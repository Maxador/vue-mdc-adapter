/**
* @module vue-mdc-adapter 0.13.2
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.33.0"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.13.2',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var CustomElement = {
    functional: true,
    render: function render(createElement, context) {
      return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
    }
  };

  var CustomElementMixin = {
    components: {
      CustomElement: CustomElement
    }
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: { type: String, default: 'a' },
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };

  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */

  function emitCustomEvent(el, evtType, evtData) {
    var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var evt = void 0;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    el.dispatchEvent(evt);
  }

  var CustomButton = {
    name: 'custom-button',
    functional: true,
    props: {
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        data.attrs.role = 'button';
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else if (data.attrs && data.attrs.href) {
        // href case
        element = 'a';
        data.attrs.role = 'button';
      } else {
        // button fallback
        element = 'button';
      }

      return h(element, data, context.children);
    }
  };

  var CustomButtonMixin = {
    props: {
      href: String,
      disabled: Boolean,
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomButton: CustomButton
    }
  };

  function extractIconProp(iconProp) {
    if (typeof iconProp === 'string') {
      return {
        classes: { 'material-icons': true },
        content: iconProp
      };
    } else if (iconProp instanceof Array) {
      return {
        classes: iconProp.reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {})
      };
    } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
      return {
        classes: iconProp.className.split(' ').reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {}),
        content: iconProp.textContent
      };
    }
  }

  var DispatchEventMixin = {
    props: {
      'event': String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        this.$emit(evt.type);
        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
        }
      }
    }
  };

  var DispatchFocusMixin = {
    data: function data() {
      return { hasFocus: false };
    },

    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_ = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_ = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables_;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables_ = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables_ = false;
    }
    return supportsCssVariables_;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {!{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {!{x: number, y: number}}
   */
  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {!{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'isSupported_',
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }
    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.registerRootHandlers_();

        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
          }
          _this2.layoutInternal_();
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      /** @private */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;

        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        requestAnimationFrame(function () {
          // This needs to be wrapped in an rAF call b/c web browsers
          // report active states inconsistently when they're called within
          // event handling code:
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
          // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
          activationState.wasElementMadeActive = e && e.type === 'keydown' ? _this9.adapter_.isSurfaceActive() : true;
          if (activationState.wasElementMadeActive) {
            _this9.animateActivation_();
          } else {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }

          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];
        });
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  var RippleBase = function (_MDCRippleFoundation) {
    inherits(RippleBase, _MDCRippleFoundation);
    createClass(RippleBase, null, [{
      key: 'isSurfaceActive',
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: 'MATCHES',
      get: function get$$1() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      classCallCheck(this, RippleBase);
      return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },

        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler);
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);

  var RippleMixin = {
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var mdcRipple = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-ripple", attrs: { "tag": _vm.tag, "classes": _vm.classes, "styles": _vm.styles } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-ripple',
    mixins: [CustomElementMixin, RippleMixin],
    props: {
      tag: String
    }
  };

  var VueMDCRipple = BasePlugin({
    mdcRipple: mdcRipple
  });

  var mdcButtonBase = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { ref: "root", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link, "disabled": _vm.disabled }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-button-base',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcButton = {
    name: 'mdc-button',
    extends: mdcButtonBase,
    props: {
      raised: Boolean,
      unelevated: Boolean,
      stroked: Boolean,
      dense: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-button--raised': this.raised,
          'mdc-button--unelevated': this.unelevated,
          'mdc-button--stroked': this.stroked,
          'mdc-button--dense': this.dense,
          'mdc-button--accent': this.accent
        }
      };
    },

    watch: {
      raised: function raised() {
        this.$set(this.classes, 'mdc-button--raised', this.raised);
      },
      unelevated: function unelevated() {
        this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
      },
      stroked: function stroked() {
        this.$set(this.classes, 'mdc-button--stroked', this.stroked);
      },
      dense: function dense() {
        this.$set(this.classes, 'mdc-button--dense', this.dense);
      },
      accent: function accent() {
        this.$set(this.classes, 'mdc-button--accent', this.accent);
      }
    }
  };

  var VueMDCButton = BasePlugin({
    mdcButton: mdcButton
  });

  var mdcCard = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card", class: { 'mdc-card--stroked': _vm.stroked } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: "mdc-card",
    props: {
      stroked: Boolean
    }
  };

  var mdcCardPrimaryAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-card-primary-action mdc-card__primary-action", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-primary-action',
    mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcCardMedia = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-media mdc-card__media", class: _vm.classes, style: _vm.styles }, [_vm.$slots.default ? _c('div', { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: "mdc-card-media",
    props: {
      src: String,
      'square': Boolean
    },
    computed: {
      styles: function styles() {
        var styles = {
          backgroundImage: 'url(' + this.src + ')'
        };

        return styles;
      },
      classes: function classes() {
        return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
      }
    }
  };

  var mdcCardHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c('h1', { staticClass: "mdc-card__title", class: { 'mdc-card__title--large': _vm.largeTitle } }, [_vm._v(" " + _vm._s(_vm.title) + " ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c('h2', { staticClass: "mdc-card__subtitle" }, [_vm._v(" " + _vm._s(_vm.subtitle) + " ")]) : _vm._e()])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-header',
    props: {
      'title': String,
      'subtitle': String,
      'large-title': { type: Boolean, default: true }
    }
  };

  var mdcCardTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h1', { staticClass: "mdc-card-title mdc-card__title", class: { 'mdc-card__title--large': _vm.large } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-title',
    props: {
      'large': Boolean
    }
  };

  var mdcCardSubtitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h2', { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-subtitle'
  };

  var mdcCardText = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-text'
  };

  var mdcCardActions = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-actions',
    props: {
      fullBleed: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-card__actions--full-bleed': this.fullBleed
        };
      }
    }
  };

  var mdcCardActionButtons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: "mdc-card-action-buttons"
  };

  var mdcCardActionButton = {
    name: 'mdc-card-action-button',
    extends: mdcButtonBase,
    props: {
      compact: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-card__action': true,
          'mdc-card-action-button': true,
          'mdc-button--compact': this.compact,
          'mdc-button--accent': this.accent
        }
      };
    },

    watch: {
      compact: function compact() {
        this.$set(this.classes, 'mdc-button--compact', this.compact);
      },
      accent: function accent() {
        this.$set(this.classes, 'mdc-button--accent', this.accent);
      }
    }
  };

  var mdcCardActionIcons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: "mdc-card-action-icons"
  };

  var mdcCardActionIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { class: _vm.classes, style: _vm.styles, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    },
    data: function data() {
      return {
        classes: {
          'mdc-card-action-icon': true,
          'material-icons': !!this.icon,
          'mdc-card__action': true,
          'mdc-card__action--icon': true,
          'mdc-icon-toggle': true
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', !!this.icon);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var VueMDCCard = BasePlugin({
    mdcCard: mdcCard,
    mdcCardPrimaryAction: mdcCardPrimaryAction,
    mdcCardMedia: mdcCardMedia,
    mdcCardHeader: mdcCardHeader,
    mdcCardTitle: mdcCardTitle,
    mdcCardSubtitle: mdcCardSubtitle,
    mdcCardText: mdcCardText,
    mdcCardActions: mdcCardActions,
    mdcCardActionButtons: mdcCardActionButtons,
    mdcCardActionButton: mdcCardActionButton,
    mdcCardActionIcons: mdcCardActionIcons,
    mdcCardActionIcon: mdcCardActionIcon
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template F
   */

  var MDCComponent = function () {
    createClass(MDCComponent, null, [{
      key: 'attachTo',

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }

      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args);
      // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.
      /** @protected {!F} */
      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    createClass(MDCComponent, [{
      key: 'initialize',
      value: function initialize() /* ...args */{}
      // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.


      /**
       * @return {!F} foundation
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }

      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'listen',
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }

      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'unlisten',
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);
    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple = function (_MDCComponent) {
    inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _ref;

      classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @type {boolean} */
      var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

      _this.disabled = false;

      /** @private {boolean} */
      _this.unbounded_;
      return _this;
    }

    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    createClass(MDCRipple, [{
      key: 'setUnbounded_',


      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: 'activate',
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.foundation_.layout();
      }

      /** @return {!MDCRippleFoundation} */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: 'unbounded',


      /** @return {boolean} */
      get: function get$$1() {
        return this.unbounded_;
      }

      /** @param {boolean} unbounded */
      ,
      set: function set$$1(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$isUnbounded = _ref2.isUnbounded,
            isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (isUnbounded !== undefined) {
          ripple.unbounded = /** @type {boolean} */isUnbounded;
        }
        return ripple;
      }

      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: 'createAdapter',
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);

        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        };
      }
    }]);
    return MDCRipple;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @record
   */

  var MDCSelectionControl = function () {
    function MDCSelectionControl() {
      classCallCheck(this, MDCSelectionControl);
    }

    createClass(MDCSelectionControl, [{
      key: 'ripple',

      /** @return {?MDCRipple} */
      get: function get$$1() {}
    }]);
    return MDCSelectionControl;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Checkbox. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCCheckboxAdapter = function () {
    function MDCCheckboxAdapter() {
      classCallCheck(this, MDCCheckboxAdapter);
    }

    createClass(MDCCheckboxAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Sets an attribute with a given value on the input element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: 'setNativeControlAttr',
      value: function setNativeControlAttr(attr, value) {}

      /**
       * Removes an attribute from the input element.
       * @param {string} attr
       */

    }, {
      key: 'removeNativeControlAttr',
      value: function removeNativeControlAttr(attr) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerAnimationEndHandler',
      value: function registerAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterAnimationEndHandler',
      value: function deregisterAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerChangeHandler',
      value: function registerChangeHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterChangeHandler',
      value: function deregisterChangeHandler(handler) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }, {
      key: 'forceLayout',
      value: function forceLayout() {}

      /** @return {boolean} */

    }, {
      key: 'isAttachedToDOM',
      value: function isAttachedToDOM() {}
    }]);
    return MDCCheckboxAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {string} */
  var ROOT = 'mdc-checkbox';

  /** @enum {string} */
  var cssClasses$1 = {
    UPGRADED: 'mdc-checkbox--upgraded',
    CHECKED: 'mdc-checkbox--checked',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    DISABLED: 'mdc-checkbox--disabled',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
  };

  /** @enum {string} */
  var strings$1 = {
    NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
  };

  /** @enum {number} */
  var numbers$1 = {
    ANIM_END_LATCH_MS: 250
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {!Array<string>} */
  var CB_PROTO_PROPS = ['checked', 'indeterminate'];

  /**
   * @extends {MDCFoundation<!MDCCheckboxAdapter>}
   */

  var MDCCheckboxFoundation = function (_MDCFoundation) {
    inherits(MDCCheckboxFoundation, _MDCFoundation);
    createClass(MDCCheckboxFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$1;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$1;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$1;
      }

      /** @return {!MDCCheckboxAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCCheckboxAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setNativeControlAttr: function setNativeControlAttr() {},
            removeNativeControlAttr: function removeNativeControlAttr() {},
            registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
            deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
            registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
            deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
            forceLayout: function forceLayout() {},
            isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
          }
        );
      }
    }]);

    function MDCCheckboxFoundation(adapter) {
      classCallCheck(this, MDCCheckboxFoundation);

      /** @private {string} */
      var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

      _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;

      /** @private {string} */
      _this.currentAnimationClass_ = '';

      /** @private {number} */
      _this.animEndLatchTimer_ = 0;

      _this.animEndHandler_ = /** @private {!EventListener} */function () {
        return _this.handleAnimationEnd();
      };

      _this.changeHandler_ = /** @private {!EventListener} */function () {
        return _this.handleChange();
      };
      return _this;
    }

    createClass(MDCCheckboxFoundation, [{
      key: 'init',
      value: function init() {
        this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
        this.adapter_.addClass(cssClasses$1.UPGRADED);
        this.adapter_.registerChangeHandler(this.changeHandler_);
        this.installPropertyChangeHooks_();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterChangeHandler(this.changeHandler_);
        this.uninstallPropertyChangeHooks_();
      }

      /** @return {boolean} */

    }, {
      key: 'isChecked',
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isIndeterminate',
      value: function isIndeterminate() {
        return this.getNativeControl_().indeterminate;
      }

      /** @param {boolean} indeterminate */

    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        this.getNativeControl_().indeterminate = indeterminate;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(cssClasses$1.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$1.DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * Handles the animationend event for the checkbox
       */

    }, {
      key: 'handleAnimationEnd',
      value: function handleAnimationEnd() {
        var _this2 = this;

        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
          _this2.adapter_.removeClass(_this2.currentAnimationClass_);
          _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
        }, numbers$1.ANIM_END_LATCH_MS);
      }

      /**
       * Handles the change event for the checkbox
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        this.transitionCheckState_();
      }

      /** @private */

    }, {
      key: 'installPropertyChangeHooks_',
      value: function installPropertyChangeHooks_() {
        var _this3 = this;

        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
          // We have to check for this descriptor, since some browsers (Safari) don't support its return.
          // See: https://bugs.webkit.org/show_bug.cgi?id=49739
          if (validDescriptor(desc)) {
            var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
              get: desc.get,
              set: function set$$1(state) {
                desc.set.call(nativeCb, state);
                _this3.transitionCheckState_();
              },
              configurable: desc.configurable,
              enumerable: desc.enumerable
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
          }
        });
      }

      /** @private */

    }, {
      key: 'uninstallPropertyChangeHooks_',
      value: function uninstallPropertyChangeHooks_() {
        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
          if (validDescriptor(desc)) {
            Object.defineProperty(nativeCb, controlState, desc);
          }
        });
      }

      /** @private */

    }, {
      key: 'transitionCheckState_',
      value: function transitionCheckState_() {
        var nativeCb = this.adapter_.getNativeControl();
        if (!nativeCb) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_(nativeCb);
        if (oldState === newState) {
          return;
        }

        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.isIndeterminate()) {
          this.adapter_.setNativeControlAttr(strings$1.ARIA_CHECKED_ATTR, strings$1.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter_.removeNativeControlAttr(strings$1.ARIA_CHECKED_ATTR);
        }

        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter_.forceLayout();
          this.adapter_.removeClass(this.currentAnimationClass_);
        }

        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;

        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter_.addClass(this.currentAnimationClass_);
          this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
        }
      }

      /**
       * @param {!MDCSelectionControlState} nativeCb
       * @return {string}
       * @private
       */

    }, {
      key: 'determineCheckState_',
      value: function determineCheckState_(nativeCb) {
        var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;


        if (nativeCb.indeterminate) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      }

      /**
       * @param {string} oldState
       * @param {string} newState
       * @return {string}
       */

    }, {
      key: 'getTransitionAnimationClass_',
      value: function getTransitionAnimationClass_(oldState, newState) {
        var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
        var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return '';
            }
          // fallthrough
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          // TRANSITION_STATE_INDETERMINATE
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          indeterminate: false,
          disabled: false,
          value: null
        };
      }
    }]);
    return MDCCheckboxFoundation;
  }(MDCFoundation);

  /**
   * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
   * @return {boolean}
   */


  function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Form Field. Provides an interface for managing
   * - event handlers
   * - ripple activation
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCFormFieldAdapter = function () {
    function MDCFormFieldAdapter() {
      classCallCheck(this, MDCFormFieldAdapter);
    }

    createClass(MDCFormFieldAdapter, [{
      key: "registerInteractionHandler",

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
    }, {
      key: "activateInputRipple",
      value: function activateInputRipple() {}
    }, {
      key: "deactivateInputRipple",
      value: function deactivateInputRipple() {}
    }]);
    return MDCFormFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$2 = {
    ROOT: 'mdc-form-field'
  };

  /** @enum {string} */
  var strings$2 = {
    LABEL_SELECTOR: '.mdc-form-field > label'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFormFieldAdapter>}
   */

  var MDCFormFieldFoundation = function (_MDCFoundation) {
    inherits(MDCFormFieldFoundation, _MDCFoundation);
    createClass(MDCFormFieldFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$2;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$2;
      }

      /** @return {!MDCFormFieldAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          activateInputRipple: function activateInputRipple() {},
          deactivateInputRipple: function deactivateInputRipple() {}
        };
      }
    }]);

    function MDCFormFieldFoundation(adapter) {
      classCallCheck(this, MDCFormFieldFoundation);

      /** @private {!EventListener} */
      var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = /** @type {!EventListener} */function () {
        return _this.handleClick_();
      };
      return _this;
    }

    createClass(MDCFormFieldFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      }

      /** @private */

    }, {
      key: 'handleClick_',
      value: function handleClick_() {
        var _this2 = this;

        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
          return _this2.adapter_.deactivateInputRipple();
        });
      }
    }]);
    return MDCFormFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {Object<string, !VendorPropertyMapType>} */
  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };

  /** @const {Object<string, !VendorPropertyMapType>} */
  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };

  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */
  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }

  /**
   * @param {string} eventType
   * @return {boolean}
   */
  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }

  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */
  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  }

  // Public functions to access getAnimationName() for JavaScript events or CSS
  // property names.

  var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  var mdcCheckbox = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-checkbox", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-checkbox__native-control", attrs: { "id": _vm._uid, "type": "checkbox", "name": _vm.name }, domProps: { "value": _vm.value }, on: { "change": _vm.onChange } }), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__background" }, [_c('svg', { staticClass: "mdc-checkbox__checkmark", attrs: { "viewBox": "0 0 24 24" } }, [_c('path', { staticClass: "checkbox__checkmark-path", attrs: { "fill": "none", "stroke": "white", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-checkbox',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: Boolean,
      indeterminate: Boolean,
      disabled: Boolean,
      label: String,
      'align-end': Boolean,
      value: {
        type: String,
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      },
      formFieldClasses: function formFieldClasses() {
        return {
          'mdc-form-field': this.hasLabel,
          'mdc-form-field--align-end': this.hasLabel && this.alignEnd
        };
      }
    },
    watch: {
      checked: function checked(value) {
        this.foundation.setChecked(value);
      },
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      },
      indeterminate: function indeterminate(value) {
        this.foundation.setIndeterminate(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCCheckboxFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlAttr: function setNativeControlAttr(attr, value) {
          _this.$refs.control.setAttribute(attr, value);
        },
        removeNativeControlAttr: function removeNativeControlAttr(attr) {
          _this.$refs.control.removeAttribute(attr);
        },
        registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
          return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
          return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        registerChangeHandler: function registerChangeHandler(handler) {
          return _this.$refs.control.addEventListener('change', handler);
        },
        deregisterChangeHandler: function deregisterChangeHandler(handler) {
          return _this.$refs.control.removeEventListener('change', handler);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        },
        forceLayout: function forceLayout() {
          return _this.$refs.root.offsetWidth;
        },
        isAttachedToDOM: function isAttachedToDOM() {
          return Boolean(_this.$el.parentNode);
        }
      });

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return RippleBase.isSurfaceActive(_this.$refs.control);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.foundation.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setIndeterminate(this.indeterminate);
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      onChange: function onChange() {
        this.$emit('update:indeterminate', this.foundation.isIndeterminate());
        this.$emit('change', this.foundation.isChecked());
      }
    }
  };

  var VueMDCCheckbox = BasePlugin({
    mdcCheckbox: mdcCheckbox
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipAdapter = function () {
    function MDCChipAdapter() {
      classCallCheck(this, MDCChipAdapter);
    }

    createClass(MDCChipAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Adds a class to the leading icon element.
       * @param {string} className
       */

    }, {
      key: "addClassToLeadingIcon",
      value: function addClassToLeadingIcon(className) {}

      /**
       * Removes a class from the leading icon element.
       * @param {string} className
       */

    }, {
      key: "removeClassFromLeadingIcon",
      value: function removeClassFromLeadingIcon(className) {}

      /**
       * Returns true if target has className, false otherwise.
       * @param {!EventTarget} target
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "eventTargetHasClass",
      value: function eventTargetHasClass(target, className) {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}

      /**
       * Registers an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerTrailingIconInteractionHandler",
      value: function registerTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterTrailingIconInteractionHandler",
      value: function deregisterTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom "MDCChip:interaction" event denoting the chip has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyInteraction",
      value: function notifyInteraction() {}

      /**
       * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyTrailingIconInteraction",
      value: function notifyTrailingIconInteraction() {}
    }]);
    return MDCChipAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$3 = {
    INTERACTION_EVENT: 'MDCChip:interaction',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
  };

  /** @enum {string} */
  var cssClasses$3 = {
    CHECKMARK: 'mdc-chip__checkmark',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--hidden-leading',
    LEADING_ICON: 'mdc-chip__icon--leading',
    SELECTED: 'mdc-chip--selected'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipAdapter>}
   * @final
   */

  var MDCChipFoundation = function (_MDCFoundation) {
    inherits(MDCChipFoundation, _MDCFoundation);
    createClass(MDCChipFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$3;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$3;
      }

      /**
       * {@see MDCChipAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            addClassToLeadingIcon: function addClassToLeadingIcon() {},
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
            eventTargetHasClass: function eventTargetHasClass() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {},
            registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler() {},
            deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler() {},
            notifyInteraction: function notifyInteraction() {},
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {}
          }
        );
      }

      /**
       * @param {!MDCChipAdapter} adapter
       */

    }]);

    function MDCChipFoundation(adapter) {
      classCallCheck(this, MDCChipFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction_(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.trailingIconInteractionHandler_ = function (evt) {
        return _this.handleTrailingIconInteraction_(evt);
      };
      return _this;
    }

    createClass(MDCChipFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerEventHandler(evtType, _this2.interactionHandler_);
        });
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this2.adapter_.registerTrailingIconInteractionHandler(evtType, _this2.trailingIconInteractionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterEventHandler(evtType, _this3.interactionHandler_);
        });
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTrailingIconInteractionHandler(evtType, _this3.trailingIconInteractionHandler_);
        });
      }

      /**
       * Toggles the selected class on the chip element.
       */

    }, {
      key: 'toggleSelected',
      value: function toggleSelected() {
        if (this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.removeClass(cssClasses$3.SELECTED);
        } else {
          this.adapter_.addClass(cssClasses$3.SELECTED);
        }
      }

      /**
       * Handles an interaction event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction_',
      value: function handleInteraction_(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyInteraction();
        }
      }

      /**
       * Handles a transition end event on the root element.
       * This is a proxy for handling a transition end event on the leading icon or checkmark,
       * since the transition end event bubbles.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (evt.propertyName !== 'opacity') {
          return;
        }
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.LEADING_ICON) && this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.addClassToLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        } else if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.CHECKMARK) && !this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.removeClassFromLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        }
      }

      /**
       * Handles an interaction event on the trailing icon element. This is used to
       * prevent the ripple from activating on interaction with the trailing icon.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTrailingIconInteraction_',
      value: function handleTrailingIconInteraction_(evt) {
        evt.stopPropagation();
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyTrailingIconInteraction();
        }
      }
    }]);
    return MDCChipFoundation;
  }(MDCFoundation);

  var mdcChip = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "0" } }, [_vm.haveleadingIcon ? _c('i', { ref: "leadingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--leading", class: _vm.leadingClasses }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _vm.isFilter ? _c('div', { staticClass: "mdc-chip__checkmark" }, [_c('svg', { staticClass: "mdc-chip__checkmark-svg", attrs: { "viewBox": "-2 -3 30 30" } }, [_c('path', { staticClass: "mdc-chip__checkmark-path", attrs: { "fill": "none", "stroke": "black", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })])]) : _vm._e(), _vm._v(" "), _c('div', { staticClass: "mdc-chip__text" }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c('i', { ref: "trailingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--trailing", class: _vm.trailingClasses, attrs: { "tabindex": "0", "role": "button" } }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-chip',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      leadingIcon: [String],
      trailingIcon: [String],
      leadingIconClasses: [Object],
      trailingIconClasses: [Object]
    },
    inject: ['mdcChipSet'],
    data: function data() {
      return {
        classes: {
          'mdc-chip': true
        },
        styles: {}
      };
    },

    methods: {
      toggleSelected: function toggleSelected() {
        this.foundation.toggleSelected();
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          return _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          return _this.$el.removeEventListener(evtType, handler);
        },
        notifyInteraction: function notifyInteraction() {
          _this.dispatchEvent({ type: 'click' });
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.INTERACTION_EVENT, {
            chip: _this
          }, true);
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          _this.dispatchEvent({ type: 'trailingIconClick' });
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.TRAILING_ICON_INTERACTION_EVENT, {
            chip: _this
          }, true);
        },

        registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.addEventListener(evtType, handler);
          }
        },
        deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.removeEventListener(evtType, handler);
          }
        }
      });

      this.foundation.init();

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },

    computed: {
      isFilter: function isFilter() {
        return this.mdcChipSet && this.mdcChipSet.filter;
      },
      haveleadingIcon: function haveleadingIcon() {
        return !!this.leadingIcon || this.leadingIconClasses;
      },
      havetrailingIcon: function havetrailingIcon() {
        return !!this.trailingIcon || this.trailingIconClasses;
      },
      leadingClasses: function leadingClasses() {
        return _extends({}, {
          'material-icons': !!this.leadingIcon
        }, this.leadingIconClasses);
      },
      trailingClasses: function trailingClasses() {
        return _extends({}, {
          'material-icons': !!this.trailingIcon
        }, this.trailingIconClasses);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    }
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip Set.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip Set into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipSetAdapter = function () {
    function MDCChipSetAdapter() {
      classCallCheck(this, MDCChipSetAdapter);
    }

    createClass(MDCChipSetAdapter, [{
      key: "hasClass",

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);
    return MDCChipSetAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCComponent<!MDCChipFoundation>}
   * @final
   */

  var MDCChip = function (_MDCComponent) {
    inherits(MDCChip, _MDCComponent);

    /**
     * @param {...?} args
     */
    function MDCChip() {
      var _ref;

      classCallCheck(this, MDCChip);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @private {?Element} */
      var _this = possibleConstructorReturn(this, (_ref = MDCChip.__proto__ || Object.getPrototypeOf(MDCChip)).call.apply(_ref, [this].concat(args)));

      _this.leadingIcon_ = _this.root_.querySelector(strings$3.LEADING_ICON_SELECTOR);
      /** @private {!MDCRipple} */
      _this.ripple_ = new MDCRipple(_this.root_);
      return _this;
    }

    /**
     * @param {!Element} root
     * @return {!MDCChip}
     */


    createClass(MDCChip, [{
      key: 'destroy',
      value: function destroy() {
        this.ripple_.destroy();
        get(MDCChip.prototype.__proto__ || Object.getPrototypeOf(MDCChip.prototype), 'destroy', this).call(this);
      }

      /**
       * Toggles selected state of the chip.
       */

    }, {
      key: 'toggleSelected',
      value: function toggleSelected() {
        this.foundation_.toggleSelected();
      }

      /**
       * @return {!MDCChipFoundation}
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCChipFoundation( /** @type {!MDCChipAdapter} */_extends({
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this2.root_.classList.contains(className);
          },
          addClassToLeadingIcon: function addClassToLeadingIcon(className) {
            if (_this2.leadingIcon_) {
              _this2.leadingIcon_.classList.add(className);
            }
          },
          removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
            if (_this2.leadingIcon_) {
              _this2.leadingIcon_.classList.remove(className);
            }
          },
          eventTargetHasClass: function eventTargetHasClass(target, className) {
            return target.classList.contains(className);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            return _this2.root_.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            return _this2.root_.removeEventListener(evtType, handler);
          },
          registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler(evtType, handler) {
            var trailingIconEl = _this2.root_.querySelector(strings$3.TRAILING_ICON_SELECTOR);
            if (trailingIconEl) {
              trailingIconEl.addEventListener(evtType, handler);
            }
          },
          deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler(evtType, handler) {
            var trailingIconEl = _this2.root_.querySelector(strings$3.TRAILING_ICON_SELECTOR);
            if (trailingIconEl) {
              trailingIconEl.removeEventListener(evtType, handler);
            }
          },
          notifyInteraction: function notifyInteraction() {
            return _this2.emit(strings$3.INTERACTION_EVENT, { chip: _this2 }, true /* shouldBubble */);
          },
          notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
            return _this2.emit(strings$3.TRAILING_ICON_INTERACTION_EVENT, { chip: _this2 }, true /* shouldBubble */);
          }
        }));
      }

      /** @return {!MDCRipple} */

    }, {
      key: 'ripple',
      get: function get$$1() {
        return this.ripple_;
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        return new MDCChip(root);
      }
    }]);
    return MDCChip;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$4 = {
    CHIP_SELECTOR: '.mdc-chip'
  };

  /** @enum {string} */
  var cssClasses$4 = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipSetAdapter>}
   * @final
   */

  var MDCChipSetFoundation = function (_MDCFoundation) {
    inherits(MDCChipSetFoundation, _MDCFoundation);
    createClass(MDCChipSetFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$4;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$4;
      }

      /**
       * {@see MDCChipSetAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipSetAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipSetAdapter} */{
            hasClass: function hasClass() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }

      /**
       * @param {!MDCChipSetAdapter} adapter
       */

    }]);

    function MDCChipSetFoundation(adapter) {
      classCallCheck(this, MDCChipSetFoundation);

      /**
       * The selected chips in the set. Only used for choice chip set or filter chip set.
       * @private {!Array<!MDCChip>}
       */
      var _this = possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));

      _this.selectedChips_ = [];

      /** @private {function(!Event): undefined} */
      _this.chipInteractionHandler_ = function (evt) {
        return _this.handleChipInteraction_(evt);
      };
      return _this;
    }

    createClass(MDCChipSetFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
      }

      /**
       * Handles a chip interaction event
       * @param {!Object} evt
       * @private
       */

    }, {
      key: 'handleChipInteraction_',
      value: function handleChipInteraction_(evt) {
        var chip = evt.detail.chip;

        if (this.adapter_.hasClass(cssClasses$4.CHOICE)) {
          if (this.selectedChips_.length === 0) {
            this.selectedChips_[0] = chip;
          } else if (this.selectedChips_[0] !== chip) {
            this.selectedChips_[0].toggleSelected();
            this.selectedChips_[0] = chip;
          } else {
            this.selectedChips_ = [];
          }
          chip.toggleSelected();
        } else if (this.adapter_.hasClass(cssClasses$4.FILTER)) {
          var index = this.selectedChips_.indexOf(chip);
          if (index >= 0) {
            this.selectedChips_.splice(index, 1);
          } else {
            this.selectedChips_.push(chip);
          }
          chip.toggleSelected();
        }
      }
    }]);
    return MDCChipSetFoundation;
  }(MDCFoundation);

  var mdcChipSet = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-chip-set',
    props: {
      choice: [Boolean],
      filter: [Boolean]
    },
    provide: function provide() {
      return { mdcChipSet: this };
    },
    data: function data() {
      return {
        classes: {
          'mdc-chip-set': true,
          'mdc-chip-set--choice': this.choice,
          'mdc-chip-set--filter': this.filter
        }
      };
    },

    methods: {},
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipSetFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCChipSet = BasePlugin({
    mdcChip: mdcChip,
    mdcChipSet: mdcChipSet
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$5 = {
    ROOT: 'mdc-dialog',
    OPEN: 'mdc-dialog--open',
    ANIMATING: 'mdc-dialog--animating',
    BACKDROP: 'mdc-dialog__backdrop',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
    CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
  };

  var strings$5 = {
    OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
    DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
    ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
    ACCEPT_EVENT: 'MDCDialog:accept',
    CANCEL_EVENT: 'MDCDialog:cancel'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCDialogFoundation = function (_MDCFoundation) {
    inherits(MDCDialogFoundation, _MDCFoundation);
    createClass(MDCDialogFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$5;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$5;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyAccept: function notifyAccept() {},
          notifyCancel: function notifyCancel() {},
          trapFocusOnSurface: function trapFocusOnSurface() {},
          untrapFocusOnSurface: function untrapFocusOnSurface() {},
          isDialog: function isDialog() {
            return (/* el: Element */ /* boolean */false
            );
          },
          layoutFooterRipples: function layoutFooterRipples() {}
        };
      }
    }]);

    function MDCDialogFoundation(adapter) {
      classCallCheck(this, MDCDialogFoundation);

      var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

      _this.isOpen_ = false;
      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$5.BACKDROP)) {
          _this.cancel(true);
        }
      };
      _this.dialogClickHandler_ = function (evt) {
        return _this.handleDialogClick_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.cancel(true);
        }
      };
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };
      return _this;
    }

    createClass(MDCDialogFoundation, [{
      key: 'destroy',
      value: function destroy() {
        // Ensure that dialog is cleaned up when destroyed
        if (this.isOpen_) {
          this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.adapter_.untrapFocusOnSurface();
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
          this.enableScroll_();
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.isOpen_ = true;
        this.disableScroll_();
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'close',
      value: function close() {
        this.isOpen_ = false;
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }
    }, {
      key: 'accept',
      value: function accept(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyAccept();
        }

        this.close();
      }
    }, {
      key: 'cancel',
      value: function cancel(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyCancel();
        }

        this.close();
      }
    }, {
      key: 'handleDialogClick_',
      value: function handleDialogClick_(evt) {
        var target = evt.target;

        if (this.adapter_.eventTargetHasClass(target, cssClasses$5.ACCEPT_BTN)) {
          this.accept(true);
        } else if (this.adapter_.eventTargetHasClass(target, cssClasses$5.CANCEL_BTN)) {
          this.cancel(true);
        }
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.adapter_.isDialog(evt.target)) {
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          if (this.isOpen_) {
            this.adapter_.trapFocusOnSurface();
            this.adapter_.layoutFooterRipples();
          } else {
            this.enableScroll_();
          }      }    }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }]);
    return MDCDialogFoundation;
  }(MDCFoundation);

  var tabbable = function (el, options) {
    options = options || {};

    var elementDocument = el.ownerDocument || el;
    var basicTabbables = [];
    var orderedTabbables = [];

    // A node is "available" if
    // - it's computed style
    var isUnavailable = createIsUnavailable(elementDocument);

    var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

    var candidates = el.querySelectorAll(candidateSelectors.join(','));

    if (options.includeContainer) {
      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

      if (candidateSelectors.some(function (candidateSelector) {
        return matches.call(el, candidateSelector);
      })) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var candidate, candidateIndex;
    for (var i = 0, l = candidates.length; i < l; i++) {
      candidate = candidates[i];
      candidateIndex = parseInt(candidate.getAttribute('tabindex'), 10) || candidate.tabIndex;

      if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
        continue;
      }

      if (candidateIndex === 0) {
        basicTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          index: i,
          tabIndex: candidateIndex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(function (a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    }).map(function (a) {
      return a.node;
    });

    Array.prototype.push.apply(tabbableNodes, basicTabbables);

    return tabbableNodes;
  };

  function createIsUnavailable(elementDocument) {
    // Node cache must be refreshed on every check, in case
    // the content of the element has changed
    var isOffCache = [];

    // "off" means `display: none;`, as opposed to "hidden",
    // which means `visibility: hidden;`. getComputedStyle
    // accurately reflects visiblity in context but not
    // "off" state, so we need to recursively check parents.

    function isOff(node, nodeComputedStyle) {
      if (node === elementDocument.documentElement) return false;

      // Find the cached node (Array.prototype.find not available in IE9)
      for (var i = 0, length = isOffCache.length; i < length; i++) {
        if (isOffCache[i][0] === node) return isOffCache[i][1];
      }

      nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = isOff(node.parentNode);
      }

      isOffCache.push([node, result]);

      return result;
    }

    return function isUnavailable(node) {
      if (node === elementDocument.documentElement) return false;

      var computedStyle = elementDocument.defaultView.getComputedStyle(node);

      if (isOff(node, computedStyle)) return true;

      return computedStyle.visibility === 'hidden';
    };
  }

  var listeningFocusTrap = null;

  function focusTrap(element, userOptions) {
    var tabbableNodes = [];
    var firstTabbableNode = null;
    var lastTabbableNode = null;
    var nodeFocusedBeforeActivation = null;
    var active = false;
    var paused = false;
    var tabEvent = null;

    var container = typeof element === 'string' ? document.querySelector(element) : element;

    var config = userOptions || {};
    config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
    config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };

    return trap;

    function activate(activateOptions) {
      if (active) return;

      var defaultedActivateOptions = {
        onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
      };

      active = true;
      paused = false;
      nodeFocusedBeforeActivation = document.activeElement;

      if (defaultedActivateOptions.onActivate) {
        defaultedActivateOptions.onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!active) return;

      var defaultedDeactivateOptions = {
        returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
        onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
      };

      removeListeners();

      if (defaultedDeactivateOptions.onDeactivate) {
        defaultedDeactivateOptions.onDeactivate();
      }

      if (defaultedDeactivateOptions.returnFocus) {
        setTimeout(function () {
          tryFocus(nodeFocusedBeforeActivation);
        }, 0);
      }

      active = false;
      paused = false;
      return this;
    }

    function pause() {
      if (paused || !active) return;
      paused = true;
      removeListeners();
    }

    function unpause() {
      if (!paused || !active) return;
      paused = false;
      addListeners();
    }

    function addListeners() {
      if (!active) return;

      // There can be only one listening focus trap at a time
      if (listeningFocusTrap) {
        listeningFocusTrap.pause();
      }
      listeningFocusTrap = trap;

      updateTabbableNodes();
      tryFocus(firstFocusNode());
      document.addEventListener('focus', checkFocus, true);
      document.addEventListener('click', checkClick, true);
      document.addEventListener('mousedown', checkPointerDown, true);
      document.addEventListener('touchstart', checkPointerDown, true);
      document.addEventListener('keydown', checkKey, true);

      return trap;
    }

    function removeListeners() {
      if (!active || listeningFocusTrap !== trap) return;

      document.removeEventListener('focus', checkFocus, true);
      document.removeEventListener('click', checkClick, true);
      document.removeEventListener('mousedown', checkPointerDown, true);
      document.removeEventListener('touchstart', checkPointerDown, true);
      document.removeEventListener('keydown', checkKey, true);

      listeningFocusTrap = null;

      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;
      if (!optionValue) {
        return null;
      }
      if (typeof optionValue === 'string') {
        node = document.querySelector(optionValue);
        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }
      if (typeof optionValue === 'function') {
        node = optionValue();
        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }
      return node;
    }

    function firstFocusNode() {
      var node;
      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(document.activeElement)) {
        node = document.activeElement;
      } else {
        node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error('You can\'t have a focus-trap without at least one focusable element');
      }

      return node;
    }

    // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event
    function checkPointerDown(e) {
      if (config.clickOutsideDeactivates && !container.contains(e.target)) {
        deactivate({ returnFocus: false });
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function checkFocus(e) {
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      // Checking for a blur method here resolves a Firefox issue (#15)
      if (typeof e.target.blur === 'function') e.target.blur();

      if (tabEvent) {
        readjustFocus(tabEvent);
      }
    }

    function checkKey(e) {
      if (e.key === 'Tab' || e.keyCode === 9) {
        handleTab(e);
      }

      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        deactivate();
      }
    }

    function handleTab(e) {
      updateTabbableNodes();

      if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
        return tabEvent = e;
      }

      e.preventDefault();
      var currentFocusIndex = tabbableNodes.indexOf(e.target);

      if (e.shiftKey) {
        if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
          return tryFocus(lastTabbableNode);
        }
        return tryFocus(tabbableNodes[currentFocusIndex - 1]);
      }

      if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

      tryFocus(tabbableNodes[currentFocusIndex + 1]);
    }

    function updateTabbableNodes() {
      tabbableNodes = tabbable(container);
      firstTabbableNode = tabbableNodes[0];
      lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
    }

    function readjustFocus(e) {
      if (e.shiftKey) return tryFocus(lastTabbableNode);

      tryFocus(firstTabbableNode);
    }
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function tryFocus(node) {
    if (!node || !node.focus) return;
    if (node === document.activeElement) return;

    node.focus();
    if (node.tagName.toLowerCase() === 'input') {
      node.select();
    }
  }

  var focusTrap_1 = focusTrap;

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
    var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

    return focusTrapFactory(surfaceEl, {
      initialFocus: acceptButtonEl,
      clickOutsideDeactivates: true
    });
  }

  var mdcDialog = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { ref: "root", staticClass: "mdc-dialog", class: _vm.classes, style: _vm.styles, attrs: { "role": "alertdialog", "aria-labelledby": 'label' + _vm._uid, "aria-describedby": 'desc' + _vm._uid } }, [_c('div', { ref: "surface", staticClass: "mdc-dialog__surface", class: _vm.surfaceClasses }, [_c('header', { staticClass: "mdc-dialog__header" }, [_c('h2', { staticClass: "mdc-dialog__header__title", attrs: { "id": 'label' + _vm._uid } }, [_vm._v(" " + _vm._s(_vm.title) + " ")])]), _vm._v(" "), _c('section', { staticClass: "mdc-dialog__body", class: _vm.bodyClasses, attrs: { "id": 'desc' + _vm._uid } }, [_vm._t("default")], 2), _vm._v(" "), _c('footer', { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c('mdcButton', { ref: "cancel", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--cancel", class: { 'mdc-dialog__action': _vm.accent }, on: { "click": _vm.onCancel } }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c('mdcButton', { ref: "accept", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--accept", class: { 'mdc-dialog__action': _vm.accent }, attrs: { "disabled": _vm.acceptDisabled }, on: { "click": _vm.onAccept } }, [_vm._v(_vm._s(_vm.accept))])], 1)]), _vm._v(" "), _c('div', { staticClass: "mdc-dialog__backdrop" })]);
    }, staticRenderFns: [],
    name: 'mdc-dialog',
    props: {
      title: { type: String, required: true },
      accept: { type: String, default: 'Ok' },
      acceptDisabled: Boolean,
      cancel: { type: String, default: 'Cancel' },
      accent: Boolean,
      scrollable: Boolean
    },
    components: {
      mdcButton: mdcButton
    },
    data: function data() {
      return {
        classes: {
          'mdc-theme--dark': this.dark
        },
        styles: {},
        surfaceClasses: {},
        bodyClasses: {
          'mdc-dialog__body--scrollable': this.scrollable
        }
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);

      this.foundation = new MDCDialogFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$refs.root.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$refs.root.removeEventListener(evt, handler);
        },
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.addEventListener(evt, handler)
        },
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.removeEventListener(evt, handler)
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          return document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          return document.removeEventListener('keydown', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          return _this.$refs.surface.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          return _this.$refs.surface.removeEventListener('transitionend', handler);
        },
        notifyAccept: function notifyAccept() {
          return _this.$emit('accept');
        },
        notifyCancel: function notifyCancel() {
          return _this.$emit('cancel');
        },
        trapFocusOnSurface: function trapFocusOnSurface() {
          return _this.focusTrap.activate();
        },
        untrapFocusOnSurface: function untrapFocusOnSurface() {
          return _this.focusTrap.deactivate();
        },
        isDialog: function isDialog(el) {
          return _this.$refs.surface === el;
        },
        layoutFooterRipples: function layoutFooterRipples() {
          _this.$refs.accept.ripple.layout();
          _this.cancel && _this.$refs.cancel.ripple.layout();
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {
      onCancel: function onCancel() {
        this.foundation.cancel(true);
      },
      onAccept: function onAccept() {
        var _this2 = this;

        if (this.$listeners['validate']) {
          this.$emit('validate', {
            accept: function accept() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              return _this2.foundation.accept(notify);
            }
          });
        } else {
          this.foundation.accept(true);
        }
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      }
    }
  };

  var VueMDCDialog = BasePlugin({
    mdcDialog: mdcDialog
  });

  var mdcPermanentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-permanent-drawer',
    props: {
      'toolbar-spacer': Boolean
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
    inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
    createClass(MDCSlidableDrawerFoundation, null, [{
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          hasNecessaryDom: function hasNecessaryDom() {
            return (/* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          setTranslateX: function setTranslateX() /* value: number | null */{},
          getFocusableElements: function getFocusableElements() /* NodeList */{},
          saveElementTabState: function saveElementTabState() /* el: Element */{},
          restoreElementTabState: function restoreElementTabState() /* el: Element */{},
          makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (/* boolean */false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      classCallCheck(this, MDCSlidableDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };
      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };
      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };
      return _this;
    }

    createClass(MDCSlidableDrawerFoundation, [{
      key: 'init',
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
        // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_();
        // Debounce multiple calls
        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }
        this.isOpen_ = true;
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_();
        // Debounce multiple calls
        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }
        this.isOpen_ = false;
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: 'detabinate_',
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }

      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: 'retabinate_',
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: 'handleTouchStart_',
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;

        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: 'handleTouchMove_',
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: 'handleTouchEnd_',
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_();

        // Did the user close the drawer by more than 50%?
        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: 'newPosition_',
      get: function get$$1() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);
    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$6 = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };

  var strings$6 = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCPersistentDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$6;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      classCallCheck(this, MDCPersistentDrawerFoundation);
      return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    createClass(MDCPersistentDrawerFoundation, [{
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);
    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

  var storedTransformPropertyName_ = void 0;
  var supportsPassive_$1 = void 0;

  // Remap touch events to pointer events, if the browser doesn't support touch events.
  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';
        case 'touchmove':
          return 'pointermove';
        case 'touchend':
          return 'pointerup';
        default:
          return eventName;
      }
    }

    return eventName;
  }

  // Choose the correct transform property to use on the current browser.
  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  // Determine whether the current browser supports CSS properties.
  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }
    return false;
  }

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ? { passive: true } : false;
  }

  // Save the tab state for an element.
  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }
    el.setAttribute(TAB_DATA_HANDLED, true);
  }

  // Restore the tab state for an element, if it was saved.
  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }
      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  var mdcPersistentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-persistent-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'toolbar-spacer': Boolean,
      'open': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: function open() {
        this._refresh();
      }
    },
    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


      this.foundation = new MDCPersistentDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$7 = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };

  var strings$7 = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCTemporaryDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$7;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$7;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable() /* value: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      classCallCheck(this, MDCTemporaryDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$7.ROOT)) {
          _this.close(true);
        }
      };
      return _this;
    }

    createClass(MDCTemporaryDrawerFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

        // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.
        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: 'open',
      value: function open() {
        this.disableScroll_();
        // Make sure custom property values are cleared before starting.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
      }
    }, {
      key: 'close',
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }]);
    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var mdcTemporaryDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-temporary-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'open': Boolean,
      'toolbar-spacer': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: function open() {
        this._refresh();
      }
    },
    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
          FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
          OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


      this.foundation = new MDCTemporaryDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        updateCssVariable: function updateCssVariable(value) {
          if (supportsCssCustomProperties()) {
            _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
          }
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    }
  };

  var media = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'small',
      get: function get$$1() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: 'large',
      get: function get$$1() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);
    return _class;
  }())();

  var mdcDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": function change($event) {
            _vm.$root.$emit('mdc:layout');
          }, "open": function open($event) {
            _vm.$emit('open');
          }, "close": function close($event) {
            _vm.$emit('close');
          } }, model: { value: _vm.open_, callback: function callback($$v) {
            _vm.open_ = $$v;
          }, expression: "open_" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer',
    props: {
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean,
      drawerType: {
        type: String,
        validator: function validator(val) {
          return val in ['temporary', 'persistent', 'permanent'];
        }
      },
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: { type: Object, required: false },
      openOn: String,
      openOnSource: { type: Object, required: false },
      closeOn: String,
      closeOnSource: { type: Object, required: false }
    },
    provide: function provide() {
      return { mdcDrawer: this };
    },
    data: function data() {
      return {
        small: false,
        large: false,
        open_: false
      };
    },

    components: {
      'mdc-permanent-drawer': mdcPermanentDrawer,
      'mdc-persistent-drawer': mdcPersistentDrawer,
      'mdc-temporary-drawer': mdcTemporaryDrawer
    },
    computed: {
      type: function type() {
        if (this.permanent) {
          return 'mdc-permanent-drawer';
        } else if (this.persistent) {
          return 'mdc-persistent-drawer';
        } else if (this.temporary) {
          return 'mdc-temporary-drawer';
        } else {
          switch (this.drawerType) {
            case 'permanent':
              return 'mdc-permanent-drawer';
            case 'persistent':
              return 'mdc-persistent-drawer';
            case 'temporary':
              return 'mdc-temporary-drawer';
            default:
              return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
          }
        }
      },
      isPermanent: function isPermanent() {
        return this.permanent || this.type === 'mdc-permanent-drawer';
      },
      isPersistent: function isPersistent() {
        return this.persistent || this.type === 'mdc-persistent-drawer';
      },
      isTemporary: function isTemporary() {
        return this.temporary || this.type === 'mdc-temporary-drawer';
      },
      isResponsive: function isResponsive() {
        return !(this.permanent || this.persistent || this.temporary || this.drawerType);
      }
    },
    methods: {
      open: function open() {
        this.open_ = true;
      },
      close: function close() {
        this.isPermanent || (this.open_ = false);
      },
      toggle: function toggle() {
        this.isPermanent || (this.isOpen() ? this.close() : this.open());
      },
      isOpen: function isOpen() {
        return this.isPermanent || this.open_;
      },
      refreshMedia: function refreshMedia() {
        this.small = media.small.matches;
        this.large = media.large.matches;
        if (this.isResponsive) {
          if (this.large) {
            this.open();
          } else {
            this.close();
          }
        }
      }
    },
    created: function created() {
      if (window && window.matchMedia) {
        this.small = media.small.matches;
        this.large = media.large.matches;
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.toggleOn) {
        var source = this.toggleOnSource || this.$root;
        source.$on(this.toggleOn, function () {
          return _this.toggle();
        });
      }
      if (this.openOn) {
        var _source = this.openOnSource || this.$root;
        _source.$on(this.openOn, function () {
          return _this.open();
        });
      }
      if (this.closeOn) {
        var _source2 = this.closeOnSource || this.$root;
        _source2.$on(this.closeOn, function () {
          return _this.close();
        });
      }
      media.small.addListener(this.refreshMedia);
      media.large.addListener(this.refreshMedia);
      this.$nextTick(function () {
        return _this.refreshMedia();
      });
    },
    beforeDestroy: function beforeDestroy() {
      media.small.removeListener(this.refreshMedia);
      media.large.removeListener(this.refreshMedia);
    }
  };

  var mdcDrawerLayout = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-layout'
  };

  var mdcDrawerHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
    }, staticRenderFns: [],
    name: 'mdc-drawer-header',
    props: {
      'permanent': Boolean,
      'persistent': Boolean,
      'temporary': Boolean
    },
    inject: ['mdcDrawer'],
    computed: {
      show: function show() {
        if (this.temporary || this.persistent || this.permanent) {
          return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
        } else {
          return true;
        }
      }
    }
  };

  var mdcDrawerList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-list',
    props: {
      'dense': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  var mdcDrawerItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.onClick } }, [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      temporaryClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    methods: {
      onClick: function onClick(evt) {
        this.mdcDrawer.isTemporary && this.temporaryClose && this.mdcDrawer.close();
        this.dispatchEvent(evt);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  var mdcDrawerDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-drawer-divider'
  };

  var VueMDCDrawer = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerLayout: mdcDrawerLayout,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  var mdcElevation = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-elevation" });
    }, staticRenderFns: [],
    name: 'mdc-elevation',
    props: {}
  };

  var VueMDCElevation = BasePlugin({
    mdcElevation: mdcElevation
  });

  var mdcFAB = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { staticClass: "mdc-fab", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_c('span', { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-fab',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    props: {
      icon: String,
      mini: Boolean,
      absolute: Boolean,
      fixed: Boolean
    },
    data: function data() {
      return {
        classes: {
          'material-icons': this.icon,
          'mdc-fab--mini': this.mini,
          'mdc-fab--absolute': this.absolute,
          'mdc-fab--fixed': this.fixed
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', this.icon);
      },
      mini: function mini() {
        this.$set(this.classes, 'mdc-fab--mini', this.mini);
      }
    }
  };

  var VueMDCFab = BasePlugin({
    mdcFAB: mdcFAB
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var strings$8 = {
    TILES_SELECTOR: '.mdc-grid-list__tiles',
    TILE_SELECTOR: '.mdc-grid-tile'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCGridListFoundation = function (_MDCFoundation) {
    inherits(MDCGridListFoundation, _MDCFoundation);
    createClass(MDCGridListFoundation, null, [{
      key: 'strings',
      get: function get$$1() {
        return strings$8;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getNumberOfTiles: function getNumberOfTiles() {
            return (/* number */0
            );
          },
          getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
        };
      }
    }]);

    function MDCGridListFoundation(adapter) {
      classCallCheck(this, MDCGridListFoundation);

      var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.alignCenter();
      };
      _this.resizeFrame_ = 0;
      return _this;
    }

    createClass(MDCGridListFoundation, [{
      key: 'init',
      value: function init() {
        this.alignCenter();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'alignCenter',
      value: function alignCenter() {
        var _this2 = this;

        if (this.resizeFrame_ !== 0) {
          cancelAnimationFrame(this.resizeFrame_);
        }
        this.resizeFrame_ = requestAnimationFrame(function () {
          _this2.alignCenter_();
          _this2.resizeFrame_ = 0;
        });
      }
    }, {
      key: 'alignCenter_',
      value: function alignCenter_() {
        if (this.adapter_.getNumberOfTiles() == 0) {
          return;
        }
        var gridWidth = this.adapter_.getOffsetWidth();
        var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
        var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
        this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
      }
    }]);
    return MDCGridListFoundation;
  }(MDCFoundation);

  var mdcGridList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-grid-list" }, [_c('ul', { staticClass: "mdc-grid-list__tiles", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-grid-list',
    props: {
      'width': [String, Number],
      'ratio': String,
      'narrow-gutter': Boolean,
      'header-caption': Boolean,
      'icon-align-start': Boolean,
      'icon-align-end': Boolean,
      'with-support-text': Boolean,
      'interactive': Boolean
    },
    provide: function provide() {
      return { mdcGrid: this };
    },

    computed: {
      classes: function classes() {
        var classes = {};

        classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
        classes['mdc-grid-list--header-caption'] = this.headerCaption;
        classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
        classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
        classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
        classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
        classes['mdc-grid-list--non-interactive'] = !this.interactive;

        return classes;
      },
      styles: function styles() {
        var defaultWidth = 200;
        return {
          '--mdc-grid-list-tile-width': (this.width || defaultWidth) + 'px'
        };
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCGridListFoundation({
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
        },
        setStyleForTilesElement: function setStyleForTilesElement(property, value) {
          _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcGridTile = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-grid-tile", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined }, on: { "click": _vm.onClick } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.cover ? _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('div', { staticClass: "mdc-grid-tile__primary-content", style: { backgroundImage: 'url(' + _vm.src + ')' } })]) : _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('img', { staticClass: "mdc-grid-tile__primary-content", attrs: { "src": _vm.src } })]), _vm._v(" "), _vm.title || _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c('i', { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c('span', { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-grid-tile',
    inject: ['mdcGrid'],
    mixins: [DispatchEventMixin],
    props: {
      'src': String,
      'cover': Boolean,
      'icon': String,
      'title': String,
      'support-text': String,
      'selected': Boolean,
      'activated': Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-grid-tile--selected': this.selected,
          'mdc-grid-tile--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcGrid && this.mdcGrid.interactive;
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      },
      hasEndDetail: function hasEndDetail() {
        return this.endIcon || this.$slots['end-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    methods: {
      onClick: function onClick(evt) {
        this.dispatchEvent(evt);
      },
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    }
  };

  var VueMDCGridList = BasePlugin({
    mdcGridList: mdcGridList,
    mdcGridTile: mdcGridTile
  });

  var mdcIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon mdc-icon--material", class: { 'material-icons': !!_vm.icon } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-icon',
    props: {
      icon: String
    }
  };

  var VueMDCIcon = BasePlugin({
    mdcIcon: mdcIcon
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCIconToggleAdapter = function () {
    function MDCIconToggleAdapter() {
      classCallCheck(this, MDCIconToggleAdapter);
    }

    createClass(MDCIconToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {string} text */

    }, {
      key: "setText",
      value: function setText(text) {}

      /** @return {number} */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /** @param {number} tabIndex */

    }, {
      key: "setTabIndex",
      value: function setTabIndex(tabIndex) {}

      /**
       * @param {string} name
       * @return {string}
       */

    }, {
      key: "getAttr",
      value: function getAttr(name) {}

      /**
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(name, value) {}

      /** @param {string} name */

    }, {
      key: "rmAttr",
      value: function rmAttr(name) {}

      /** @param {!IconToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);
    return MDCIconToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$8 = {
    ROOT: 'mdc-icon-toggle',
    DISABLED: 'mdc-icon-toggle--disabled'
  };

  /** @enum {string} */
  var strings$9 = {
    DATA_TOGGLE_ON: 'data-toggle-on',
    DATA_TOGGLE_OFF: 'data-toggle-off',
    ARIA_PRESSED: 'aria-pressed',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_LABEL: 'aria-label',
    CHANGE_EVENT: 'MDCIconToggle:change'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCIconToggleAdapter>}
   */

  var MDCIconToggleFoundation = function (_MDCFoundation) {
    inherits(MDCIconToggleFoundation, _MDCFoundation);
    createClass(MDCIconToggleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$8;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$9;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          setText: function setText() /* text: string */{},
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          setTabIndex: function setTabIndex() /* tabIndex: number */{},
          getAttr: function getAttr() {
            return (/* name: string */ /* string */''
            );
          },
          setAttr: function setAttr() /* name: string, value: string */{},
          rmAttr: function rmAttr() /* name: string */{},
          notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
        };
      }
    }]);

    function MDCIconToggleFoundation(adapter) {
      classCallCheck(this, MDCIconToggleFoundation);

      /** @private {boolean} */
      var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

      _this.on_ = false;

      /** @private {boolean} */
      _this.disabled_ = false;

      /** @private {number} */
      _this.savedTabIndex_ = -1;

      /** @private {?IconToggleState} */
      _this.toggleOnData_ = null;

      /** @private {?IconToggleState} */
      _this.toggleOffData_ = null;

      _this.clickHandler_ = /** @private {!EventListener} */function () {
        return _this.toggleFromEvt_();
      };

      /** @private {boolean} */
      _this.isHandlingKeydown_ = false;

      _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = true;
          return evt.preventDefault();
        }
      };

      _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = false;
          _this.toggleFromEvt_();
        }
      };
      return _this;
    }

    createClass(MDCIconToggleFoundation, [{
      key: 'init',
      value: function init() {
        this.refreshToggleData();
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      }
    }, {
      key: 'refreshToggleData',
      value: function refreshToggleData() {
        var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
            DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
            DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

        this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
        this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      }

      /** @private */

    }, {
      key: 'toggleFromEvt_',
      value: function toggleFromEvt_() {
        this.toggle();
        var isOn = this.on_;

        this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
      }

      /** @return {boolean} */

    }, {
      key: 'isOn',
      value: function isOn() {
        return this.on_;
      }

      /** @param {boolean=} isOn */

    }, {
      key: 'toggle',
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

        this.on_ = isOn;

        var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
            ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
            ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


        if (this.on_) {
          this.adapter_.setAttr(ARIA_PRESSED, 'true');
        } else {
          this.adapter_.setAttr(ARIA_PRESSED, 'false');
        }

        var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
            classToRemove = _ref.cssClass;

        if (classToRemove) {
          this.adapter_.removeClass(classToRemove);
        }

        var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
            content = _ref2.content,
            label = _ref2.label,
            cssClass = _ref2.cssClass;

        if (cssClass) {
          this.adapter_.addClass(cssClass);
        }
        if (content) {
          this.adapter_.setText(content);
        }
        if (label) {
          this.adapter_.setAttr(ARIA_LABEL, label);
        }
      }

      /**
       * @param {string} dataAttr
       * @return {!IconToggleState}
       */

    }, {
      key: 'parseJsonDataAttr_',
      value: function parseJsonDataAttr_(dataAttr) {
        var val = this.adapter_.getAttr(dataAttr);
        if (!val) {
          return {};
        }
        return (/** @type {!IconToggleState} */JSON.parse(val)
        );
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} isDisabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(isDisabled) {
        this.disabled_ = isDisabled;

        var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
        var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setTabIndex(-1);
          this.adapter_.setAttr(ARIA_DISABLED, 'true');
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.setTabIndex(this.savedTabIndex_);
          this.adapter_.rmAttr(ARIA_DISABLED);
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {boolean} */

    }, {
      key: 'isKeyboardActivated',
      value: function isKeyboardActivated() {
        return this.isHandlingKeydown_;
      }
    }]);
    return MDCIconToggleFoundation;
  }(MDCFoundation);

  /**
   * @param {!KeyboardKey} keyboardKey
   * @return {boolean}
   */
  function isSpace(keyboardKey) {
    return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
  }

  var mdcIConToggle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon-toggle", class: _vm.classes, style: _vm.styles, attrs: { "role": "button", "aria-pressed": "false", "tabindex": _vm.tabIndex, "data-toggle-on": _vm.toggleOnData, "data-toggle-off": _vm.toggleOffData } }, [_c('i', { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
    }, staticRenderFns: [],
    name: 'mdc-icon-toggle',
    props: {
      toggleOn: [String, Object],
      toggleOff: [String, Object],
      value: Boolean,
      disabled: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-icon-toggle--accent': this.accent
        },
        styles: {},
        iconClasses: {},
        tabIndex: 0,
        text: ''
      };
    },

    watch: {
      value: function value(_value) {
        this.foundation && this.foundation.toggle(_value);
      },
      disabled: function disabled(_disabled) {
        this.foundation && this.foundation.setDisabled(_disabled);
      },
      toggleOnData: function toggleOnData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      toggleOffData: function toggleOffData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      accent: function accent(value) {
        this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
      }
    },
    computed: {
      toggleOnData: function toggleOnData() {
        var toggle = this.toggleOn;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      },
      toggleOffData: function toggleOffData() {
        var toggle = this.toggleOff;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.iconClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.iconClasses, className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$el.removeEventListener(evt, handler);
        },
        setText: function setText(text) {
          _this.text = text;
        },
        getTabIndex: function getTabIndex() {
          return _this.tabIndex;
        },
        setTabIndex: function setTabIndex(tabIndex) {
          _this.tabIndex = tabIndex;
        },
        getAttr: function getAttr(name, value) {
          return _this.$el.getAttribute(name, value);
        },
        setAttr: function setAttr(name, value) {
          _this.$el.setAttribute(name, value);
        },
        rmAttr: function rmAttr(name) {
          _this.$el.removeAttribute(name);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('input', evtData.isOn);
        }
      });
      this.foundation.init();
      this.foundation.toggle(this.value);
      this.foundation.setDisabled(this.disabled);

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return _this.foundation.isKeyboardActivated();
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  var VueMDCIconToggle = BasePlugin({
    mdcIConToggle: mdcIConToggle
  });

  var mdcLayoutApp = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-app" }, [_c('div', { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--main-container" }, [_c('div', { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
    }, staticRenderFns: [],
    name: 'mdc-layout-app'
  };

  var VueMDCLayoutApp = BasePlugin({
    mdcLayoutApp: mdcLayoutApp
  });

  var mdcLayoutGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-grid", class: _vm.classes }, [_c('div', { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-layout-grid',
    props: {
      'fixed-column-width': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth
        }
      };
    }
  };

  var spanOptions = {
    type: [String, Number],
    default: null,
    validator: function validator(value) {
      var num = Number(value);
      return isFinite(num) && num <= 12 && num > 0;
    }
  };

  var mdcLayoutCell = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-cell mdc-layout-grid__cell", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-cell',
    props: {
      span: spanOptions,
      order: spanOptions,
      phone: spanOptions,
      tablet: spanOptions,
      desktop: spanOptions,
      align: {
        type: String,
        validator: function validator(value) {
          return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      classes: function classes() {
        var classes = [];

        if (this.span) {
          classes.push("mdc-layout-grid__cell--span-" + this.span);
        }

        if (this.order) {
          classes.push("mdc-layout-grid__cell--order-" + this.order);
        }

        if (this.phone) {
          classes.push("mdc-layout-grid__cell--span-" + this.phone + "-phone");
        }

        if (this.tablet) {
          classes.push("mdc-layout-grid__cell--span-" + this.tablet + "-tablet");
        }

        if (this.desktop) {
          classes.push("mdc-layout-grid__cell--span-" + this.desktop + "-desktop");
        }

        if (this.align) {
          classes.push("mdc-layout-grid__cell--align-" + this.align);
        }

        return classes;
      }
    }
  };

  var mdcLayoutInnerGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-inner-grid'
  };

  var VueMDCLayoutGrid = BasePlugin({
    mdcLayoutGrid: mdcLayoutGrid,
    mdcLayoutCell: mdcLayoutCell,
    mdcLayoutInnerGrid: mdcLayoutInnerGrid
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$9 = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
  };

  var strings$10 = {
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
    BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCLinearProgressFoundation = function (_MDCFoundation) {
    inherits(MDCLinearProgressFoundation, _MDCFoundation);
    createClass(MDCLinearProgressFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$9;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$10;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          getPrimaryBar: function getPrimaryBar() /* el: Element */{},
          getBuffer: function getBuffer() /* el: Element */{},
          hasClass: function hasClass() {
            return (/* className: string */false
            );
          },
          removeClass: function removeClass() /* className: string */{},
          setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
        };
      }
    }]);

    function MDCLinearProgressFoundation(adapter) {
      classCallCheck(this, MDCLinearProgressFoundation);
      return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
    }

    createClass(MDCLinearProgressFoundation, [{
      key: 'init',
      value: function init() {
        this.determinate_ = !this.adapter_.hasClass(cssClasses$9.INDETERMINATE_CLASS);
        this.reverse_ = this.adapter_.hasClass(cssClasses$9.REVERSED_CLASS);
        this.progress_ = 0;
      }
    }, {
      key: 'setDeterminate',
      value: function setDeterminate(isDeterminate) {
        this.determinate_ = isDeterminate;
        if (this.determinate_) {
          this.adapter_.removeClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
        } else {
          this.adapter_.addClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), 1);
          this.setScale_(this.adapter_.getBuffer(), 1);
        }
      }
    }, {
      key: 'setProgress',
      value: function setProgress(value) {
        this.progress_ = value;
        if (this.determinate_) {
          this.setScale_(this.adapter_.getPrimaryBar(), value);
        }
      }
    }, {
      key: 'setBuffer',
      value: function setBuffer(value) {
        if (this.determinate_) {
          this.setScale_(this.adapter_.getBuffer(), value);
        }
      }
    }, {
      key: 'setReverse',
      value: function setReverse(isReversed) {
        this.reverse_ = isReversed;
        if (this.reverse_) {
          this.adapter_.addClass(cssClasses$9.REVERSED_CLASS);
        } else {
          this.adapter_.removeClass(cssClasses$9.REVERSED_CLASS);
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.removeClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.addClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'setScale_',
      value: function setScale_(el, scaleValue) {
        var _this2 = this;

        var value = 'scaleX(' + scaleValue + ')';
        transformStyleProperties.forEach(function (transformStyleProperty) {
          _this2.adapter_.setStyle(el, transformStyleProperty, value);
        });
      }
    }]);
    return MDCLinearProgressFoundation;
  }(MDCFoundation);

  var ProgressPropType = {
    type: [Number, String],
    validator: function validator(value) {
      return Number(value) >= 0 && Number(value) <= 1;
    }
  };

  var mdcLinearProgress = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress", class: _vm.classes, style: _vm.styles, attrs: { "role": "progressbar" } }, [_c('div', { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c('div', { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c('div', { ref: "primary", staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]);
    }],
    name: 'mdc-linear-progress',
    props: {
      'open': { type: Boolean, default: true },
      'indeterminate': Boolean,
      'reverse': Boolean,
      'accent': Boolean,
      'progress': ProgressPropType,
      'buffer': ProgressPropType
    },
    data: function data() {
      return {
        classes: { 'mdc-linear-progress--accent': this.accent },
        styles: {}
      };
    },

    watch: {
      open: function open() {
        if (this.open) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      progress: function progress() {
        this.foundation.setProgress(Number(this.progress));
      },
      buffer: function buffer() {
        this.foundation.setBuffer(Number(this.buffer));
      },
      indeterminate: function indeterminate() {
        this.foundation.setDeterminate(!this.indeterminate);
      },
      reverse: function reverse() {
        this.foundation.setReverse(this.reverse);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLinearProgressFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        getPrimaryBar: function getPrimaryBar() /* el: Element */{
          return _this.$refs.primary;
        },
        getBuffer: function getBuffer() /* el: Element */{
          return _this.$refs.buffer;
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        setStyle: function setStyle(el, styleProperty, value) {
          el.style[styleProperty] = value;
        }
      });
      this.foundation.init();

      this.foundation.setReverse(this.reverse);
      this.foundation.setProgress(Number(this.progress));
      this.foundation.setBuffer(Number(this.buffer));
      this.foundation.setDeterminate(!this.indeterminate);
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCLinearProgress = BasePlugin({
    mdcLinearProgress: mdcLinearProgress
  });

  var mdcList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('ul', { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list',
    props: {
      dense: Boolean,
      avatarList: Boolean,
      twoLine: Boolean,
      bordered: Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcList: this };
    },

    computed: {
      classes: function classes() {
        return {
          'mdc-list--dense': this.dense,
          'mdc-list--avatar-list': this.avatarList,
          'mdc-list--two-line': this.twoLine,
          'mdc-list--bordered': this.bordered,
          'mdc-list--non-interactive': !this.interactive
        };
      }
    }
  };

  var mdcListItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c('span', { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c('span', { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c('span', { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-item',
    inject: ['mdcList'],
    props: {
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--selected': this.selected,
          'mdc-list-item--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcList && this.mdcList.interactive;
      },
      hasSecondary: function hasSecondary() {
        return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
      },
      hasEndDetail: function hasEndDetail() {
        return !!this.$slots['end-detail'];
      },
      hasStartDetail: function hasStartDetail() {
        return !!this.$slots['start-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }

  };

  var mdcListDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-list-divider", class: _vm.classes, attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-list-divider',
    props: {
      inset: Boolean,
      padded: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list-divider--inset': this.inset,
          'mdc-list-divider--padded': this.padded
        };
      }
    }
  };

  var mdcListGroup = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group'
  };

  var mdcListGroupHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h3', { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group-header'
  };

  var mdcListGroupDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-group-divider mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-list-group-divider'
  };

  var VueMDCList = BasePlugin({
    mdcList: mdcList,
    mdcListItem: mdcListItem,
    mdcListDivider: mdcListDivider,
    mdcListGroup: mdcListGroup,
    mdcListGroupHeader: mdcListGroupHeader,
    mdcListGroupDivider: mdcListGroupDivider
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter = function () {
    function MDCMenuAdapter() {
      classCallCheck(this, MDCMenuAdapter);
    }

    createClass(MDCMenuAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /** @return {boolean} */

    }, {
      key: "hasNecessaryDom",
      value: function hasNecessaryDom() {}

      /**
       * @param {EventTarget} target
       * @param {string} attributeName
       * @return {string}
       */

    }, {
      key: "getAttributeForEventTarget",
      value: function getAttributeForEventTarget(target, attributeName) {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}

      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}

      /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}

      /** @return {number} */

    }, {
      key: "getNumberOfItems",
      value: function getNumberOfItems() {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerBodyClickHandler",
      value: function registerBodyClickHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterBodyClickHandler",
      value: function deregisterBodyClickHandler(handler) {}

      /**
       * @param {EventTarget} target
       * @return {number}
       */

    }, {
      key: "getIndexForEventTarget",
      value: function getIndexForEventTarget(target) {}

      /** @param {{index: number}} evtData */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }, {
      key: "notifyCancel",
      value: function notifyCancel() {}
    }, {
      key: "saveFocus",
      value: function saveFocus() {}
    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}

      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
    }, {
      key: "focus",
      value: function focus() {}

      /** @return {number} */

    }, {
      key: "getFocusedItemIndex",
      value: function getFocusedItemIndex() /* number */{}

      /** @param {number} index */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}

      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}

      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}

      /** @param {{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}

      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}

      /**
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttrForOptionAtIndex",
      value: function setAttrForOptionAtIndex(index, attr, value) {}

      /**
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "rmAttrForOptionAtIndex",
      value: function rmAttrForOptionAtIndex(index, attr) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForOptionAtIndex",
      value: function addClassForOptionAtIndex(index, className) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "rmClassForOptionAtIndex",
      value: function rmClassForOptionAtIndex(index, className) {}
    }]);
    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$10 = {
    ROOT: 'mdc-menu',
    OPEN: 'mdc-menu--open',
    ANIMATING_OPEN: 'mdc-menu--animating-open',
    ANIMATING_CLOSED: 'mdc-menu--animating-closed',
    SELECTED_LIST_ITEM: 'mdc-list-item--selected'
  };

  /** @enum {string} */
  var strings$11 = {
    ITEMS_SELECTOR: '.mdc-menu__items',
    SELECTED_EVENT: 'MDCMenu:selected',
    CANCEL_EVENT: 'MDCMenu:cancel',
    ARIA_DISABLED_ATTR: 'aria-disabled'
  };

  /** @enum {number} */
  var numbers$2 = {
    // Amount of time to wait before triggering a selected event on the menu. Note that this time
    // will most likely be bumped up once interactive lists are supported to allow for the ripple to
    // animate before closing the menu
    SELECTED_TRIGGER_DELAY: 50,
    // Total duration of menu open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
    // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
    OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
  };

  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */
  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };

  /**
   * Enum for representing an element corner for positioning the menu.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */
  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation = function (_MDCFoundation) {
    inherits(MDCMenuFoundation, _MDCFoundation);
    createClass(MDCMenuFoundation, null, [{
      key: 'cssClasses',

      /** @return enum{cssClasses} */
      get: function get$$1() {
        return cssClasses$10;
      }

      /** @return enum{strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$11;
      }

      /** @return enum{numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$2;
      }

      /** @return enum{number} */

    }, {
      key: 'Corner',
      get: function get$$1() {
        return Corner;
      }

      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCMenuAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return false;
            },
            getAttributeForEventTarget: function getAttributeForEventTarget() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getNumberOfItems: function getNumberOfItems() {
              return 0;
            },
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            registerBodyClickHandler: function registerBodyClickHandler() {},
            deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
            getIndexForEventTarget: function getIndexForEventTarget() {
              return 0;
            },
            notifySelected: function notifySelected() {},
            notifyCancel: function notifyCancel() {},
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFocused: function isFocused() {
              return false;
            },
            focus: function focus() {},
            getFocusedItemIndex: function getFocusedItemIndex() {
              return -1;
            },
            focusItemAtIndex: function focusItemAtIndex() {},
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {},
            setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
            rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
            addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
            rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
          }
        );
      }

      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      classCallCheck(this, MDCMenuFoundation);

      /** @private {function(!Event)} */
      var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = function (evt) {
        return _this.handlePossibleSelected_(evt);
      };
      /** @private {function(!Event)} */
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeyboardDown_(evt);
      };
      /** @private {function(!Event)} */
      _this.keyupHandler_ = function (evt) {
        return _this.handleKeyboardUp_(evt);
      };
      /** @private {function(!Event)} */
      _this.documentClickHandler_ = function (evt) {
        return _this.handleDocumentClick_(evt);
      };
      /** @private {boolean} */
      _this.isOpen_ = false;
      /** @private {number} */
      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.selectedTriggerTimerId_ = 0;
      /** @private {number} */
      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */
      _this.dimensions_;
      /** @private {number} */
      _this.itemHeight_;
      /** @private {Corner} */
      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {AnchorMargin} */
      _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
      /** @private {?AutoLayoutMeasurements} */
      _this.measures_ = null;
      /** @private {number} */
      _this.selectedIndex_ = -1;
      /** @private {boolean} */
      _this.rememberSelection_ = false;
      /** @private {boolean} */
      _this.quickOpen_ = false;

      // A keyup event on the menu needs to have a corresponding keydown
      // event on the menu. If the user opens the menu with a keydown event on a
      // button, the menu will only get the key up event causing buggy behavior with selected elements.
      /** @private {boolean} */
      _this.keyDownWithinMenu_ = false;
      return _this;
    }

    createClass(MDCMenuFoundation, [{
      key: 'init',
      value: function init() {
        var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
            ROOT = _MDCMenuFoundation$cs.ROOT,
            OPEN = _MDCMenuFoundation$cs.OPEN;


        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }

        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearTimeout(this.selectedTriggerTimerId_);
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
      }

      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
       */

    }, {
      key: 'setAnchorCorner',
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }

      /**
       * @param {!AnchorMargin} margin 4-plet of margins from anchor.
       */

    }, {
      key: 'setAnchorMargin',
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }

      /** @param {boolean} rememberSelection */

    }, {
      key: 'setRememberSelection',
      value: function setRememberSelection(rememberSelection) {
        this.rememberSelection_ = rememberSelection;
        this.setSelectedIndex(-1);
      }

      /** @param {boolean} quickOpen */

    }, {
      key: 'setQuickOpen',
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }

      /**
       * @param {?number} focusIndex
       * @private
       */

    }, {
      key: 'focusOnOpen_',
      value: function focusOnOpen_(focusIndex) {
        if (focusIndex === null) {
          // If this instance of MDCMenu remembers selections, and the user has
          // made a selection, then focus the last selected item
          if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
            this.adapter_.focusItemAtIndex(this.selectedIndex_);
            return;
          }

          this.adapter_.focus();
          // If that doesn't work, focus first item instead.
          if (!this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          }
        } else {
          this.adapter_.focusItemAtIndex(focusIndex);
        }
      }

      /**
       * Handle clicks and cancel the menu if not a child list-item
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDocumentClick_',
      value: function handleDocumentClick_(evt) {
        var el = evt.target;

        while (el && el !== document.documentElement) {
          if (this.adapter_.getIndexForEventTarget(el) !== -1) {
            return;
          }
          el = el.parentNode;
        }

        this.adapter_.notifyCancel();
        this.close(evt);
      }
    }, {
      key: 'handleKeyboardDown_',


      /**
       * Handle keys that we want to repeat on hold (tab and arrows).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */
      value: function handleKeyboardDown_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;

        var isTab = key === 'Tab' || keyCode === 9;
        var isArrowUp = key === 'ArrowUp' || keyCode === 38;
        var isArrowDown = key === 'ArrowDown' || keyCode === 40;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEnter = key === 'Enter' || keyCode === 13;
        // The menu needs to know if the keydown event was triggered on the menu
        this.keyDownWithinMenu_ = isEnter || isSpace;

        var focusedItemIndex = this.adapter_.getFocusedItemIndex();
        var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

        if (shiftKey && isTab && focusedItemIndex === 0) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
          evt.preventDefault();
          return false;
        }

        if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
          this.adapter_.focusItemAtIndex(0);
          evt.preventDefault();
          return false;
        }

        // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
        if (isArrowUp || isArrowDown || isSpace) {
          evt.preventDefault();
        }

        if (isArrowUp) {
          if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(lastItemIndex);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
          }
        } else if (isArrowDown) {
          if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
          }
        }

        return true;
      }

      /**
       * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */

    }, {
      key: 'handleKeyboardUp_',
      value: function handleKeyboardUp_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key;

        var isEnter = key === 'Enter' || keyCode === 13;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEscape = key === 'Escape' || keyCode === 27;

        if (isEnter || isSpace) {
          // If the keydown event didn't occur on the menu, then it should
          // disregard the possible selected event.
          if (this.keyDownWithinMenu_) {
            this.handlePossibleSelected_(evt);
          }
          this.keyDownWithinMenu_ = false;
        }

        if (isEscape) {
          this.adapter_.notifyCancel();
          this.close();
        }

        return true;
      }

      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handlePossibleSelected_',
      value: function handlePossibleSelected_(evt) {
        var _this2 = this;

        if (this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true') {
          return;
        }
        var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
        if (targetIndex < 0) {
          return;
        }
        // Debounce multiple selections
        if (this.selectedTriggerTimerId_) {
          return;
        }
        this.selectedTriggerTimerId_ = setTimeout(function () {
          _this2.selectedTriggerTimerId_ = 0;
          _this2.close();
          if (_this2.rememberSelection_) {
            _this2.setSelectedIndex(targetIndex);
          }
          _this2.adapter_.notifySelected({ index: targetIndex });
        }, numbers$2.SELECTED_TRIGGER_DELAY);
      }

      /**
       * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
       */

    }, {
      key: 'getAutoLayoutMeasurements_',
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();

        return {
          viewport: viewport,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          menuHeight: this.dimensions_.height,
          menuWidth: this.dimensions_.width
        };
      }

      /**
       * Computes the corner of the anchor from which to animate and position the menu.
       * @return {Corner}
       * @private
       */

    }, {
      key: 'getOriginCorner_',
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;

        var _measures_ = this.measures_,
            viewportDistance = _measures_.viewportDistance,
            anchorHeight = _measures_.anchorHeight,
            anchorWidth = _measures_.anchorWidth,
            menuHeight = _measures_.menuHeight,
            menuWidth = _measures_.menuWidth;

        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

        var topOverflow = menuHeight - availableTop;
        var bottomOverflow = menuHeight - availableBottom;
        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

        var leftOverflow = menuWidth - availableLeft;
        var rightOverflow = menuWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return corner;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getHorizontalOriginOffset_',
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth;

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var x = 0;
        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
          x = rightOffset;
        } else {
          var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
          x = leftOffset;
        }
        return x;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getVerticalOriginOffset_',
      value: function getVerticalOriginOffset_(corner) {
        var _measures_2 = this.measures_,
            viewport = _measures_2.viewport,
            viewportDistance = _measures_2.viewportDistance,
            anchorHeight = _measures_2.anchorHeight,
            menuHeight = _measures_2.menuHeight;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var canOverlapVertically = !avoidVerticalOverlap;
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
          // anchor corner. Bottom margin is ignored in such cases.
          if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
          }
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          // adjust for when menu can overlap anchor, but too tall to be aligned to top
          // anchor corners. Top margin is ignored in that case.
          if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
          }
        }
        return y;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: 'getMenuMaxHeight_',
      value: function getMenuMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

        // When maximum height is not specified, it is handled from css.
        if (this.anchorCorner_ & CornerBit.BOTTOM) {
          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top;
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
          }
        }

        return maxHeight;
      }

      /** @private */

    }, {
      key: 'autoPosition_',
      value: function autoPosition_() {
        var _position;

        if (!this.adapter_.hasAnchor()) {
          return;
        }

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();

        var corner = this.getOriginCorner_();
        var maxMenuHeight = this.getMenuMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
        var _measures_3 = this.measures_,
            anchorWidth = _measures_3.anchorWidth,
            menuHeight = _measures_3.menuHeight,
            menuWidth = _measures_3.menuWidth;
        // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

        if (anchorWidth / menuWidth > numbers$2.ANCHOR_TO_MENU_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        }

        // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
        // scale animation is "anchored" on the anchor.
        if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$2.OFFSET_TO_MENU_HEIGHT_RATIO) {
          var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
          var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
          verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
        }

        this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

        // Clear measures after positioning is complete.
        this.measures_ = null;
      }

      /**
       * Open the menu.
       * @param {{focusIndex: ?number}=} options
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$focusIndex = _ref.focusIndex,
            focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
          _this3.autoPosition_();
          _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
          _this3.focusOnOpen_(focusIndex);
          _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
          if (!_this3.quickOpen_) {
            _this3.openAnimationEndTimerId_ = setTimeout(function () {
              _this3.openAnimationEndTimerId_ = 0;
              _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
            }, numbers$2.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }

      /**
       * Closes the menu.
       * @param {Event=} evt
       */

    }, {
      key: 'close',
      value: function close() {
        var _this4 = this;

        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true' : false;

        if (targetIsDisabled) {
          return;
        }

        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
          if (!_this4.quickOpen_) {
            _this4.closeAnimationEndTimerId_ = setTimeout(function () {
              _this4.closeAnimationEndTimerId_ = 0;
              _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
            }, numbers$2.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.adapter_.restoreFocus();
      }

      /** @return {boolean} */

    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /** @return {number} */

    }, {
      key: 'getSelectedIndex',
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }

      /**
       * @param {number} index Index of the item to set as selected.
       */

    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        if (index === this.selectedIndex_) {
          return;
        }

        var prevSelectedIndex = this.selectedIndex_;
        if (prevSelectedIndex >= 0) {
          this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
          this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$10.SELECTED_LIST_ITEM);
        }

        this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
          this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$10.SELECTED_LIST_ITEM);
        }
      }
    }]);
    return MDCMenuFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_$1 = void 0;

  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */
  function getTransformPropertyName$1(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_$1 = transformPropertyName;
    }

    return storedTransformPropertyName_$1;
  }

  var mdcMenu = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-menu mdc-simple-menu", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "-1" } }, [_c('ul', { ref: "items", staticClass: "mdc-simple-menu__items mdc-list", attrs: { "role": "menu", "aria-hidden": "true" } }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-menu',
    props: {
      'open-from-top-left': Boolean,
      'open-from-top-right': Boolean,
      'open-from-bottom-left': Boolean,
      'open-from-bottom-right': Boolean,
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {
          'mdc-simple-menu--open-from-top-left': this.openFromTopLeft,
          'mdc-simple-menu--open-from-top-right': this.openFromTopRight,
          'mdc-simple-menu--open-from-bottom-left': this.openFromBottomLeft,
          'mdc-simple-menu--open-from-bottom-right': this.openFromBottomRight
        },
        styles: {},
        items: []
      };
    },

    methods: {
      show: function show(options) {
        this.foundation.open(options);
      },
      hide: function hide() {
        this.foundation.close();
      },
      isOpen: function isOpen() {
        return this.foundation ? this.foundation.isOpen() : false;
      }
    },
    mounted: function mounted() {
      var _this = this;

      var refreshItems = function refreshItems() {
        _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
        _this.$emit('update');
      };
      this.slotObserver = new MutationObserver(function () {
        return refreshItems();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      this._previousFocus = undefined;

      this.foundation = new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this.$refs.items);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          return {
            width: _this.$refs.items.offsetWidth,
            height: _this.$refs.items.offsetHeight
          };
        },
        hasAnchor: function hasAnchor() {
          return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this.$refs.root.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$refs.root.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$refs.root.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          var evt = {
            index: evtData.index,
            item: _this.items[evtData.index]
          };
          _this.$emit('select', evt);
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('cancel');
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this._previousFocus = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this._previousFocus) {
            _this._previousFocus.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.root;
        },
        focus: function focus() {
          return _this.$refs.root.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
        },
        setPosition: function setPosition(position) {
          _this.$set(_this.styles, 'left', position.left);
          _this.$set(_this.styles, 'right', position.right);
          _this.$set(_this.styles, 'top', position.top);
          _this.$set(_this.styles, 'bottom', position.bottom);
        },
        setMaxHeight: function setMaxHeight(height) {
          _this.$set(_this.styles, 'max-height', height);
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          _this.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          _this.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          _this.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          _this.items[index].classList.remove(className);
        }
      });

      refreshItems();
      this.foundation.init();
      if (this.anchorCorner !== void 0) {
        this.foundation.setAnchorCorner(Number(this.anchorCorner));
      }
      if (this.anchorMargin !== void 0) {
        this.foundation.setAnchorMargin(this.anchorMargin);
      }
    },

    watch: {
      quickOpen: function quickOpen(nv) {
        this.foundation.setQuickOpen(nv);
      },
      anchorCorner: function anchorCorner(nv) {
        this.foundation.setAnchorCorner(Number(nv));
      },
      anchorMargin: function anchorMargin(nv) {
        this.foundation.setAnchorMargin(nv);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.slotObserver.disconnect();
      this.foundation.destroy();
    }
  };

  var mdcMenuItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-item mdc-list-item", attrs: { "role": "menuitem", "tabindex": _vm.disabled ? '-1' : '0', "aria-disabled": _vm.disabled } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-item',
    props: {
      disabled: Boolean
    }
  };

  var mdcMenuDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-divider mdc-list-divider", attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-menu-divider'
  };

  var mdcMenuAnchor = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-anchor'
  };

  var VueMDCMenu = BasePlugin({
    mdcMenu: mdcMenu,
    mdcMenuItem: mdcMenuItem,
    mdcMenuDivider: mdcMenuDivider,
    mdcMenuAnchor: mdcMenuAnchor
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Radio. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCRadioAdapter = function () {
    function MDCRadioAdapter() {
      classCallCheck(this, MDCRadioAdapter);
    }

    createClass(MDCRadioAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }]);
    return MDCRadioAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$12 = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
  };

  /** @enum {string} */
  var cssClasses$11 = {
    ROOT: 'mdc-radio',
    DISABLED: 'mdc-radio--disabled'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCRadioAdapter>}
   */

  var MDCRadioFoundation = function (_MDCFoundation) {
    inherits(MDCRadioFoundation, _MDCFoundation);

    function MDCRadioFoundation() {
      classCallCheck(this, MDCRadioFoundation);
      return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
    }

    createClass(MDCRadioFoundation, [{
      key: 'isChecked',


      /** @return {boolean} */
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          disabled: false,
          value: null
        };
      }
    }], [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$11;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$12;
      }

      /** @return {!MDCRadioAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCRadioAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
          }
        );
      }
    }]);
    return MDCRadioFoundation;
  }(MDCFoundation);

  var mdcRadio = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-radio", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-radio__native-control", attrs: { "type": "radio", "id": _vm._uid, "name": _vm.name }, on: { "change": _vm.sync } }), _vm._v(" "), _c('div', { ref: "label", staticClass: "mdc-radio__background" }, [_c('div', { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c('div', { staticClass: "mdc-radio__inner-circle" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-radio',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'picked',
      event: 'change'
    },
    props: {
      'name': { type: String, required: true },
      'value': String,
      'picked': String,
      'checked': Boolean,
      'label': String,
      'align-end': Boolean,
      'disabled': Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        formFieldClasses: {
          'mdc-form-field': this.label,
          'mdc-form-field--align-end': this.label && this.alignEnd
        }
      };
    },
    mounted: function mounted() {
      var _this = this;

      // add foundation
      this.foundation = new MDCRadioFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        }
      });

      // add ripple
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return false;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();

      this.foundation.setValue(this.value ? this.value : this.label);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

      // refresh model
      this.checked && this.sync();
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    watch: {
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      }
    },
    methods: {
      isChecked: function isChecked() {
        return this.foundation.isChecked();
      },
      sync: function sync() {
        this.$emit('change', this.foundation.getValue());
      }
    }
  };

  var VueMDCRadio = BasePlugin({
    mdcRadio: mdcRadio
  });

  var MDCNativeSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-native-select", attrs: { "disabled": _vm.disabled }, on: { "change": [function ($event) {
            var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
              return o.selected;
            }).map(function (o) {
              var val = "_value" in o ? o._value : o.value;return val;
            });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
          }, _vm.onChange] } }, [_vm.label ? _c('option', { attrs: { "disabled": "disabled", "value": "" } }, [_vm._v(_vm._s(_vm.label))]) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-native-select',
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [String, Array],
      disabled: Boolean,
      label: String
    },
    data: function data() {
      return {
        selected: this.value
      };
    },

    methods: {
      onChange: function onChange() {
        this.$emit('change', this.selected);
      }
    },
    watch: {
      value: function value(newValue) {
        this.selected = newValue;
      }
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$12 = {
    BOX: 'mdc-select--box',
    DISABLED: 'mdc-select--disabled',
    OPEN: 'mdc-select--open',
    ROOT: 'mdc-select',
    SCROLL_LOCK: 'mdc-select-scroll-lock'
  };

  var strings$13 = {
    CHANGE_EVENT: 'MDCSelect:change',
    BOTTOM_LINE_SELECTOR: '.mdc-select__bottom-line',
    LABEL_SELECTOR: '.mdc-select__label',
    MENU_SELECTOR: '.mdc-select__menu',
    SURFACE_SELECTOR: '.mdc-select__surface',
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends MDCComponent<!MDCMenuFoundation>
   */

  var MDCMenu = function (_MDCComponent) {
    inherits(MDCMenu, _MDCComponent);

    /** @param {...?} args */
    function MDCMenu() {
      var _ref;

      classCallCheck(this, MDCMenu);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @private {!Element} */
      var _this = possibleConstructorReturn(this, (_ref = MDCMenu.__proto__ || Object.getPrototypeOf(MDCMenu)).call.apply(_ref, [this].concat(args)));

      _this.previousFocus_;
      return _this;
    }

    /**
     * @param {!Element} root
     * @return {!MDCMenu}
     */


    createClass(MDCMenu, [{
      key: 'show',


      /** @param {{focusIndex: ?number}=} options */
      value: function show() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$focusIndex = _ref2.focusIndex,
            focusIndex = _ref2$focusIndex === undefined ? null : _ref2$focusIndex;

        this.foundation_.open({ focusIndex: focusIndex });
      }
    }, {
      key: 'hide',
      value: function hide() {
        this.foundation_.close();
      }

      /**
       * @param {Corner} corner Default anchor corner alignment of top-left
       *     menu corner.
       */

    }, {
      key: 'setAnchorCorner',
      value: function setAnchorCorner(corner) {
        this.foundation_.setAnchorCorner(corner);
      }

      /**
       * @param {AnchorMargin} margin
       */

    }, {
      key: 'setAnchorMargin',
      value: function setAnchorMargin(margin) {
        this.foundation_.setAnchorMargin(margin);
      }

      /**
       * Return the item container element inside the component.
       * @return {?Element}
       */

    }, {
      key: 'getOptionByIndex',


      /**
       * Return the item within the menu that is selected.
       * @param {number} index
       * @return {?Element}
       */
      value: function getOptionByIndex(index) {
        var items = this.items;

        if (index < items.length) {
          return this.items[index];
        } else {
          return null;
        }
      }

      /** @param {number} index */

    }, {
      key: 'getDefaultFoundation',


      /** @return {!MDCMenuFoundation} */
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCMenuFoundation({
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this2.root_.classList.contains(className);
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return Boolean(_this2.itemsContainer_);
          },
          getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
            return target.getAttribute(attributeName);
          },
          getInnerDimensions: function getInnerDimensions() {
            var itemsContainer = _this2.itemsContainer_;

            return { width: itemsContainer.offsetWidth, height: itemsContainer.offsetHeight };
          },
          hasAnchor: function hasAnchor() {
            return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return _this2.root_.parentElement.getBoundingClientRect();
          },
          getWindowDimensions: function getWindowDimensions() {
            return { width: window.innerWidth, height: window.innerHeight };
          },
          getNumberOfItems: function getNumberOfItems() {
            return _this2.items.length;
          },
          registerInteractionHandler: function registerInteractionHandler(type, handler) {
            return _this2.root_.addEventListener(type, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
            return _this2.root_.removeEventListener(type, handler);
          },
          registerBodyClickHandler: function registerBodyClickHandler(handler) {
            return document.body.addEventListener('click', handler);
          },
          deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
            return document.body.removeEventListener('click', handler);
          },
          getIndexForEventTarget: function getIndexForEventTarget(target) {
            return _this2.items.indexOf(target);
          },
          notifySelected: function notifySelected(evtData) {
            return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {
              index: evtData.index,
              item: _this2.items[evtData.index]
            });
          },
          notifyCancel: function notifyCancel() {
            return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});
          },
          saveFocus: function saveFocus() {
            _this2.previousFocus_ = document.activeElement;
          },
          restoreFocus: function restoreFocus() {
            if (_this2.previousFocus_) {
              _this2.previousFocus_.focus();
            }
          },
          isFocused: function isFocused() {
            return document.activeElement === _this2.root_;
          },
          focus: function focus() {
            return _this2.root_.focus();
          },
          getFocusedItemIndex: function getFocusedItemIndex() {
            return _this2.items.indexOf(document.activeElement);
          },
          focusItemAtIndex: function focusItemAtIndex(index) {
            return _this2.items[index].focus();
          },
          isRtl: function isRtl() {
            return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
          },
          setTransformOrigin: function setTransformOrigin(origin) {
            _this2.root_.style[getTransformPropertyName$1(window) + '-origin'] = origin;
          },
          setPosition: function setPosition(position) {
            _this2.root_.style.left = 'left' in position ? position.left : null;
            _this2.root_.style.right = 'right' in position ? position.right : null;
            _this2.root_.style.top = 'top' in position ? position.top : null;
            _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;
          },
          setMaxHeight: function setMaxHeight(height) {
            _this2.root_.style.maxHeight = height;
          },
          setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
            return _this2.items[index].setAttribute(attr, value);
          },
          rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
            return _this2.items[index].removeAttribute(attr);
          },
          addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
            return _this2.items[index].classList.add(className);
          },
          rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
            return _this2.items[index].classList.remove(className);
          }
        });
      }
    }, {
      key: 'open',


      /** @return {boolean} */
      get: function get$$1() {
        return this.foundation_.isOpen();
      }

      /** @param {boolean} value */
      ,
      set: function set$$1(value) {
        if (value) {
          this.foundation_.open();
        } else {
          this.foundation_.close();
        }
      }
    }, {
      key: 'itemsContainer_',
      get: function get$$1() {
        return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);
      }

      /**
       * Return the items within the menu. Note that this only contains the set of elements within
       * the items container that are proper list items, and not supplemental / presentational DOM
       * elements.
       * @return {!Array<!Element>}
       */

    }, {
      key: 'items',
      get: function get$$1() {
        var itemsContainer = this.itemsContainer_;

        return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));
      }
    }, {
      key: 'selectedItemIndex',
      set: function set$$1(index) {
        this.foundation_.setSelectedIndex(index);
      }

      /** @return {number} */
      ,
      get: function get$$1() {
        return this.foundation_.getSelectedIndex();
      }

      /** @param {!boolean} rememberSelection */

    }, {
      key: 'rememberSelection',
      set: function set$$1(rememberSelection) {
        this.foundation_.setRememberSelection(rememberSelection);
      }

      /** @param {boolean} quickOpen */

    }, {
      key: 'quickOpen',
      set: function set$$1(quickOpen) {
        this.foundation_.setQuickOpen(quickOpen);
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        return new MDCMenu(root);
      }
    }]);
    return MDCMenu;
  }(MDCComponent);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var OPENER_KEYS = [{ key: 'ArrowUp', keyCode: 38, forType: 'keydown' }, { key: 'ArrowDown', keyCode: 40, forType: 'keydown' }, { key: 'Space', keyCode: 32, forType: 'keyup' }];

  var MDCSelectFoundation = function (_MDCFoundation) {
    inherits(MDCSelectFoundation, _MDCFoundation);
    createClass(MDCSelectFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$12;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$13;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          floatLabel: function floatLabel() /* value: boolean */{},
          activateBottomLine: function activateBottomLine() {},
          deactivateBottomLine: function deactivateBottomLine() {},
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          setAttr: function setAttr() /* attr: string, value: string */{},
          rmAttr: function rmAttr() /* attr: string */{},
          computeBoundingRect: function computeBoundingRect() {
            return (/* {left: number, top: number} */{ left: 0, top: 0 }
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          focus: function focus() {},
          makeTabbable: function makeTabbable() {},
          makeUntabbable: function makeUntabbable() {},
          getComputedStyleValue: function getComputedStyleValue() {
            return (/* propertyName: string */ /* string */''
            );
          },
          setStyle: function setStyle() /* propertyName: string, value: string */{},
          create2dRenderingContext: function create2dRenderingContext() {
            return (/* {font: string, measureText: (string) => {width: number}} */{
                font: '',
                measureText: function measureText() {
                  return { width: 0 };
                }
              }
            );
          },
          setMenuElStyle: function setMenuElStyle() /* propertyName: string, value: string */{},
          setMenuElAttr: function setMenuElAttr() /* attr: string, value: string */{},
          rmMenuElAttr: function rmMenuElAttr() /* attr: string */{},
          getMenuElOffsetHeight: function getMenuElOffsetHeight() {
            return (/* number */0
            );
          },
          openMenu: function openMenu() /* focusIndex: number */{},
          isMenuOpen: function isMenuOpen() {
            return (/* boolean */false
            );
          },
          setSelectedTextContent: function setSelectedTextContent() /* textContent: string */{},
          getNumberOfOptions: function getNumberOfOptions() {
            return (/* number */0
            );
          },
          getTextForOptionAtIndex: function getTextForOptionAtIndex() {
            return (/* index: number */ /* string */''
            );
          },
          getValueForOptionAtIndex: function getValueForOptionAtIndex() {
            return (/* index: number */ /* string */''
            );
          },
          setAttrForOptionAtIndex: function setAttrForOptionAtIndex() /* index: number, attr: string, value: string */{},
          rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() /* index: number, attr: string */{},
          getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          registerMenuInteractionHandler: function registerMenuInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler() /* type: string, handler: EventListener */{},
          notifyChange: function notifyChange() {},
          getWindowInnerHeight: function getWindowInnerHeight() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSelectFoundation(adapter) {
      classCallCheck(this, MDCSelectFoundation);

      var _this = possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));

      _this.ctx_ = null;
      _this.selectedIndex_ = -1;
      _this.disabled_ = false;
      _this.isFocused_ = false;

      /** @private {number} */
      _this.animationRequestId_ = 0;

      _this.displayHandler_ = function (evt) {
        evt.preventDefault();
        if (!_this.adapter_.isMenuOpen()) {
          _this.open_();
        }
      };
      _this.displayViaKeyboardHandler_ = function (evt) {
        return _this.handleDisplayViaKeyboard_(evt);
      };
      _this.selectionHandler_ = function (_ref) {
        var detail = _ref.detail;
        var index = detail.index;


        if (index !== _this.selectedIndex_) {
          _this.setSelectedIndex(index);
          _this.adapter_.notifyChange();
        }
        _this.close_();
      };
      _this.cancelHandler_ = function () {
        _this.close_();
        if (_this.selectedIndex_ === -1) {
          _this.adapter_.floatLabel(false);
        }
      };
      return _this;
    }

    createClass(MDCSelectFoundation, [{
      key: 'init',
      value: function init() {
        this.ctx_ = this.adapter_.create2dRenderingContext();
        this.adapter_.registerInteractionHandler('click', this.displayHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.displayViaKeyboardHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.displayViaKeyboardHandler_);
        this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
        this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
        this.resize();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Drop reference to context object to prevent potential leaks
        this.ctx_ = null;
        cancelAnimationFrame(this.animationRequestId_);
        this.adapter_.deregisterInteractionHandler('click', this.displayHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.displayViaKeyboardHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.displayViaKeyboardHandler_);
        this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
        this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
      }
    }, {
      key: 'getValue',
      value: function getValue() {
        return this.selectedIndex_ >= 0 ? this.adapter_.getValueForOptionAtIndex(this.selectedIndex_) : '';
      }
    }, {
      key: 'getSelectedIndex',
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }
    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        var prevSelectedIndex = this.selectedIndex_;
        if (prevSelectedIndex >= 0) {
          this.adapter_.rmAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected');
        }

        this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfOptions() ? index : -1;
        var selectedTextContent = '';
        if (this.selectedIndex_ >= 0) {
          selectedTextContent = this.adapter_.getTextForOptionAtIndex(this.selectedIndex_).trim();
          this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
          this.adapter_.floatLabel(true);
        } else {
          if (!this.adapter_.isMenuOpen()) {
            this.adapter_.floatLabel(false);
          }
        }
        this.adapter_.setSelectedTextContent(selectedTextContent);
      }
    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }
    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

        this.disabled_ = disabled;
        if (this.disabled_) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.setAttr('aria-disabled', 'true');
          this.adapter_.makeUntabbable();
        } else {
          this.adapter_.removeClass(DISABLED);
          this.adapter_.rmAttr('aria-disabled');
          this.adapter_.makeTabbable();
        }
      }
    }, {
      key: 'resize',
      value: function resize() {
        var font = this.adapter_.getComputedStyleValue('font');
        var letterSpacing = parseFloat(this.adapter_.getComputedStyleValue('letter-spacing'));

        if (font) {
          this.ctx_.font = font;
        } else {
          var primaryFontFamily = this.adapter_.getComputedStyleValue('font-family').split(',')[0];
          var fontSize = this.adapter_.getComputedStyleValue('font-size');
          this.ctx_.font = fontSize + ' ' + primaryFontFamily;
        }

        var maxTextLength = 0;

        for (var i = 0, l = this.adapter_.getNumberOfOptions(); i < l; i++) {
          var surfacePaddingRight = parseInt(this.adapter_.getComputedStyleValue('padding-right'), 10);
          var surfacePaddingLeft = parseInt(this.adapter_.getComputedStyleValue('padding-left'), 10);
          var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;
          var txt = this.adapter_.getTextForOptionAtIndex(i).trim();

          var _ctx_$measureText = this.ctx_.measureText(txt),
              width = _ctx_$measureText.width;

          var addedSpace = letterSpacing * txt.length;

          maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));
        }

        this.adapter_.setStyle('width', maxTextLength + 'px');
      }
    }, {
      key: 'open_',
      value: function open_() {
        var _this2 = this;

        this.disableScroll_();
        var OPEN = MDCSelectFoundation.cssClasses.OPEN;

        var focusIndex = this.selectedIndex_ < 0 ? 0 : this.selectedIndex_;

        this.setMenuStylesForOpenAtIndex_(focusIndex);
        this.adapter_.floatLabel(true);
        this.adapter_.activateBottomLine();
        this.adapter_.addClass(OPEN);
        this.animationRequestId_ = requestAnimationFrame(function () {
          _this2.adapter_.openMenu(focusIndex);
          _this2.isFocused_ = true;
        });
      }
    }, {
      key: 'setMenuStylesForOpenAtIndex_',
      value: function setMenuStylesForOpenAtIndex_(index) {
        var innerHeight = this.adapter_.getWindowInnerHeight();

        var _adapter_$computeBoun = this.adapter_.computeBoundingRect(),
            left = _adapter_$computeBoun.left,
            top = _adapter_$computeBoun.top;

        this.adapter_.setMenuElAttr('aria-hidden', 'true');
        this.adapter_.setMenuElStyle('display', 'block');
        var menuHeight = this.adapter_.getMenuElOffsetHeight();
        var itemOffsetTop = this.adapter_.getOffsetTopForOptionAtIndex(index);
        this.adapter_.setMenuElStyle('display', '');
        this.adapter_.rmMenuElAttr('aria-hidden');

        var adjustedTop = top - itemOffsetTop;
        var overflowsTop = adjustedTop < 0;
        var overflowsBottom = adjustedTop + menuHeight > innerHeight;
        if (overflowsTop) {
          adjustedTop = 0;
        } else if (overflowsBottom) {
          adjustedTop = Math.max(0, innerHeight - menuHeight);
        }
        this.adapter_.setMenuElStyle('left', left + 'px');
        this.adapter_.setMenuElStyle('top', adjustedTop + 'px');
        this.adapter_.setMenuElStyle('transform-origin', 'center ' + itemOffsetTop + 'px');
      }
    }, {
      key: 'close_',
      value: function close_() {
        var OPEN = MDCSelectFoundation.cssClasses.OPEN;

        this.adapter_.removeClass(OPEN);
        this.adapter_.deactivateBottomLine();
        this.adapter_.focus();
        this.enableScroll_();
      }
    }, {
      key: 'handleDisplayViaKeyboard_',
      value: function handleDisplayViaKeyboard_(evt) {
        // We use a hard-coded 2 instead of Event.AT_TARGET to avoid having to reference a browser
        // global.
        var EVENT_PHASE_AT_TARGET = 2;
        if (evt.eventPhase !== EVENT_PHASE_AT_TARGET) {
          return;
        }

        // Prevent pressing space down from scrolling the page
        var isSpaceDown = evt.type === 'keydown' && (evt.key === 'Space' || evt.keyCode === 32);
        if (isSpaceDown) {
          evt.preventDefault();
        }

        var isOpenerKey = OPENER_KEYS.some(function (_ref2) {
          var key = _ref2.key,
              keyCode = _ref2.keyCode,
              forType = _ref2.forType;

          return evt.type === forType && (evt.key === key || evt.keyCode === keyCode);
        });

        if (isOpenerKey) {
          this.displayHandler_(evt);
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$12.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$12.SCROLL_LOCK);
      }
    }]);
    return MDCSelectFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Bottom Line.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Select label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectBottomLineAdapter = function () {
    function MDCSelectBottomLineAdapter() {
      classCallCheck(this, MDCSelectBottomLineAdapter);
    }

    createClass(MDCSelectBottomLineAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the bottom line element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the bottom line element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
    }]);
    return MDCSelectBottomLineAdapter;
  }();

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$13 = {
    BOTTOM_LINE_ACTIVE: 'mdc-select__bottom-line--active'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCSelectBottomLineAdapter>}
   * @final
   */

  var MDCSelectBottomLineFoundation = function (_MDCFoundation) {
    inherits(MDCSelectBottomLineFoundation, _MDCFoundation);
    createClass(MDCSelectBottomLineFoundation, [{
      key: 'activate',


      /**
       * Adds the active class to bottom line
       */
      value: function activate() {
        this.adapter_.addClass(cssClasses$13.BOTTOM_LINE_ACTIVE);
      }

      /**
       * Removes the active class from the bottom line
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.adapter_.removeClass(cssClasses$13.BOTTOM_LINE_ACTIVE);
      }

      /**
       * @param {!MDCSelectBottomLineAdapter} adapter
       */

    }], [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$13;
      }

      /**
       * {@see MDCSelectBottomLineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectBottomLineAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSelectBottomLineAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {}
          }
        );
      }
    }]);

    function MDCSelectBottomLineFoundation(adapter) {
      classCallCheck(this, MDCSelectBottomLineFoundation);
      return possibleConstructorReturn(this, (MDCSelectBottomLineFoundation.__proto__ || Object.getPrototypeOf(MDCSelectBottomLineFoundation)).call(this, _extends(MDCSelectBottomLineFoundation.defaultAdapter, adapter)));
    }

    return MDCSelectBottomLineFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Select label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectLabelAdapter = function () {
    function MDCSelectLabelAdapter() {
      classCallCheck(this, MDCSelectLabelAdapter);
    }

    createClass(MDCSelectLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
    }]);
    return MDCSelectLabelAdapter;
  }();

  var cssClasses$14 = {
    LABEL_FLOAT_ABOVE: 'mdc-select__label--float-above'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCSelectLabelAdapter>}
   * @final
   */

  var MDCSelectLabelFoundation = function (_MDCFoundation) {
    inherits(MDCSelectLabelFoundation, _MDCFoundation);
    createClass(MDCSelectLabelFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$14;
      }

      /**
       * {@see MDCSelectLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectLabelAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSelectLabelAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {}
          }
        );
      }

      /**
       * @param {!MDCSelectLabelAdapter} adapter
       */

    }]);

    function MDCSelectLabelFoundation(adapter) {
      classCallCheck(this, MDCSelectLabelFoundation);
      return possibleConstructorReturn(this, (MDCSelectLabelFoundation.__proto__ || Object.getPrototypeOf(MDCSelectLabelFoundation)).call(this, _extends(MDCSelectLabelFoundation.defaultAdapter, adapter)));
    }

    /**
     * Styles the label to float or defloat as necessary.
     * @param {string} value The value of the input.
     */


    createClass(MDCSelectLabelFoundation, [{
      key: 'styleFloat',
      value: function styleFloat(value) {
        var LABEL_FLOAT_ABOVE = MDCSelectLabelFoundation.cssClasses.LABEL_FLOAT_ABOVE;

        if (!!value) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
        }
      }
    }]);
    return MDCSelectLabelFoundation;
  }(MDCFoundation);

  var MDCMenuSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-select mdc-menu-select", class: _vm.classes, attrs: { "role": "listbox" } }, [_c('div', { ref: "surface", staticClass: "mdc-select__surface", style: _vm.surfaceStyles, attrs: { "tabindex": _vm.tabIndex } }, [_c('div', { ref: "label", staticClass: "mdc-select__label", class: _vm.labelClasses }, [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('div', { ref: "selectedContent", staticClass: "mdc-select__selected-text" }, [_vm._v(_vm._s(_vm.selectedTextContent))]), _vm._v(" "), _c('div', { ref: "bottomLine", staticClass: "mdc-select__bottom-line", class: _vm.bottomLineClasses })]), _vm._v(" "), _c('mdc-menu', { ref: "menu", staticClass: "mdc-select__menu", on: { "update": _vm.refreshIndex } }, [_vm._t("default")], 2)], 1);
    }, staticRenderFns: [],
    name: 'mdc-menu-select',
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      multiple: Boolean,
      value: [String, Array],
      disabled: Boolean,
      label: String,
      box: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-select--box': this.box
        },
        labelClasses: {},
        bottomLineClasses: {},
        surfaceStyles: {},
        tabIndex: 0,
        selectedTextContent: ''
      };
    },

    components: {
      'mdc-menu': mdcMenu
    },
    watch: {
      disabled: function disabled(value) {
        this.foundation && this.foundation.setDisabled(value);
      },
      value: function value() {
        this.refreshIndex();
      },
      box: function box() {
        this.$set(this.classes, 'mdc-select--box', this.box);
      }
    },
    methods: {
      refreshIndex: function refreshIndex() {
        if (this.foundation) {
          var options = this.$refs.menu.items;
          for (var i = 0; i < options.length; i++) {
            var optionValue = options[i].getAttribute('data-value') || options[i].textContent.trim();
            if (this.value == optionValue) {
              this.foundation.setSelectedIndex(i);
              //TODO: MDCFIX force float above if value is valid
              this.$set(this.labelClasses, 'mdc-select__label--float-above', true);
              return;
            }
          }
          //TODO: MDCFIX force float above if value is valid
          this.foundation.setSelectedIndex(-1);
          this.$set(this.labelClasses, 'mdc-select__label--float-above', false);
          this.$emit('change', this.foundation.getValue()); // TODO: MDCFIX
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.labelFoundation = new MDCSelectLabelFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.labelClasses, className);
        }
      });

      this.bottomLineFoundation = new MDCSelectBottomLineFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.bottomLineClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.bottomLineClasses, className);
        }
      });
      this.bottomLineFoundation.init();

      this.foundation = new MDCSelectFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        floatLabel: function floatLabel(value) {
          _this.labelFoundation.styleFloat(value);
        },
        activateBottomLine: function activateBottomLine() {
          _this.bottomLineFoundation.activate();
        },
        deactivateBottomLine: function deactivateBottomLine() {
          _this.bottomLineFoundation.deactivate();
        },
        setAttr: function setAttr(attr, value) {
          return _this.$el.setAttribute(attr, value);
        },
        rmAttr: function rmAttr(attr, value) {
          return _this.$el.removeAttribute(attr, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.surface.getBoundingClientRect();
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$refs.surface.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$refs.surface.removeEventListener(type, handler);
        },
        focus: function focus() {
          return _this.$refs.surface.focus();
        },
        makeTabbable: function makeTabbable() {
          _this.tabIndex = 0;
        },
        makeUntabbable: function makeUntabbable() {
          _this.tabIndex = -1;
        },
        getComputedStyleValue: function getComputedStyleValue(prop) {
          return window.getComputedStyle(_this.$refs.surface).getPropertyValue(prop);
        },
        setStyle: function setStyle(propertyName, value) {
          return _this.$set(_this.surfaceStyles, propertyName, value);
        },
        create2dRenderingContext: function create2dRenderingContext() {
          return document.createElement('canvas').getContext('2d');
        },
        setMenuElStyle: function setMenuElStyle(propertyName, value) {
          return _this.$refs.menu.$el.style[propertyName] = value;
        },
        setMenuElAttr: function setMenuElAttr(attr, value) {
          return _this.$refs.menu.$el.setAttribute(attr, value);
        },
        rmMenuElAttr: function rmMenuElAttr(attr) {
          return _this.$refs.menu.$el.removeAttribute(attr);
        },
        getMenuElOffsetHeight: function getMenuElOffsetHeight() {
          return _this.$refs.menu.$el.offsetHeight;
        },
        openMenu: function openMenu(focusIndex) {
          return _this.$refs.menu.show({ focusIndex: focusIndex });
        },
        isMenuOpen: function isMenuOpen() {
          return _this.$refs.menu.isOpen();
        },
        setSelectedTextContent: function setSelectedTextContent(selectedTextContent) {
          _this.selectedTextContent = selectedTextContent;
        },
        getNumberOfOptions: function getNumberOfOptions() {
          return _this.$refs.menu.items.length;
        },
        getTextForOptionAtIndex: function getTextForOptionAtIndex(index) {
          return _this.$refs.menu.items[index].textContent.trim();
        },
        getValueForOptionAtIndex: function getValueForOptionAtIndex(index) {
          return _this.$refs.menu.items[index].getAttribute('data-value') || _this.$refs.menu.items[index].textContent.trim();
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          return _this.$refs.menu.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          return _this.$refs.menu.items[index].removeAttribute(attr);
        },
        getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex(index) {
          return _this.$refs.menu.items[index].offsetTop;
        },
        registerMenuInteractionHandler: function registerMenuInteractionHandler(type, handler) {
          return _this.$refs.menu.$el.addEventListener(type, handler);
        },
        deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler(type, handler) {
          return _this.$refs.menu.$el.removeEventListener(type, handler);
        },
        notifyChange: function notifyChange() {
          _this.$emit('change', _this.foundation.getValue());
        },
        getWindowInnerHeight: function getWindowInnerHeight() {
          return window.innerHeight;
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        }
      });

      //TODO: MDCFIX
      var foundation = this.foundation;
      if (foundation) {
        foundation.resize = function () {
          if (!foundation.ctx_) {
            return;
          }
          var font = foundation.adapter_.getComputedStyleValue('font');
          var letterSpacing = parseFloat(foundation.adapter_.getComputedStyleValue('letter-spacing'));
          if (font) {
            foundation.ctx_.font = font;
          } else {
            var primaryFontFamily = foundation.adapter_.getComputedStyleValue('font-family').split(',')[0];
            var fontSize = foundation.adapter_.getComputedStyleValue('font-size');
            foundation.ctx_.font = fontSize + ' ' + primaryFontFamily;
          }

          var maxTextLength = 0;

          var surfacePaddingRight = parseInt(foundation.adapter_.getComputedStyleValue('padding-right'), 10);
          var surfacePaddingLeft = parseInt(foundation.adapter_.getComputedStyleValue('padding-left'), 10);
          var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;

          for (var i = 0, l = foundation.adapter_.getNumberOfOptions(); i < l; i++) {
            var txt = foundation.adapter_.getTextForOptionAtIndex(i).trim();

            var _foundation$ctx_$meas = foundation.ctx_.measureText(txt),
                _width = _foundation$ctx_$meas.width;

            var _addedSpace = letterSpacing * txt.length;

            maxTextLength = Math.max(maxTextLength, Math.ceil(_width + _addedSpace + selectBoxAddedPadding));
          }

          var labelTxt = _this.label;

          var _foundation$ctx_$meas2 = foundation.ctx_.measureText(labelTxt),
              width = _foundation$ctx_$meas2.width;

          var addedSpace = letterSpacing * labelTxt.length;

          maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));

          foundation.adapter_.setStyle('width', maxTextLength + 'px');
        };
      }
      ///
      this.labelFoundation.init();
      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      this.refreshIndex();
      if (this.value !== this.foundation.getValue()) {
        this.$emit('change', this.foundation.getValue());
      }
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();

      var labelFoundation = this.labelFoundation;
      this.labelFoundation = null;
      labelFoundation.destroy();

      var bottomLineFoundation = this.bottomLineFoundation;
      this.bottomLineFoundation = null;
      bottomLineFoundation.destroy();
    }
  };

  var MDCMultiSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-multi-select mdc-list", style: _vm.styles, attrs: { "multiple": _vm.multiple, "disabled": _vm.disabled }, on: { "change": [function ($event) {
            var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
              return o.selected;
            }).map(function (o) {
              var val = "_value" in o ? o._value : o.value;return val;
            });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
          }, _vm.onChange] } }, [_vm.label ? _c('optgroup', { ref: "optgroup", staticClass: "mdc-list-group", attrs: { "label": _vm.label } }, [_vm._t("default")], 2) : _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-multi-select',
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      multiple: Boolean,
      value: [String, Array],
      disabled: Boolean,
      label: String,
      maxSize: {
        type: [String, Number],
        default: 4
      }
    },
    data: function data() {
      return {
        selected: this.value,
        size: undefined,
        count: undefined
      };
    },

    computed: {
      styles: function styles() {
        var scroll = this.count > this.size;
        var size = 48 * this.size + (scroll ? 0 : 16);

        var styles = {
          'height': size + 'px',
          'overflow-y': scroll ? 'scroll' : 'hidden'
        };
        if (!scroll) {
          styles['background-image'] = 'unset';
        }
        return styles;
      }
    },
    methods: {
      onChange: function onChange() {
        this.$emit('change', this.selected);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var refreshSize = function refreshSize() {
        var count = _this.$refs.root.querySelectorAll('option, optgroup').length;
        _this.count = count;
        var max = Number(_this.maxSize);
        if (_this.label) {
          max += 1;
        }
        _this.size = Math.min(count, max);
      };

      this.slotObserver = new MutationObserver(function () {
        return refreshSize();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      refreshSize();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
    }
  };

  var media$1 = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'mobile',
      get: function get$$1() {
        return this._mobile || (this._mobile = window.matchMedia('(max-width: 600px) and (pointer: coarse)'));
      }
    }]);
    return _class;
  }())();

  var mdcSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, _vm._b({ tag: "component", attrs: { "multiple": _vm.multiple, "label": _vm.label, "value": _vm.value }, on: { "change": _vm.onChange } }, 'component', _vm.$attrs, false), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-select',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      multiple: Boolean,
      value: [String, Array],
      label: String,
      native: Boolean,
      menu: Boolean
    },
    provide: function provide() {
      return { mdcSelect: this };
    },

    components: {
      'mdc-native-select': MDCNativeSelect,
      'mdc-menu-select': MDCMenuSelect,
      'mdc-multi-select': MDCMultiSelect
    },
    data: function data() {
      return {
        mobile: window ? media$1.mobile.matches : true
      };
    },

    computed: {
      type: function type() {
        return this.multiple ? 'mdc-multi-select' : this.menu ? 'mdc-menu-select' : this.isNative ? 'mdc-native-select' : 'mdc-menu-select';
      },
      isNative: function isNative() {
        return this.native || this.multiple || this.mobile;
      }
    },
    methods: {
      onChange: function onChange(value) {
        this.$emit('change', value);
      },
      refreshMedia: function refreshMedia() {
        this.mobile = media$1.mobile.matches;
      }
    },
    beforeMount: function beforeMount() {
      media$1.mobile.addListener(this.refreshMedia);
      this.refreshMedia();
    },
    beforeDestroy: function beforeDestroy() {
      media$1.mobile.removeListener(this.refreshMedia);
    }
  };

  var MDCNativeOption = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-native-option',
    props: {
      value: String,
      disabled: Boolean
    },
    computed: {
      hasValue: function hasValue() {
        return !(typeof this.value === 'undefined');
      }
    }
  };

  var MDCMenuOption = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-option mdc-menu-option mdc-list-item", attrs: { "role": "option", "tabindex": _vm.disabled ? -1 : 0, "aria-disabled": _vm.disabled, "data-value": _vm.value } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-option',
    props: {
      value: String,
      disabled: Boolean
    }
  };

  var MDCMultiOption = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-multi-option',
    props: {
      value: String,
      disabled: Boolean
    },
    computed: {
      hasValue: function hasValue() {
        return !(typeof this.value === 'undefined');
      }
    }
  };

  var mdcOption = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { tag: "component", attrs: { "disabled": _vm.disabled, "value": _vm.value } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-option',
    props: {
      value: String,
      disabled: Boolean
    },
    inject: ['mdcSelect'],
    components: {
      'mdc-native-option': MDCNativeOption,
      'mdc-multi-option': MDCMultiOption,
      'mdc-menu-option': MDCMenuOption
    },
    computed: {
      isNative: function isNative() {
        return this.mdcSelect.isNative;
      },
      multiple: function multiple() {
        return this.mdcSelect.multiple;
      },
      menu: function menu() {
        return this.mdcSelect.menu;
      },
      type: function type() {
        return this.multiple ? 'mdc-multi-option' : this.menu ? 'mdc-menu-option' : this.isNative ? 'mdc-native-option' : 'mdc-menu-option';
      }
    }
  };

  var VueMDCSelect = BasePlugin({
    mdcSelect: mdcSelect,
    mdcOption: mdcOption
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$15 = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };

  /** @enum {string} */
  var strings$14 = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };

  /** @enum {number} */
  var numbers$3 = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter = function () {
    function MDCSliderAdapter() {
      classCallCheck(this, MDCSliderAdapter);
    }

    createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}

      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}

      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}

      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}

      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}

      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}

      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}

      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}

      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}

      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}

      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}

      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);
    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   *you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };

  /** @enum {string} */
  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };

  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation = function (_MDCFoundation) {
    inherits(MDCSliderFoundation, _MDCFoundation);
    createClass(MDCSliderFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$15;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$14;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$3;
      }

      /** @return {!MDCSliderAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSliderAdapter} */{
            hasClass: function hasClass() {
              return (/* className: string */ /* boolean */false
              );
            },
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getAttribute: function getAttribute() {
              return (/* name: string */ /* string|null */null
              );
            },
            setAttribute: function setAttribute() /* name: string, value: string */{},
            removeAttribute: function removeAttribute() /* name: string */{},
            computeBoundingRect: function computeBoundingRect() {
              return (/* ClientRect */{
                  top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (/* number */0
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
            setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
            setMarkerValue: function setMarkerValue() /* value: number */{},
            appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
            isRTL: function isRTL() {
              return (/* boolean */false
              );
            }
          }
        );
      }

      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      classCallCheck(this, MDCSliderFoundation);

      /** @private {?ClientRect} */
      var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

      _this.rect_ = null;
      // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.
      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;
      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };
      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };
      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };
      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCSliderFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses$15.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$15.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'setupTrackMarker',
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step;

          // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value
          var indivisible = Math.ceil(numMarkers) !== numMarkers;
          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }

      /** @return {number} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.value_;
      }

      /** @param {number} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.setValue_(value, false);
      }

      /** @return {number} */

    }, {
      key: 'getMax',
      value: function getMax() {
        return this.max_;
      }

      /** @param {number} max */

    }, {
      key: 'setMax',
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$14.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getMin',
      value: function getMin() {
        return this.min_;
      }

      /** @param {number} min */

    }, {
      key: 'setMin',
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$14.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getStep',
      value: function getStep() {
        return this.step_;
      }

      /** @param {number} step */

    }, {
      key: 'setStep',
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses$15.DISABLED, this.disabled_);
        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings$14.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings$14.ARIA_DISABLED);
          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }

      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDown_',
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        };

        // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
          _this4.handleUp_();
          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleMove_',
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: 'handleUp_',
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: 'getPageX_',
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }
        return evt.pageX;
      }

      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'setValueFromEvt_',
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }

      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: 'computeValueFromPageX_',
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;

        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
      }

      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: 'handleKeydown_',
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
          return;
        }

        // Prevent page from scrolling due to key presses that would normally scroll the page
        evt.preventDefault();
        this.adapter_.addClass(cssClasses$15.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: 'getKeyId_',
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }

      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: 'getValueForKeyId_',
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;

        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;
          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;
          case KEY_IDS.HOME:
            return this.min_;
          case KEY_IDS.END:
            return this.max_;
          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers$3.PAGE_FACTOR;
          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers$3.PAGE_FACTOR;
          default:
            return NaN;
        }
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }
        this.adapter_.addClass(cssClasses$15.FOCUS);
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses$15.FOCUS);
      }

      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: 'setValue_',
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;

        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }
        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }
        this.value_ = value;
        this.adapter_.setAttribute(strings$14.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();
          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }

      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: 'quantize_',
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: 'updateUIForCurrentValue_',
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;

        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);
            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };
          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
          _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
        });
      }

      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: 'setActive_',
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses$15.ACTIVE, this.active_);
      }

      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: 'setInTransit_',
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses$15.IN_TRANSIT, this.inTransit_);
      }

      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: 'toggleClass_',
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);
    return MDCSliderFoundation;
  }(MDCFoundation);

  var mdcSlider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
        return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
      })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
    }, staticRenderFns: [],
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: { type: [Number, String], default: 0 },
      max: { type: [Number, String], default: 100 },
      step: { type: [Number, String], default: 0 },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: { type: Object, required: false }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },

    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    methods: {
      layout: function layout() {
        var _this = this;

        this.$nextTick(function () {
          _this.foundation && _this.foundation.layout();
        });
      }
    },
    mounted: function mounted() {
      var _this2 = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this2.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this2.$delete(_this2.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this2.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this2.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this2.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this2.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this2.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this2.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this2.$el.removeEventListener(type, handler);
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this2.$refs.thumbContainer.addEventListener(type, handler);
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this2.$refs.thumbContainer.removeEventListener(type, handler);
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this2.$emit('input', _this2.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this2.$emit('change', _this2.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this2.$set(_this2.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this2.$set(_this2.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this2.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this2.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this2.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this2.$set(_this2.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });

      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }
      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));
      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      this.$root.$on('mdc:layout', this.layout);

      if (this.layoutOn) {
        var source = this.layoutOnSource || this.$root;
        source.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCSlider = BasePlugin({
    mdcSlider: mdcSlider
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$16 = {
    ROOT: 'mdc-snackbar',
    TEXT: 'mdc-snackbar__text',
    ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
    ACTION_BUTTON: 'mdc-snackbar__action-button',
    ACTIVE: 'mdc-snackbar--active',
    MULTILINE: 'mdc-snackbar--multiline',
    ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
  };

  var strings$15 = {
    TEXT_SELECTOR: '.mdc-snackbar__text',
    ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
    ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
    SHOW_EVENT: 'MDCSnackbar:show',
    HIDE_EVENT: 'MDCSnackbar:hide'
  };

  var numbers$4 = {
    MESSAGE_TIMEOUT: 2750
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSnackbarFoundation = function (_MDCFoundation) {
    inherits(MDCSnackbarFoundation, _MDCFoundation);
    createClass(MDCSnackbarFoundation, [{
      key: 'active',
      get: function get$$1() {
        return this.active_;
      }
    }], [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$16;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$15;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          setAriaHidden: function setAriaHidden() {},
          unsetAriaHidden: function unsetAriaHidden() {},
          setActionAriaHidden: function setActionAriaHidden() {},
          unsetActionAriaHidden: function unsetActionAriaHidden() {},
          setActionText: function setActionText() /* actionText: string */{},
          setMessageText: function setMessageText() /* message: string */{},
          setFocus: function setFocus() {},
          visibilityIsHidden: function visibilityIsHidden() {
            return (/* boolean */false
            );
          },
          registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
          deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
          registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
          deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
          deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyShow: function notifyShow() {},
          notifyHide: function notifyHide() {}
        };
      }
    }]);

    function MDCSnackbarFoundation(adapter) {
      classCallCheck(this, MDCSnackbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

      _this.active_ = false;
      _this.actionWasClicked_ = false;
      _this.dismissOnAction_ = true;
      _this.firstFocus_ = true;
      _this.pointerDownRecognized_ = false;
      _this.snackbarHasFocus_ = false;
      _this.snackbarData_ = null;
      _this.queue_ = [];
      _this.actionClickHandler_ = function () {
        _this.actionWasClicked_ = true;
        _this.invokeAction_();
      };
      _this.visibilitychangeHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = true;

        if (!_this.adapter_.visibilityIsHidden()) {
          setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
        }
      };
      _this.interactionHandler_ = function (evt) {
        if (evt.type == 'touchstart' || evt.type == 'mousedown') {
          _this.pointerDownRecognized_ = true;
        }
        _this.handlePossibleTabKeyboardFocus_(evt);

        if (evt.type == 'focus') {
          _this.pointerDownRecognized_ = false;
        }
      };
      _this.blurHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = false;
        _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      };
      return _this;
    }

    createClass(MDCSnackbarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerActionClickHandler(this.actionClickHandler_);
        this.adapter_.setAriaHidden();
        this.adapter_.setActionAriaHidden();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this2 = this;

        this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
        this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
        this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'dismissesOnAction',
      value: function dismissesOnAction() {
        return this.dismissOnAction_;
      }
    }, {
      key: 'setDismissOnAction',
      value: function setDismissOnAction(dismissOnAction) {
        this.dismissOnAction_ = !!dismissOnAction;
      }
    }, {
      key: 'show',
      value: function show(data) {
        var _this3 = this;

        if (!data) {
          throw new Error('Please provide a data object with at least a message to display.');
        }
        if (!data.message) {
          throw new Error('Please provide a message to be displayed.');
        }
        if (data.actionHandler && !data.actionText) {
          throw new Error('Please provide action text with the handler.');
        }
        if (this.active) {
          this.queue_.push(data);
          return;
        }
        clearTimeout(this.timeoutId_);
        this.snackbarData_ = data;
        this.firstFocus_ = true;
        this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
        this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
        });

        var ACTIVE = cssClasses$16.ACTIVE,
            MULTILINE = cssClasses$16.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$16.ACTION_ON_BOTTOM;


        this.adapter_.setMessageText(this.snackbarData_.message);

        if (this.snackbarData_.multiline) {
          this.adapter_.addClass(MULTILINE);
          if (this.snackbarData_.actionOnBottom) {
            this.adapter_.addClass(ACTION_ON_BOTTOM);
          }
        }

        if (this.snackbarData_.actionHandler) {
          this.adapter_.setActionText(this.snackbarData_.actionText);
          this.actionHandler_ = this.snackbarData_.actionHandler;
          this.setActionHidden_(false);
        } else {
          this.setActionHidden_(true);
          this.actionHandler_ = null;
          this.adapter_.setActionText(null);
        }

        this.active_ = true;
        this.adapter_.addClass(ACTIVE);
        this.adapter_.unsetAriaHidden();
        this.adapter_.notifyShow();

        this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      }
    }, {
      key: 'handlePossibleTabKeyboardFocus_',
      value: function handlePossibleTabKeyboardFocus_() {
        var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

        if (hijackFocus) {
          this.setFocusOnAction_();
        }

        this.firstFocus_ = false;
      }
    }, {
      key: 'setFocusOnAction_',
      value: function setFocusOnAction_() {
        this.adapter_.setFocus();
        this.snackbarHasFocus_ = true;
        this.firstFocus_ = false;
      }
    }, {
      key: 'invokeAction_',
      value: function invokeAction_() {
        try {
          if (!this.actionHandler_) {
            return;
          }

          this.actionHandler_();
        } finally {
          if (this.dismissOnAction_) {
            this.cleanup_();
          }
        }
      }
    }, {
      key: 'cleanup_',
      value: function cleanup_() {
        var _this4 = this;

        var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

        if (allowDismissal) {
          var ACTIVE = cssClasses$16.ACTIVE,
              MULTILINE = cssClasses$16.MULTILINE,
              ACTION_ON_BOTTOM = cssClasses$16.ACTION_ON_BOTTOM;


          this.adapter_.removeClass(ACTIVE);

          var handler = function handler() {
            clearTimeout(_this4.timeoutId_);
            _this4.adapter_.deregisterTransitionEndHandler(handler);
            _this4.adapter_.removeClass(MULTILINE);
            _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
            _this4.setActionHidden_(true);
            _this4.adapter_.setAriaHidden();
            _this4.active_ = false;
            _this4.snackbarHasFocus_ = false;
            _this4.adapter_.notifyHide();
            _this4.showNext_();
          };

          this.adapter_.registerTransitionEndHandler(handler);
        }
      }
    }, {
      key: 'showNext_',
      value: function showNext_() {
        if (!this.queue_.length) {
          return;
        }
        this.show(this.queue_.shift());
      }
    }, {
      key: 'setActionHidden_',
      value: function setActionHidden_(isHidden) {
        if (isHidden) {
          this.adapter_.setActionAriaHidden();
        } else {
          this.adapter_.unsetActionAriaHidden();
        }
      }
    }]);
    return MDCSnackbarFoundation;
  }(MDCFoundation);

  var mdcSnackbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes, attrs: { "aria-live": "assertive", "aria-atomic": "true", "aria-hidden": _vm.hidden } }, [_c('div', { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c('div', { staticClass: "mdc-snackbar__action-wrapper" }, [_c('button', { ref: "button", staticClass: "mdc-snackbar__action-button", attrs: { "type": "button", "aria-hidden": _vm.actionHidden } }, [_vm._v(_vm._s(_vm.actionText))])])]);
    }, staticRenderFns: [],
    name: 'mdc-snackbar',
    props: {
      'align-start': Boolean,
      'event': {
        type: String,
        required: false,
        default: function _default() {
          return 'show-snackbar';
        }
      },
      'event-source': {
        type: Object,
        required: false,
        default: function _default() {
          return this.$root;
        }
      },
      'dismisses-on-action': { type: Boolean, default: true }
    },
    data: function data() {
      return {
        classes: {
          'mdc-snackbar--align-start': this.alignStart
        },
        message: '',
        actionText: '',
        hidden: false,
        actionHidden: false
      };
    },

    methods: {
      show: function show(data) {
        this.foundation.show(data);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setAriaHidden: function setAriaHidden() {
          return _this.hidden = true;
        },
        unsetAriaHidden: function unsetAriaHidden() {
          return _this.hidden = false;
        },
        setActionAriaHidden: function setActionAriaHidden() {
          return _this.actionHidden = true;
        },
        unsetActionAriaHidden: function unsetActionAriaHidden() {
          return _this.actionHidden = false;
        },
        setActionText: function setActionText(text) {
          _this.actionText = text;
        },
        setMessageText: function setMessageText(text) {
          _this.message = text;
        },
        setFocus: function setFocus() {
          return _this.$refs.button.focus();
        },
        visibilityIsHidden: function visibilityIsHidden() {
          return document.hidden;
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
          return _this.$refs.button.addEventListener('blur', handler, true);
        },
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
          return _this.$refs.button.removeEventListener('blur', handler, true);
        },
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
          return document.addEventListener('visibilitychange', handler);
        },
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
          return document.removeEventListener('visibilitychange', handler);
        },
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
          return document.body.addEventListener(evt, handler, true);
        },
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
          return document.body.removeEventListener(evt, handler, true);
        },
        registerActionClickHandler: function registerActionClickHandler(handler) {
          return _this.$refs.button.addEventListener('click', handler);
        },
        deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
          return _this.$refs.button.removeEventListener('click', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        notifyShow: function notifyShow() {
          return _this.$emit('show');
        },
        notifyHide: function notifyHide() {
          return _this.$emit('hide');
        }
      });
      this.foundation.init();
      if (this.event) {
        this.eventSource.$on(this.event, function (data) {
          _this.foundation.show(data);
        });
      }
      this.foundation.setDismissOnAction(this.dismissesOnAction);
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCSnackbar = BasePlugin({
    mdcSnackbar: mdcSnackbar
  });

  var mdcSwitch = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch-wrapper", class: { 'mdc-form-field': this.hasLabel, 'mdc-form-field--align-end': this.hasLabel && this.alignEnd } }, [_c('div', { staticClass: "mdc-switch", class: { 'mdc-switch--disabled': _vm.disabled } }, [_c('input', { ref: "control", staticClass: "mdc-switch__native-control", attrs: { "type": "checkbox", "name": _vm.name, "id": _vm._uid, "disabled": _vm.disabled }, domProps: { "checked": _vm.checked }, on: { "change": _vm.onChanged } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _vm.hasLabel ? _c('label', { staticClass: "mdc-switch-label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch__background" }, [_c('div', { staticClass: "mdc-switch__knob" })]);
    }],
    name: 'mdc-switch',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      'checked': Boolean,
      'label': String,
      'alignEnd': Boolean,
      'disabled': Boolean,
      'value': { type: String, default: function _default() {
          return 'on';
        }
      },
      'name': String
    },
    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      }
    },
    methods: {
      onChanged: function onChanged(event) {
        this.$emit('change', event.target.checked);
      }
    }
  };

  var VueMDCSwitch = BasePlugin({
    mdcSwitch: mdcSwitch
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$17 = {
    ACTIVE: 'mdc-tab--active'
  };

  var strings$16 = {
    SELECTED_EVENT: 'MDCTab:selected'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabFoundation = function (_MDCFoundation) {
    inherits(MDCTabFoundation, _MDCFoundation);
    createClass(MDCTabFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$17;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$16;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getOffsetLeft: function getOffsetLeft() {
            return (/* number */0
            );
          },
          notifySelected: function notifySelected() {}
        };
      }
    }]);

    function MDCTabFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCTabFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.isActive_ = false;
      _this.preventDefaultOnClick_ = false;

      _this.clickHandler_ = function (evt) {
        if (_this.preventDefaultOnClick_) {
          evt.preventDefault();
        }
        _this.adapter_.notifySelected();
      };

      _this.keydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
          _this.adapter_.notifySelected();
        }
      };
      return _this;
    }

    createClass(MDCTabFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'getComputedWidth',
      value: function getComputedWidth() {
        return this.computedWidth_;
      }
    }, {
      key: 'getComputedLeft',
      value: function getComputedLeft() {
        return this.computedLeft_;
      }
    }, {
      key: 'isActive',
      value: function isActive() {
        return this.isActive_;
      }
    }, {
      key: 'setActive',
      value: function setActive(isActive) {
        this.isActive_ = isActive;
        if (this.isActive_) {
          this.adapter_.addClass(cssClasses$17.ACTIVE);
        } else {
          this.adapter_.removeClass(cssClasses$17.ACTIVE);
        }
      }
    }, {
      key: 'preventsDefaultOnClick',
      value: function preventsDefaultOnClick() {
        return this.preventDefaultOnClick_;
      }
    }, {
      key: 'setPreventDefaultOnClick',
      value: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.preventDefaultOnClick_ = preventDefaultOnClick;
      }
    }, {
      key: 'measureSelf',
      value: function measureSelf() {
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.computedLeft_ = this.adapter_.getOffsetLeft();
      }
    }]);
    return MDCTabFoundation;
  }(MDCFoundation);

  var mdcTab = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-tab", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [!!_vm.hasIcon ? _c('i', { ref: "icon", staticClass: "mdc-tab__icon", class: _vm.hasIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c('span', { class: { 'mdc-tab__icon-text': !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-tab',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      active: Boolean,
      icon: [String, Array, Object]
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      hasIcon: function hasIcon() {
        if (this.icon || this.$slots.icon) {
          this.icon ? extractIconProp(this.icon) : {};
        }
        return false;
      },
      hasText: function hasText() {
        return !!this.$slots.default;
      }
    },
    methods: {
      getComputedWidth: function getComputedWidth() {
        return this.foundation.getComputedWidth();
      },
      getComputedLeft: function getComputedLeft() {
        return this.foundation.getComputedLeft();
      },
      isActive: function isActive() {
        return this.foundation.isActive();
      },
      setActive: function setActive(isActive) {
        this.foundation.setActive(isActive);
      },
      isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
        return this.foundation.preventsDefaultOnClick();
      },
      setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureSelf: function measureSelf() {
        this.foundation.measureSelf();
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$el.removeEventListener(type, handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getOffsetLeft: function getOffsetLeft() {
          return _this.$el.offsetLeft;
        },
        notifySelected: function notifySelected() {
          emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
        }
      });
      this.foundation.init();
      this.setActive(this.active);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$18 = {
    UPGRADED: 'mdc-tab-bar-upgraded'
  };

  var strings$17 = {
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
    CHANGE_EVENT: 'MDCTabBar:change'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabBarFoundation = function (_MDCFoundation) {
    inherits(MDCTabBarFoundation, _MDCFoundation);
    createClass(MDCTabBarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$18;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$17;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
          getNumberOfTabs: function getNumberOfTabs() {
            return (/* number */0
            );
          },
          isTabActiveAtIndex: function isTabActiveAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
          measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          }
        };
      }
    }]);

    function MDCTabBarFoundation(adapter) {
      classCallCheck(this, MDCTabBarFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

      _this.isIndicatorShown_ = false;
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.activeTabIndex_ = 0;
      _this.layoutFrame_ = 0;
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCTabBarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.addClass(cssClasses$18.UPGRADED);
        this.adapter_.bindOnMDCTabSelectedEvent();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        var activeTabIndex = this.findActiveTabIndex_();
        if (activeTabIndex >= 0) {
          this.activeTabIndex_ = activeTabIndex;
        }
        this.layout();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.removeClass(cssClasses$18.UPGRADED);
        this.adapter_.unbindOnMDCTabSelectedEvent();
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this2 = this;

        this.forEachTabIndex_(function (index) {
          return _this2.adapter_.measureTabAtIndex(index);
        });
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.layoutIndicator_();
      }
    }, {
      key: 'layoutIndicator_',
      value: function layoutIndicator_() {
        var isIndicatorFirstRender = !this.isIndicatorShown_;

        // Ensure that indicator appears in the right position immediately for correct first render.
        if (isIndicatorFirstRender) {
          this.adapter_.setStyleForIndicator('transition', 'none');
        }

        var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
        var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

        var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
        this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

        if (isIndicatorFirstRender) {
          // Force layout so that transform styles to take effect.
          this.adapter_.getOffsetWidthForIndicator();
          this.adapter_.setStyleForIndicator('transition', '');
          this.adapter_.setStyleForIndicator('visibility', 'visible');
          this.isIndicatorShown_ = true;
        }
      }
    }, {
      key: 'findActiveTabIndex_',
      value: function findActiveTabIndex_() {
        var _this3 = this;

        var activeTabIndex = -1;
        this.forEachTabIndex_(function (index) {
          if (_this3.adapter_.isTabActiveAtIndex(index)) {
            activeTabIndex = index;
            return true;
          }
        });
        return activeTabIndex;
      }
    }, {
      key: 'forEachTabIndex_',
      value: function forEachTabIndex_(iterator) {
        var numTabs = this.adapter_.getNumberOfTabs();
        for (var index = 0; index < numTabs; index++) {
          var shouldBreak = iterator(index);
          if (shouldBreak) {
            break;
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();
          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: 'switchToTabAtIndex',
      value: function switchToTabAtIndex(index, shouldNotify) {
        var _this5 = this;

        if (index === this.activeTabIndex_) {
          return;
        }

        if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
          throw new Error('Out of bounds index specified for tab: ' + index);
        }

        var prevActiveTabIndex = this.activeTabIndex_;
        this.activeTabIndex_ = index;
        requestAnimationFrame(function () {
          if (prevActiveTabIndex >= 0) {
            _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
          }
          _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
          _this5.layoutIndicator_();
          if (shouldNotify) {
            _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
          }
        });
      }
    }, {
      key: 'getActiveTabIndex',
      value: function getActiveTabIndex() {
        return this.findActiveTabIndex_();
      }
    }]);
    return MDCTabBarFoundation;
  }(MDCFoundation);

  var mdcTabBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-tab-bar", class: _vm.classes }, [_vm._t("default"), _vm._v(" "), _c('span', { ref: "indicator", staticClass: "mdc-tab-bar__indicator", style: _vm.indicatorStyles })], 2);
    }, staticRenderFns: [],
    name: 'mdc-tab-bar',
    props: {
      'indicator-primary': Boolean,
      'indicator-accent': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-tab-bar--indicator-primary': this.indicatorPrimary,
          'mdc-tab-bar--indicator-accent': this.indicatorAccent
        },
        indicatorStyles: {},
        tabs: []
      };
    },

    methods: {
      onSelect: function onSelect(_ref) {
        var detail = _ref.detail;
        var tab = detail.tab;

        var index = this.tabs.indexOf(tab);
        if (index < 0) {
          throw new Error('mdc-tab-bar internal error: index not found');
        }
        this.foundation.switchToTabAtIndex(index, true);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabBarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
          _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
          return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
          return _this.$set(_this.indicatorStyles, propertyName, value);
        },
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return _this.$refs.indicator.offsetWidth;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData.activeTabIndex);
        },
        getNumberOfTabs: function getNumberOfTabs() {
          return _this.tabs.length;
        },
        isTabActiveAtIndex: function isTabActiveAtIndex(index) {
          return _this.tabs[index].isActive();
        },
        setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
          _this.tabs[index].setActive(isActive);
        },
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
          return _this.tabs[index].isDefaultPreventedOnClick();
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
          _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
        },
        measureTabAtIndex: function measureTabAtIndex(index) {
          return _this.tabs[index].measureSelf();
        },
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
          return _this.tabs[index].getComputedWidth();
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
          return _this.tabs[index].getComputedLeft();
        }
      });

      var resetTabs = function resetTabs() {
        var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        _this.tabs = tabElements.map(function (el) {
          return el.__vue__;
        });

        var hasText = void 0,
            hasIcon = void 0;
        var tabs = _this.tabs;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tab = _step.value;

            if (tab.hasText) {
              hasText = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tab = _step2.value;

            if (_tab.hasIcon) {
              hasIcon = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (hasText && hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
        } else if (hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
        }

        if (_this.foundation) {
          var activeTabIndex = _this.foundation.getActiveTabIndex();
          if (activeTabIndex >= 0) {
            _this.foundation.switchToTabAtIndex(activeTabIndex, true);
          } else {
            _this.foundation.switchToTabAtIndex(0, true);
          }
          _this.foundation.layout();
        }
      };

      resetTabs();

      this.slotObserver = new MutationObserver(function () {
        return resetTabs();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      this.foundation.destroy();
    }
  };

  var VueMDCTabs = BasePlugin({
    mdcTab: mdcTab,
    mdcTabBar: mdcTabBar
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldHelperTextAdapter = function () {
    function MDCTextFieldHelperTextAdapter() {
      classCallCheck(this, MDCTextFieldHelperTextAdapter);
    }

    createClass(MDCTextFieldHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);
    return MDCTextFieldHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$18 = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };

  /** @enum {string} */
  var cssClasses$19 = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
   * @final
   */

  var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
    createClass(MDCTextFieldHelperTextFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$19;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$18;
      }

      /**
       * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldHelperTextAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldHelperTextAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldHelperTextAdapter} adapter
       */

    }]);

    function MDCTextFieldHelperTextFoundation(adapter) {
      classCallCheck(this, MDCTextFieldHelperTextFoundation);
      return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
    }

    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    createClass(MDCTextFieldHelperTextFoundation, [{
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: 'setPersistent',
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        }
      }

      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: 'setValidation',
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        }
      }

      /** Makes the helper text visible to the screen reader. */

    }, {
      key: 'showToScreenReader',
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$18.ARIA_HIDDEN);
      }

      /**
       * Sets the validity of the helper text based on the input validity.
       * @param {boolean} inputIsValid
       */

    }, {
      key: 'setValidity',
      value: function setValidity(inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$18.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$18.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }

      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: 'hide_',
      value: function hide_() {
        this.adapter_.setAttr(strings$18.ARIA_HIDDEN, 'true');
      }
    }]);
    return MDCTextFieldHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the text field icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldIconAdapter = function () {
    function MDCTextFieldIconAdapter() {
      classCallCheck(this, MDCTextFieldIconAdapter);
    }

    createClass(MDCTextFieldIconAdapter, [{
      key: "setAttr",

      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */
      value: function setAttr(attr, value) {}

      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);
    return MDCTextFieldIconAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$19 = {
    ICON_EVENT: 'MDCTextField:icon'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
   * @final
   */

  var MDCTextFieldIconFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldIconFoundation, _MDCFoundation);
    createClass(MDCTextFieldIconFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$19;
      }

      /**
       * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldIconAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldIconAdapter} */{
            setAttr: function setAttr() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldIconAdapter} adapter
       */

    }]);

    function MDCTextFieldIconFoundation(adapter) {
      classCallCheck(this, MDCTextFieldIconFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };
      return _this;
    }

    createClass(MDCTextFieldIconFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }

      /**
       * Sets the content of the helper text field.
       * @param {boolean} disabled
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
        } else {
          this.adapter_.setAttr('tabindex', '0');
        }
      }

      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);
    return MDCTextFieldIconFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Adapter for MDC Text Field.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Text Field into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTextFieldAdapter = function () {
    function MDCTextFieldAdapter() {
      classCallCheck(this, MDCTextFieldAdapter);
    }

    createClass(MDCTextFieldAdapter, [{
      key: 'addClass',

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: 'hasClass',
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerTextFieldInteractionHandler',
      value: function registerTextFieldInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterTextFieldInteractionHandler',
      value: function deregisterTextFieldInteractionHandler(type, handler) {}

      /**
       * Registers an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerInputInteractionHandler',
      value: function registerInputInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterInputInteractionHandler',
      value: function deregisterInputInteractionHandler(evtType, handler) {}

      /**
       * Registers a validation attribute change listener on the input element.
       * @param {function(!Array): undefined} handler
       * @return {!MutationObserver}
       */

    }, {
      key: 'registerValidationAttributeChangeHandler',
      value: function registerValidationAttributeChangeHandler(handler) {}

      /**
       * Disconnects a validation attribute observer on the input element.
       * @param {!MutationObserver} observer
       */

    }, {
      key: 'deregisterValidationAttributeChangeHandler',
      value: function deregisterValidationAttributeChangeHandler(observer) {}

      /**
       * Returns an object representing the native text input element, with a
       * similar API shape. The object returned should include the value, disabled
       * and badInput properties, as well as the checkValidity() function. We never
       * alter the value within our code, however we do update the disabled
       * property, so if you choose to duck-type the return value for this method
       * in your implementation it's important to keep this in mind. Also note that
       * this method can return null, which the foundation will handle gracefully.
       * @return {?Element|?NativeInputType}
       */

    }, {
      key: 'getNativeInput',
      value: function getNativeInput() {}

      /**
       * Returns true if the textfield is focused.
       * We achieve this via `document.activeElement === this.root_`.
       * @return {boolean}
       */

    }, {
      key: 'isFocused',
      value: function isFocused() {}

      /**
       * Returns true if the direction of the root element is set to RTL.
       * @return {boolean}
       */

    }, {
      key: 'isRtl',
      value: function isRtl() {}

      /**
       * Activates the line ripple.
       */

    }, {
      key: 'activateLineRipple',
      value: function activateLineRipple() {}

      /**
       * Deactivates the line ripple.
       */

    }, {
      key: 'deactivateLineRipple',
      value: function deactivateLineRipple() {}

      /**
       * Sets the transform origin of the line ripple.
       * @param {number} normalizedX
       */

    }, {
      key: 'setLineRippleTransformOrigin',
      value: function setLineRippleTransformOrigin(normalizedX) {}

      /**
       * Only implement if label exists.
       * Shakes label if shouldShake is true.
       * @param {boolean} shouldShake
       */

    }, {
      key: 'shakeLabel',
      value: function shakeLabel(shouldShake) {}

      /**
       * Only implement if label exists.
       * Floats the label above the input element if shouldFloat is true.
       * @param {boolean} shouldFloat
       */

    }, {
      key: 'floatLabel',
      value: function floatLabel(shouldFloat) {}

      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasLabel',
      value: function hasLabel() {}

      /**
       * Only implement if label exists.
       * Returns width of label in pixels.
       * @return {number}
       */

    }, {
      key: 'getLabelWidth',
      value: function getLabelWidth() {}

      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasOutline',
      value: function hasOutline() {}

      /**
       * Only implement if outline element exists.
       * Updates SVG Path on outline element based on the
       * label element width and RTL context.
       * @param {number} labelWidth
       * @param {boolean} isRtl
       */

    }, {
      key: 'updateOutlinePath',
      value: function updateOutlinePath(labelWidth, isRtl) {}
    }]);
    return MDCTextFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter = function () {
    function MDCLineRippleAdapter() {
      classCallCheck(this, MDCLineRippleAdapter);
    }

    createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets an attribute with a given value on the line ripple element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);
    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$20 = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation = function (_MDCFoundation) {
    inherits(MDCLineRippleFoundation, _MDCFoundation);
    createClass(MDCLineRippleFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$20;
      }

      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCLineRippleAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }

      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
      classCallCheck(this, MDCLineRippleFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }

    createClass(MDCLineRippleFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }

      /**
       * Activates the line ripple
       */

    }, {
      key: 'activate',
      value: function activate() {
        this.adapter_.removeClass(cssClasses$20.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$20.LINE_RIPPLE_ACTIVE);
      }

      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {!number} xCoordinate
       */

    }, {
      key: 'setRippleCenter',
      value: function setRippleCenter(xCoordinate) {
        var attributeString = 'transform-origin: ' + xCoordinate + 'px center';

        this.adapter_.setAttr('style', attributeString);
      }

      /**
       * Deactivates the line ripple
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$20.LINE_RIPPLE_DEACTIVATING);
      }

      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$20.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$20.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$20.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);
    return MDCLineRippleFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter = function () {
    function MDCFloatingLabelAdapter() {
      classCallCheck(this, MDCFloatingLabelAdapter);
    }

    createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);
    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$21 = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation = function (_MDCFoundation) {
    inherits(MDCFloatingLabelFoundation, _MDCFoundation);
    createClass(MDCFloatingLabelFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$21;
      }

      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCFloatingLabelAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }

      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      classCallCheck(this, MDCFloatingLabelFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }

    createClass(MDCFloatingLabelFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: 'getWidth',
      value: function getWidth() {
        return this.adapter_.getWidth();
      }

      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: 'shake',
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: 'float',
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: 'handleShakeAnimationEnd_',
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);
    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter = function () {
    function MDCNotchedOutlineAdapter() {
      classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    createClass(MDCNotchedOutlineAdapter, [{
      key: "getWidth",

      /**
       * Returns the width of the root element.
       * @return {number}
       */
      value: function getWidth() {}

      /**
       * Returns the height of the root element.
       * @return {number}
       */

    }, {
      key: "getHeight",
      value: function getHeight() {}

      /**
       * Sets the "d" attribute of the outline element's SVG path.
       * @param {string} value
       */

    }, {
      key: "setOutlinePathAttr",
      value: function setOutlinePathAttr(value) {}

      /**
       * Returns the idle outline element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getIdleOutlineStyleValue",
      value: function getIdleOutlineStyleValue(propertyName) {}
    }]);
    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$20 = {
    PATH_SELECTOR: '.mdc-notched-outline__path',
    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation = function (_MDCFoundation) {
    inherits(MDCNotchedOutlineFoundation, _MDCFoundation);
    createClass(MDCNotchedOutlineFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$20;
      }

      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCNotchedOutlineAdapter} */{
            getWidth: function getWidth() {},
            getHeight: function getHeight() {},
            setOutlinePathAttr: function setOutlinePathAttr() {},
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
          }
        );
      }

      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      classCallCheck(this, MDCNotchedOutlineFoundation);
      return possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }

    /**
     * Updates the SVG path of the focus outline element based on the notchWidth
     * and the RTL context.
     * @param {number} notchWidth
     * @param {boolean=} isRtl
     */


    createClass(MDCNotchedOutlineFoundation, [{
      key: 'updateSvgPath',
      value: function updateSvgPath(notchWidth) {
        var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
        var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
        var radius = parseFloat(radiusStyleValue);
        var width = this.adapter_.getWidth();
        var height = this.adapter_.getHeight();
        var cornerWidth = radius + 1.2;
        var leadingStrokeLength = Math.abs(11 - cornerWidth);
        var paddedNotchWidth = notchWidth + 8;

        // The right, bottom, and left sides of the outline follow the same SVG path.
        var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

        var path = void 0;
        if (!isRtl) {
          path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
        } else {
          path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
        }

        this.adapter_.setOutlinePathAttr(path);
      }
    }]);
    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$21 = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    ICON_SELECTOR: '.mdc-text-field__icon',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    BOTTOM_LINE_SELECTOR: '.mdc-line-ripple'
  };

  /** @enum {string} */
  var cssClasses$22 = {
    ROOT: 'mdc-text-field',
    UPGRADED: 'mdc-text-field--upgraded',
    DISABLED: 'mdc-text-field--disabled',
    DENSE: 'mdc-text-field--dense',
    FOCUSED: 'mdc-text-field--focused',
    INVALID: 'mdc-text-field--invalid',
    BOX: 'mdc-text-field--box',
    OUTLINED: 'mdc-text-field--outlined'
  };

  /** @enum {number} */
  var numbers$5 = {
    LABEL_SCALE: 0.75,
    DENSE_LABEL_SCALE: 0.923
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
  // under section: `Validation-related attributes`
  var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

  /**
   * @extends {MDCFoundation<!MDCTextFieldAdapter>}
   * @final
   */

  var MDCTextFieldFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldFoundation, _MDCFoundation);
    createClass(MDCTextFieldFoundation, [{
      key: 'shouldShake',


      /** @return {boolean} */
      get: function get$$1() {
        return !this.isValid() && !this.isFocused_;
      }

      /** @return {boolean} */

    }, {
      key: 'shouldFloat',
      get: function get$$1() {
        return !this.isBadInput_() && (!!this.getValue() || this.isFocused_);
      }

      /**
       * {@see MDCTextFieldAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldAdapter}
       */

    }], [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$22;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$21;
      }

      /** @return enum {string} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$5;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
            registerInputInteractionHandler: function registerInputInteractionHandler() {},
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
            getNativeInput: function getNativeInput() {},
            isFocused: function isFocused() {},
            isRtl: function isRtl() {},
            activateLineRipple: function activateLineRipple() {},
            deactivateLineRipple: function deactivateLineRipple() {},
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
            shakeLabel: function shakeLabel() {},
            floatLabel: function floatLabel() {},
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            updateOutlinePath: function updateOutlinePath() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCTextFieldFoundation(adapter) {
      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
      classCallCheck(this, MDCTextFieldFoundation);

      /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

      _this.helperText_ = foundationMap.helperText;
      /** @type {!MDCTextFieldIconFoundation|undefined} */
      _this.icon_ = foundationMap.icon;

      /** @private {boolean} */
      _this.isFocused_ = false;
      /** @private {boolean} */
      _this.receivedUserInput_ = false;
      /** @private {boolean} */
      _this.useCustomValidityChecking_ = false;
      /** @private {boolean} */
      _this.isValid_ = true;
      /** @private {function(): undefined} */
      _this.inputFocusHandler_ = function () {
        return _this.activateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputBlurHandler_ = function () {
        return _this.deactivateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputInputHandler_ = function () {
        return _this.autoCompleteFocus();
      };
      /** @private {function(!Event): undefined} */
      _this.setPointerXOffset_ = function (evt) {
        return _this.setTransformOrigin(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.textFieldInteractionHandler_ = function () {
        return _this.handleTextFieldInteraction();
      };
      /** @private {function(!Array): undefined} */
      _this.validationAttributeChangeHandler_ = function (mutations) {
        return _this.handleValidationAttributeMutation_(mutations);
      };
      /** @private {!MutationObserver} */
      _this.validationObserver_;
      return _this;
    }

    createClass(MDCTextFieldFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        // Ensure label does not collide with any pre-filled value.
        if (this.adapter_.hasLabel() && this.getValue()) {
          this.adapter_.floatLabel(this.shouldFloat);
        }

        if (this.adapter_.isFocused()) {
          this.inputFocusHandler_();
        }

        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
      }

      /**
       * Handles user interactions with the Text Field.
       */

    }, {
      key: 'handleTextFieldInteraction',
      value: function handleTextFieldInteraction() {
        if (this.adapter_.getNativeInput().disabled) {
          return;
        }
        this.receivedUserInput_ = true;
      }

      /**
       * Handles validation attribute changes
       * @param {Array<MutationRecord>} mutationsList
       * @private
       */

    }, {
      key: 'handleValidationAttributeMutation_',
      value: function handleValidationAttributeMutation_(mutationsList) {
        var _this4 = this;

        mutationsList.some(function (mutation) {
          if (VALIDATION_ATTR_WHITELIST.indexOf(mutation.attributeName) > -1) {
            _this4.styleValidity_(true);
            return true;
          }
        });
      }

      /**
       * Updates the focus outline for outlined text fields.
       */

    }, {
      key: 'updateOutline',
      value: function updateOutline() {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        var isDense = this.adapter_.hasClass(cssClasses$22.DENSE);
        var labelScale = isDense ? numbers$5.DENSE_LABEL_SCALE : numbers$5.LABEL_SCALE;
        var labelWidth = this.adapter_.getLabelWidth() * labelScale;
        var isRtl = this.adapter_.isRtl();
        this.adapter_.updateOutlinePath(labelWidth, isRtl);
      }

      /**
       * Activates the text field focus state.
       */

    }, {
      key: 'activateFocus',
      value: function activateFocus() {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        this.updateOutline();
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }

      /**
       * Sets the line ripple's transform origin, so that the line ripple activate
       * animation will animate out from the user's click location.
       * @param {!Event} evt
       */

    }, {
      key: 'setTransformOrigin',
      value: function setTransformOrigin(evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var evtCoords = { x: evt.clientX, y: evt.clientY };
        var normalizedX = evtCoords.x - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
      }

      /**
       * Activates the Text Field's focus state in cases when the input value
       * changes without user input (e.g. programatically).
       */

    }, {
      key: 'autoCompleteFocus',
      value: function autoCompleteFocus() {
        if (!this.receivedUserInput_) {
          this.activateFocus();
        }
      }

      /**
       * Deactivates the Text Field's focus state.
       */

    }, {
      key: 'deactivateFocus',
      value: function deactivateFocus() {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var input = this.getNativeInput_();
        var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
        if (shouldRemoveLabelFloat) {
          this.receivedUserInput_ = false;
        }
      }

      /**
       * @return {string} The value of the input Element.
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeInput_().value;
      }

      /**
       * @param {string} value The value to set on the input Element.
       */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeInput_().value = value;
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
      }

      /**
       * @return {boolean} If a custom validity is set, returns that value.
       *     Otherwise, returns the result of native validity checks.
       */

    }, {
      key: 'isValid',
      value: function isValid() {
        return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
      }

      /**
       * @param {boolean} isValid Sets the validity state of the Text Field.
       */

    }, {
      key: 'setValid',
      value: function setValid(isValid) {
        this.useCustomValidityChecking_ = true;
        this.isValid_ = isValid;
        // Retrieve from the getter to ensure correct logic is applied.
        isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
        }
      }

      /**
       * @return {boolean} True if the Text Field is disabled.
       */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeInput_().disabled;
      }

      /**
       * @param {boolean} disabled Sets the text-field disabled or enabled.
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
      }

      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: 'setHelperTextContent',
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }

      /**
       * @return {boolean} True if the Text Field input fails in converting the
       *     user-supplied value.
       * @private
       */

    }, {
      key: 'isBadInput_',
      value: function isBadInput_() {
        return this.getNativeInput_().validity.badInput;
      }

      /**
       * @return {boolean} The result of native validity checking
       *     (ValidityState.valid).
       */

    }, {
      key: 'isNativeInputValid_',
      value: function isNativeInputValid_() {
        return this.getNativeInput_().validity.valid;
      }

      /**
       * Styles the component based on the validity state.
       * @param {boolean} isValid
       * @private
       */

    }, {
      key: 'styleValidity_',
      value: function styleValidity_(isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

        if (isValid) {
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
          this.helperText_.setValidity(isValid);
        }
      }

      /**
       * Styles the component based on the focused state.
       * @param {boolean} isFocused
       * @private
       */

    }, {
      key: 'styleFocused_',
      value: function styleFocused_(isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

        if (isFocused) {
          this.adapter_.addClass(FOCUSED);
        } else {
          this.adapter_.removeClass(FOCUSED);
        }
      }

      /**
       * Styles the component based on the disabled state.
       * @param {boolean} isDisabled
       * @private
       */

    }, {
      key: 'styleDisabled_',
      value: function styleDisabled_(isDisabled) {
        var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
            DISABLED = _MDCTextFieldFoundati.DISABLED,
            INVALID = _MDCTextFieldFoundati.INVALID;

        if (isDisabled) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
        if (this.icon_) {
          this.icon_.setDisabled(isDisabled);
        }
      }

      /**
       * @return {!Element|!NativeInputType} The native text input from the
       * host environment, or a dummy if none exists.
       * @private
       */

    }, {
      key: 'getNativeInput_',
      value: function getNativeInput_() {
        return this.adapter_.getNativeInput() ||
        /** @type {!NativeInputType} */{
          value: '',
          disabled: false,
          validity: {
            badInput: false,
            valid: true
          }
        };
      }
    }]);
    return MDCTextFieldFoundation;
  }(MDCFoundation);

  var mdcTextField = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'textarea', _vm.inputAttrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'input', _vm.inputAttrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm._uid } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-notched-outline" }, [_c('svg', [_c('path', { staticClass: "mdc-notched-outline__path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-notched-outline__idle" }) : _vm._e(), _vm._v(" "), _vm.hasBottomLine ? _c('div', { ref: "bottom", class: _vm.bottomClasses }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm._uid, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-textfield',
    mixins: [CustomElementMixin, DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'model'
    },
    props: {
      value: String,
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'email', 'search', 'password', 'tel', 'url'].indexOf(value) !== -1;
        }
      },
      dense: Boolean,
      label: String,
      helptext: String,
      helptextPersistent: Boolean,
      helptextValidation: Boolean,
      box: Boolean,
      outline: Boolean,
      disabled: Boolean,
      required: Boolean,
      valid: { type: Boolean, default: undefined },
      fullwidth: Boolean,
      multiline: Boolean,
      leadingIcon: [String, Array, Object],
      trailingIcon: [String, Array, Object],
      size: { type: [Number, String], default: 20 },
      minlength: { type: [Number, String], default: undefined },
      maxlength: { type: [Number, String], default: undefined },
      rows: { type: [Number, String], default: 8 },
      cols: { type: [Number, String], default: 40 },

      // other input props
      name: String,
      readonly: Boolean,
      autocomplete: Boolean,
      autofocus: Boolean
    },
    data: function data() {
      return {
        text: this.value,
        rootClasses: {
          'mdc-textfield': true,
          'mdc-text-field': true,
          'mdc-text-field--upgraded': true,
          'mdc-text-field--disabled': this.disabled,
          'mdc-text-field--dense': this.dense,
          'mdc-text-field--fullwidth': this.fullwidth,
          'mdc-text-field--textarea': this.multiline,
          'mdc-text-field--box': !this.fullwidth && this.box,
          'mdc-text-field--outlined': !this.fullwidth && this.outline
        },
        inputClasses: {
          'mdc-text-field__input': true
        },
        labelClasses: {
          'mdc-floating-label': true
        },
        bottomClasses: {
          'mdc-line-ripple': true
        },
        helpClasses: {
          'mdc-text-field-helper-text': true,
          'mdc-text-field-helper-text--persistent': this.helptextPersistent,
          'mdc-text-field-helper-text--validation-msg': this.helptextValidation
        },
        outlinePathAttr: undefined
      };
    },
    watch: {
      disabled: function disabled() {
        this.foundation && this.foundation.setDisabled(this.disabled);
      },
      required: function required() {
        this.$refs.input && (this.$refs.input.required = this.required);
      },
      valid: function valid() {
        if (typeof this.valid !== 'undefined') {
          this.foundation && this.foundation.setValid(this.valid);
        }
      },
      dense: function dense() {
        this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
      },
      helptextPersistent: function helptextPersistent() {
        this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
      },
      helptextValidation: function helptextValidation() {
        this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
      },
      value: function value(_value) {
        if (this.foundation) {
          if (_value !== this.foundation.getValue()) {
            this.foundation.setValue(_value);
          }
        }
      }
    },
    methods: {
      updateValue: function updateValue(value) {
        this.$emit('model', value);
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input && this.$refs.input.blur();
      }
    },
    computed: {
      inputAttrs: function inputAttrs() {
        var name = this.name,
            readonly = this.readonly,
            autocomplete = this.autocomplete,
            autofocus = this.autofocus;

        return { name: name, readonly: readonly, autocomplete: autocomplete, autofocus: autofocus };
      },
      inputPlaceHolder: function inputPlaceHolder() {
        return this.fullwidth ? this.label : undefined;
      },
      inputAriaControls: function inputAriaControls() {
        return this.help ? 'help-' + this._uid : undefined;
      },
      hasLabel: function hasLabel() {
        return !this.fullwidth && this.label;
      },
      hasOutline: function hasOutline() {
        return !this.fullwidth && this.outline;
      },
      hasBottomLine: function hasBottomLine() {
        return !this.hasOutline && !this.multiline;
      },
      hasLeadingIcon: function hasLeadingIcon() {
        if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
          return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
        }
        return false;
      },
      hasTrailingIcon: function hasTrailingIcon() {
        if (this.trailingIcon || this.$slots['trailing-icon']) {
          return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
        }
        return false;
      },
      labelClassesUpgraded: function labelClassesUpgraded() {
        return _extends(this.labelClasses, {
          'mdc-floating-label--float-above': this.value
        });
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.$refs.bottom) {
        this.bottomLineFoundation = new MDCLineRippleFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.bottomClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.bottomClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.bottom.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.bottom.setAttribute(name, value);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            _this.$refs.bottom.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            _this.$refs.bottom.removeEventListener(evtType, handler);
          }
        });
        this.bottomLineFoundation.init();
      }

      if (this.$refs.help) {
        this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.helpClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.helpClasses, className);
          },
          hasClass: function hasClass(className) {
            return _this.$refs.help.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.help.setAttribute(name, value);
          },
          removeAttr: function removeAttr(name) {
            _this.$refs.help.removeAttribute(name);
          },
          setContent: function setContent() /*content*/{
            // help text get's updated from {{helptext}}
            // this.$refs.help.textContent = content;
          }
        });
        this.helperTextFoundation.init();
      }

      if (this.$refs.icon) {
        if (this.hasLeadingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
        } else if (this.hasTrailingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
        }

        this.iconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.icon.setAttribute(attr, value);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.icon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.icon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('icon-action');
          }
        });
        this.iconFoundation.init();
      }

      if (this.$refs.label) {
        this.labelFoundation = new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.labelClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.labelClasses, className);
          },
          getWidth: function getWidth() {
            return _this.$refs.label.offsetWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.label.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.label.removeEventListener(evtType, handler);
          }
        });
        this.labelFoundation.init();
      }

      if (this.$refs.outline) {
        this.outlineFoundation = new MDCNotchedOutlineFoundation({
          getWidth: function getWidth() {
            return _this.$refs.outline.offsetWidth;
          },
          getHeight: function getHeight() {
            return _this.$refs.outline.offsetHeight;
          },
          setOutlinePathAttr: function setOutlinePathAttr(value) {
            _this.outlinePathAttr = value;
          },
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
            var idleOutlineElement = _this.$refs.outlineIdle;
            if (idleOutlineElement) {
              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          }
        });
        this.outlineFoundation.init();
      }

      this.foundation = new MDCTextFieldFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$refs.root.classList.contains(className);
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.addEventListener(evtType, handler);
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.removeEventListener(evtType, handler);
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.input;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        deactivateLineRipple: function deactivateLineRipple() {
          if (_this.bottom) {
            _this.bottom.deactivate();
          }
        },
        activateLineRipple: function activateLineRipple() {
          if (_this.bottom) {
            _this.bottom.activate();
          }
        },
        setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
          if (_this.bottom) {
            _this.bottom.setRippleCenter(normalizedX);
          }
        },
        registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
          _this.$refs.input.addEventListener(evtType, handler);
        },
        deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
          _this.$refs.input.removeEventListener(evtType, handler);
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
          var observer = new MutationObserver(handler);
          var targetNode = _this.$refs.input;
          var config = { attributes: true };
          observer.observe(targetNode, config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
          observer.disconnect();
        },
        shakeLabel: function shakeLabel(shouldShake) {
          _this.labelFoundation.shake(shouldShake);
        },
        floatLabel: function floatLabel(shouldFloat) {
          _this.labelFoundation.float(shouldFloat);
        },
        hasLabel: function hasLabel() {
          return !!_this.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          return _this.labelFoundation.getWidth();
        },
        getNativeInput: function getNativeInput() {
          return _this.$refs.input;
        },
        hasOutline: function hasOutline() {
          return !!_this.hasOutline;
        },
        updateOutlinePath: function updateOutlinePath(labelWidth, isRtl) {
          _this.outlineFoundation.updateSvgPath(labelWidth, isRtl);
        }
      }, {
        bottomLine: this.bottomLineFoundation,
        helperText: this.helperTextFoundation,
        icon: this.iconFoundation,
        label: this.labelFoundation,
        outline: this.outlineFoundation
      });

      this.foundation.init();
      this.foundation.setValue(this.value);
      this.foundation.setDisabled(this.disabled);
      this.$refs.input && (this.$refs.input.required = this.required);
      if (typeof this.valid !== 'undefined') {
        this.foundation.setValid(this.valid);
      }

      if (this.textbox) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.bottomLineFoundation && this.bottomLineFoundation.destroy();
      this.helperTextFoundation && this.helperTextFoundation.destroy();
      this.iconFoundation && this.iconFoundation.destroy();
      this.labelFoundation && this.labelFoundation.destroy();
      this.outlineFoundation && this.outlineFoundation.destroy();
      this.ripple && this.ripple.destroy();
    }
  };

  var VueMDCTextfield = BasePlugin({
    mdcTextField: mdcTextField
  });

  var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

  var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

  var mdcTheme = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-theme", class: _vm.classes, attrs: { "tag": _vm.tag } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-theme',
    components: {
      CustomElement: CustomElement
    },
    props: {
      tag: { type: String, default: 'div' },
      color: String,
      background: String
    },
    computed: {
      classes: function classes() {
        var classes = {};

        if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color] = true;
        }

        if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
          classes['mdc-theme--' + this.background + '-bg'] = true;

          if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
            classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
          }
        }
        return classes;
      }
    }
  };

  var VueMDCTheme = BasePlugin({
    mdcTheme: mdcTheme
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$23 = {
    FIXED: 'mdc-toolbar--fixed',
    FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
    FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
    TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
    FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
    FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
    FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
  };

  var strings$22 = {
    TITLE_SELECTOR: '.mdc-toolbar__title',
    ICON_SELECTOR: '.mdc-toolbar__icon',
    FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
    CHANGE_EVENT: 'MDCToolbar:change'
  };

  var numbers$6 = {
    MAX_TITLE_SIZE: 2.125,
    MIN_TITLE_SIZE: 1.25,
    TOOLBAR_ROW_HEIGHT: 64,
    TOOLBAR_ROW_MOBILE_HEIGHT: 56,
    TOOLBAR_MOBILE_BREAKPOINT: 600
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCToolbarFoundation = function (_MDCFoundation) {
    inherits(MDCToolbarFoundation, _MDCFoundation);
    createClass(MDCToolbarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$23;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$22;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
          deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getViewportWidth: function getViewportWidth() {
            return (/* number */0
            );
          },
          getViewportScrollY: function getViewportScrollY() {
            return (/* number */0
            );
          },
          getOffsetHeight: function getOffsetHeight() {
            return (/* number */0
            );
          },
          getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
          setStyle: function setStyle() /* property: string, value: string */{},
          setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
          setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
          setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
        };
      }
    }]);

    function MDCToolbarFoundation(adapter) {
      classCallCheck(this, MDCToolbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.checkRowHeight_();
      };
      _this.scrollHandler_ = function () {
        return _this.updateToolbarStyles_();
      };
      _this.checkRowHeightFrame_ = 0;
      _this.scrollFrame_ = 0;
      _this.executedLastChange_ = false;

      _this.calculations_ = {
        toolbarRowHeight: 0,
        // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
        toolbarRatio: 0, // The ratio of toolbar height to row height
        flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
        maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
        scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
        // Derived Heights based on the above key ratios.
        toolbarHeight: 0,
        flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
        maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
        scrollThreshold: 0
      };
      // Toolbar fixed behavior
      // If toolbar is fixed
      _this.fixed_ = false;
      // If fixed is targeted only at the last row
      _this.fixedLastrow_ = false;
      // Toolbar flexible behavior
      // If the first row is flexible
      _this.hasFlexibleRow_ = false;
      // If use the default behavior
      _this.useFlexDefaultBehavior_ = false;
      return _this;
    }

    createClass(MDCToolbarFoundation, [{
      key: 'init',
      value: function init() {
        this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
        this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
        this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
        if (this.hasFlexibleRow_) {
          this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
        }
        this.initKeyRatio_();
        this.setKeyHeights_();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'updateAdjustElementStyles',
      value: function updateAdjustElementStyles() {
        if (this.fixed_) {
          this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
        }
      }
    }, {
      key: 'getFlexibleExpansionRatio_',
      value: function getFlexibleExpansionRatio_(scrollTop) {
        // To prevent division by zero when there is no flexibleExpansionHeight
        var delta = 0.0001;
        return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
      }
    }, {
      key: 'checkRowHeight_',
      value: function checkRowHeight_() {
        var _this2 = this;

        cancelAnimationFrame(this.checkRowHeightFrame_);
        this.checkRowHeightFrame_ = requestAnimationFrame(function () {
          return _this2.setKeyHeights_();
        });
      }
    }, {
      key: 'setKeyHeights_',
      value: function setKeyHeights_() {
        var newToolbarRowHeight = this.getRowHeight_();
        if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
          this.calculations_.toolbarRowHeight = newToolbarRowHeight;
          this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
          this.updateAdjustElementStyles();
          this.updateToolbarStyles_();
        }
      }
    }, {
      key: 'updateToolbarStyles_',
      value: function updateToolbarStyles_() {
        var _this3 = this;

        cancelAnimationFrame(this.scrollFrame_);
        this.scrollFrame_ = requestAnimationFrame(function () {
          var scrollTop = _this3.adapter_.getViewportScrollY();
          var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

          if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
            return;
          }

          var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

          _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
          if (_this3.fixedLastrow_) {
            _this3.updateToolbarFixedState_(scrollTop);
          }
          if (_this3.hasFlexibleRow_) {
            _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
          }
          _this3.executedLastChange_ = hasScrolledOutOfThreshold;
          _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
        });
      }
    }, {
      key: 'scrolledOutOfThreshold_',
      value: function scrolledOutOfThreshold_(scrollTop) {
        return scrollTop > this.calculations_.scrollThreshold;
      }
    }, {
      key: 'initKeyRatio_',
      value: function initKeyRatio_() {
        var toolbarRowHeight = this.getRowHeight_();
        var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
        this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
        this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
        this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
        this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
      }
    }, {
      key: 'getRowHeight_',
      value: function getRowHeight_() {
        var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
        return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
      }
    }, {
      key: 'updateToolbarFlexibleState_',
      value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        if (flexibleExpansionRatio === 1) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        } else if (flexibleExpansionRatio === 0) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        }
      }
    }, {
      key: 'updateToolbarFixedState_',
      value: function updateToolbarFixedState_(scrollTop) {
        var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
        this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

        if (translateDistance === this.calculations_.maxTranslateYDistance) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        } else {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        }
      }
    }, {
      key: 'updateFlexibleRowElementStyles_',
      value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
        if (this.fixed_) {
          var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
          this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
        }
        if (this.useFlexDefaultBehavior_) {
          this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
        }
      }
    }, {
      key: 'updateElementStylesDefaultBehavior_',
      value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
        var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
        var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
        var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

        this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
      }
    }]);
    return MDCToolbarFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var supportsPassive_$2 = void 0;

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive$2() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$2 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$2 = isSupported;
    }

    return supportsPassive_$2 ? { passive: true } : false;
  }

  var mdcToolbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { staticClass: "mdc-toolbar-wrapper" }, [_c('div', { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c('div', { ref: "fixed-adjust", staticClass: "mdc-toolbar-fixed-adjust", style: _vm.adjustStyles }) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-toolbar',
    props: {
      'fixed': Boolean,
      'waterfall': Boolean,
      'fixed-lastrow': Boolean,
      'flexible': Boolean,
      'flexible-default': { type: Boolean, default: true }
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-toolbar': true,
          'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
          'mdc-toolbar--waterfall': this.waterfall,
          'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
          'mdc-toolbar--flexible': this.flexible,
          'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
        },
        rootStyles: {},
        adjustStyles: {
          // to avoid top margin collapse with :after el
          // 0.1 px should be rounded to 0px
          // TODO: find a better trick
          // height: '0.1px'
        },
        foundation: null
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCToolbarFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler, applyPassive$2());
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler, applyPassive$2());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        getViewportWidth: function getViewportWidth() {
          return window.innerWidth;
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getOffsetHeight: function getOffsetHeight() {
          return _this.$refs.root.offsetHeight;
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          return el ? el.offsetHeight : undefined;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        setStyleForTitleElement: function setStyleForTitleElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
          _this.$set(_this.adjustStyles, property, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcToolbarRow = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-row'
  };

  var mdcToolbarSection = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-toolbar-section mdc-toolbar__section", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-section',
    props: {
      'align-start': Boolean,
      'align-end': Boolean,
      'shrink-to-fit': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-toolbar__section--align-start': this.alignStart,
          'mdc-toolbar__section--align-end': this.alignEnd,
          'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
        }
      };
    }
  };

  var mdcToolbarMenuIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-menu-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: { type: String, 'default': "menu" }
    }
  };

  var mdcToolbarTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-title mdc-toolbar__title", on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-title',
    mixins: [DispatchEventMixin]
  };

  var mdcToolbarIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-icon mdc-toolbar__icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    }
  };

  var VueMDCToolbar = BasePlugin({
    mdcToolbar: mdcToolbar,
    mdcToolbarRow: mdcToolbarRow,
    mdcToolbarSection: mdcToolbarSection,
    mdcToolbarMenuIcon: mdcToolbarMenuIcon,
    mdcToolbarTitle: mdcToolbarTitle,
    mdcToolbarIcon: mdcToolbarIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$23 = {
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item'
  };

  /** @enum {string} */
  var cssClasses$24 = {
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Top App Bar
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Top App Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTopAppBarAdapter = function () {
    function MDCTopAppBarAdapter() {
      classCallCheck(this, MDCTopAppBarAdapter);
    }

    createClass(MDCTopAppBarAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerNavigationIconInteractionHandler",
      value: function registerNavigationIconInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterNavigationIconInteractionHandler",
      value: function deregisterNavigationIconInteractionHandler(type, handler) {}

      /**
       * Emits an event when the navigation icon is clicked.
       */

    }, {
      key: "notifyNavigationIconClicked",
      value: function notifyNavigationIconClicked() {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerScrollHandler",
      value: function registerScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterScrollHandler",
      value: function deregisterScrollHandler(handler) {}

      /** @return {number} */

    }, {
      key: "getViewportScrollY",
      value: function getViewportScrollY() {}

      /** @return {number} */

    }, {
      key: "getTotalActionItems",
      value: function getTotalActionItems() {}
    }]);
    return MDCTopAppBarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
   */

  var MDCTopAppBarFoundation = function (_MDCFoundation) {
    inherits(MDCTopAppBarFoundation, _MDCFoundation);
    createClass(MDCTopAppBarFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$23;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$24;
      }

      /**
       * {@see MDCTopAppBarAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTopAppBarAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTopAppBarAdapter} */{
            hasClass: function hasClass() /* className: string */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
            registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
            deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
            getViewportScrollY: function getViewportScrollY() {
              return (/* number */0
              );
            },
            getTotalActionItems: function getTotalActionItems() {
              return (/* number */0
              );
            }
          }
        );
      }

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */

    }]);

    function MDCTopAppBarFoundation(adapter) {
      classCallCheck(this, MDCTopAppBarFoundation);

      var _this = possibleConstructorReturn(this, (MDCTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarFoundation)).call(this, _extends(MDCTopAppBarFoundation.defaultAdapter, adapter)));

      _this.navClickHandler_ = function () {
        return _this.adapter_.notifyNavigationIconClicked();
      };
      return _this;
    }

    createClass(MDCTopAppBarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }]);
    return MDCTopAppBarFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCTopAppBarFoundation<!MDCShortTopAppBarFoundation>}
   * @final
   */

  var MDCShortTopAppBarFoundation = function (_MDCTopAppBarFoundati) {
    inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarFoundati);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCShortTopAppBarFoundation(adapter) {
      classCallCheck(this, MDCShortTopAppBarFoundation);

      // State variable for the current top app bar state
      var _this = possibleConstructorReturn(this, (MDCShortTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation)).call(this, adapter));

      _this.isCollapsed = false;

      _this.scrollHandler_ = function () {
        return _this.shortAppBarScrollHandler_();
      };
      return _this;
    }

    createClass(MDCShortTopAppBarFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'init', this).call(this);
        var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$24.SHORT_COLLAPSED_CLASS);

        if (this.adapter_.getTotalActionItems() > 0) {
          this.adapter_.addClass(cssClasses$24.SHORT_HAS_ACTION_ITEM_CLASS);
        }

        if (!isAlwaysCollapsed) {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.shortAppBarScrollHandler_();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'destroy', this).call(this);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }

      /**
       * Scroll handler for applying/removing the collapsed modifier class
       * on the short top app bar.
       */

    }, {
      key: 'shortAppBarScrollHandler_',
      value: function shortAppBarScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.isCollapsed) {
            this.adapter_.removeClass(cssClasses$24.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = false;
          }
        } else {
          if (!this.isCollapsed) {
            this.adapter_.addClass(cssClasses$24.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = true;
          }
        }
      }
    }]);
    return MDCShortTopAppBarFoundation;
  }(MDCTopAppBarFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var supportsPassive_$3 = void 0;

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$3() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$3 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$3 = isSupported;
    }

    return supportsPassive_$3 ? { passive: true } : false;
  }

  var mdcTopAppBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { ref: "root", class: _vm.rootClasses }, [_c('div', { staticClass: "mdc-top-app-bar__row" }, [_c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-start" }, [_vm.haveNavigationIcon ? _c('a', { ref: "navigationIcon", class: _vm.naviconClasses, attrs: { "href": "#" }, on: { "click": _vm.dispatchEvent } }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), !!_vm.title ? _c('span', { staticClass: "mdc-top-app-bar__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm.$slots.default ? _c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-end" }, [_vm._t("default")], 2) : _vm._e()])]);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar',
    props: {
      short: Boolean,
      shortCollapsed: Boolean,
      title: String,
      icon: {
        type: String,
        default: 'menu'
      },
      iconClasses: Object
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-top-app-bar': true,
          'mdc-top-app-bar--short': this.short,
          'mdc-top-app-bar--short-collapsed': this.shortCollapsed
        },
        foundation: null
      };
    },

    mixins: [DispatchEventMixin],
    mounted: function mounted() {
      var _this = this;

      var adapter = {
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.addEventListener(type, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.removeEventListener(type, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          emitCustomEvent(_this.$el, MDCTopAppBarFoundation.strings.NAVIGATION_EVENT, {}, true);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler, applyPassive$3());
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },

        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this.$refs.root.querySelectorAll(MDCTopAppBarFoundation.strings.ACTION_ITEM_SELECTOR).length;
        }
      };

      this.foundation = this.short ? new MDCShortTopAppBarFoundation(adapter) : new MDCTopAppBarFoundation(adapter);

      this.foundation.init();
    },

    computed: {
      haveNavigationIcon: function haveNavigationIcon() {
        return !!this.icon || this.iconClasses;
      },
      naviconClasses: function naviconClasses() {
        return _extends({
          'mdc-top-app-bar__navigation-icon': true,
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcTopAppBarAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-top-app-bar--action mdc-top-app-bar__action-item", class: _vm.actioniconClasses, attrs: { "href": "#" }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar--action',
    mixins: [DispatchEventMixin, RippleMixin],
    props: {
      icon: String,
      iconClasses: Object
    },
    computed: {
      actioniconClasses: function actioniconClasses() {
        return _extends({
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    }
  };

  var VueMDCTopAppBar = BasePlugin({
    mdcTopAppBar: mdcTopAppBar,
    mdcTopAppBarAction: mdcTopAppBarAction
  });

  var typos = ['display4', 'display3', 'display2', 'display1', 'headline', 'title', 'subheading1', 'subheading2', 'body1', 'body2', 'caption', 'button'];

  var mdcTypoMixin = function mdcTypoMixin(name) {
    return {
      render: function render(createElement) {
        var _class;

        return createElement(this.tag, {
          'class': (_class = {
            'mdc-typo': true
          }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), defineProperty(_class, 'mdc-typography--adjust-margin', this.adjustMargin), _class),
          'attrs': this.$attrs,
          'on': this.$listeners
        }, this.$slots.default);
      }
    };
  };

  function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
    return {
      props: {
        'tag': {
          type: String,
          default: defaultTag
        },
        'typo': {
          type: String,
          default: defaultTypo,
          validator: function validator(value) {
            return validTypos.indexOf(value) !== -1;
          }
        },
        'adjust-margin': {
          type: Boolean,
          default: false
        }
      }
    };
  }

  var mdcTextSection = {
    name: 'mdc-text-section',
    props: {
      'tag': {
        type: String,
        default: 'section'
      }
    },
    render: function render(createElement) {
      return createElement(this.tag, {
        'class': {
          'mdc-typography': true,
          'mdc-text-section': true
        },
        'attrs': this.$attrs,
        'on': this.$listeners
      }, this.$slots.default);
    }
  };

  var mdcText = {
    name: 'mdc-text',
    mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
  };

  var mdcDisplay = {
    name: 'mdc-display',
    mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'display1', ['display4', 'display3', 'display2', 'display1'])]
  };

  var mdcHeadline = {
    name: 'mdc-headline',
    mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline', ['headline'])]
  };

  var mdcTitle = {
    name: 'mdc-title',
    mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'title', ['title'])]
  };

  var mdcSubHeading = {
    name: 'mdc-subheading',
    mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subheading2', ['subheading1', 'subheading2'])]
  };

  var mdcBody = {
    name: 'mdc-body',
    mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
  };

  var mdcCaption = {
    name: 'mdc-caption',
    mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
  };

  var VueMDCTypography = BasePlugin({
    mdcTextSection: mdcTextSection,
    mdcText: mdcText,
    mdcBody: mdcBody,
    mdcCaption: mdcCaption,
    mdcDisplay: mdcDisplay,
    mdcHeadline: mdcHeadline,
    mdcSubHeading: mdcSubHeading,
    mdcTitle: mdcTitle
  });

  //

  var plugin = {
    version: '0.13.2',
    install: function install(vm) {
      vm.use(VueMDCButton);
      vm.use(VueMDCCard);
      vm.use(VueMDCCheckbox);
      vm.use(VueMDCChipSet);
      vm.use(VueMDCDialog);
      vm.use(VueMDCDrawer);
      vm.use(VueMDCElevation);
      vm.use(VueMDCFab);
      vm.use(VueMDCGridList);
      vm.use(VueMDCIcon);
      vm.use(VueMDCIconToggle);
      vm.use(VueMDCLayoutApp);
      vm.use(VueMDCLayoutGrid);
      vm.use(VueMDCLinearProgress);
      vm.use(VueMDCList);
      vm.use(VueMDCMenu);
      vm.use(VueMDCRadio);
      vm.use(VueMDCRipple);
      vm.use(VueMDCSelect);
      vm.use(VueMDCSlider);
      vm.use(VueMDCSnackbar);
      vm.use(VueMDCSwitch);
      vm.use(VueMDCTabs);
      vm.use(VueMDCTextfield);
      vm.use(VueMDCTheme);
      vm.use(VueMDCToolbar);
      vm.use(VueMDCTopAppBar);
      vm.use(VueMDCTypography);
    }
  };

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1lbGVtZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1saW5rLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9jdXN0b20tYnV0dG9uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1pY29uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWV2ZW50LW1peGluLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWZvY3VzLW1peGluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi1iYXNlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvYnV0dG9uL21kYy1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1tZWRpYS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtc3VidGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRleHQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L21kYy1jaGVja2JveC52dWUiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9jaGlwcy9tZGMtY2hpcC1zZXQudnVlIiwiLi4vY29tcG9uZW50cy9jaGlwcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RpYWxvZy9tZGMtZGlhbG9nLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy10ZW1wb3JhcnktZHJhd2VyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1sYXlvdXQudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VsZXZhdGlvbi9tZGMtZWxldmF0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9mYWIvbWRjLWZhYi52dWUiLCIuLi9jb21wb25lbnRzL2ZhYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9tZGMtZ3JpZC1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLXRpbGUudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ljb24vbWRjLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9pY29uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL21kYy1pY29uLXRvZ2dsZS52dWUiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL21kYy1sYXlvdXQtYXBwLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWFwcC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1jZWxsLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1pbm5lci1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9saW5lYXItcHJvZ3Jlc3MvbWRjLWxpbmVhci1wcm9ncmVzcy52dWUiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1hbmNob3IudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JhZGlvL21kYy1yYWRpby52dWUiLCIuLi9jb21wb25lbnRzL3JhZGlvL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW5hdGl2ZS1zZWxlY3QudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2JvdHRvbS1saW5lL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9ib3R0b20tbGluZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9ib3R0b20tbGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvbGFiZWwvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2xhYmVsL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2xhYmVsL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbWVudS1zZWxlY3QudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW11bHRpLXNlbGVjdC52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtc2VsZWN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1uYXRpdmUtb3B0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1tZW51LW9wdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbXVsdGktb3B0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1vcHRpb24udnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2xpZGVyL21kYy1zbGlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9zbGlkZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NuYWNrYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvbWRjLXNuYWNrYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9tZGMtc3dpdGNoLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc3dpdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RhYnMvbWRjLXRhYi52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWItYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGFicy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL21kYy10ZXh0ZmllbGQudnVlIiwiLi4vY29tcG9uZW50cy90ZXh0ZmllbGQvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3RoZW1lL21kYy10aGVtZS52dWUiLCIuLi9jb21wb25lbnRzL3RoZW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b29sYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b29sYmFyL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXIudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXJvdy52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItc2VjdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItbWVudS1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvdXRpbC5qcyIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLS1hY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy90b3AtYXBwLWJhci9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9tZGMtdHlwb2dyYXBoeS5qcyIsIi4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhdXRvSW5pdCAocGx1Z2luKSB7XG4gIC8vIEF1dG8taW5zdGFsbFxuICBsZXQgX1Z1ZSA9IG51bGxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX1Z1ZSA9IHdpbmRvdy5WdWVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qZ2xvYmFsIGdsb2JhbCovXG4gICAgX1Z1ZSA9IGdsb2JhbC5WdWVcbiAgfVxuICBpZiAoX1Z1ZSkge1xuICAgIF9WdWUudXNlKHBsdWdpbilcbiAgfVxufVxuICAiLCJleHBvcnQgZnVuY3Rpb24gQmFzZVBsdWdpbiAoY29tcG9uZW50cykgeyBcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICAgIGluc3RhbGw6ICh2bSkgPT4ge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNba2V5XVxuICAgICAgICAgIHZtLmNvbXBvbmVudChjb21wb25lbnQubmFtZSxjb21wb25lbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzXG4gIH0gXG59XG5cbiIsImV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgIGNvbnRleHQucHJvcHMuaXMgfHwgY29udGV4dC5wcm9wcy50YWcgfHwgJ2RpdicsIFxuICAgICAgY29udGV4dC5kYXRhLFxuICAgICAgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudE1peGluID0ge1xuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tTGluayA9IHtcbiAgbmFtZTogJ2N1c3RvbS1saW5rJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnYScgfSxcbiAgICBsaW5rIDogT2JqZWN0LFxuICB9LFxuICByZW5kZXIgKGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZWxlbWVudCBcbiAgICBsZXQgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuZGF0YSlcblxuICAgIGlmIChjb250ZXh0LnByb3BzLmxpbmsgJiYgY29udGV4dC5wYXJlbnQuJHJvdXRlcikge1xuICAgICAgLy8gcm91dGVyLWxpbmsgY2FzZVxuICAgICAgZWxlbWVudCA9IGNvbnRleHQucGFyZW50LiRyb290LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ10gXG4gICAgICBkYXRhLnByb3BzID0gT2JqZWN0LmFzc2lnbih7dGFnOiBjb250ZXh0LnByb3BzLnRhZ30sIGNvbnRleHQucHJvcHMubGluaylcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7Y2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbGVtZW50IGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wcm9wcy50YWcgXG4gICAgfSBcblxuICAgIHJldHVybiBoKGVsZW1lbnQsIGRhdGEsIGNvbnRleHQuY2hpbGRyZW4pXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEN1c3RvbUxpbmtNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICB0bzogW1N0cmluZywgT2JqZWN0XSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaW5rICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvICYmIHtcbiAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgICBhcHBlbmQ6IHRoaXMuYXBwZW5kLFxuICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2UsXG4gICAgICAgIGFjdGl2ZUNsYXNzOiB0aGlzLmFjdGl2ZUNsYXNzLFxuICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRzIDogeyBcbiAgICBDdXN0b21MaW5rIFxuICB9XG59IiwiLyogZ2xvYmFsIEN1c3RvbUV2ZW50ICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbWl0Q3VzdG9tRXZlbnQgKGVsLCBldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICBsZXQgZXZ0XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKVxuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSlcbiAgfVxuICBlbC5kaXNwYXRjaEV2ZW50KGV2dClcbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21CdXR0b24gPSB7XG4gIG5hbWU6ICdjdXN0b20tYnV0dG9uJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBsaW5rIDogT2JqZWN0LFxuICB9LFxuICByZW5kZXIgKGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZWxlbWVudCBcbiAgICBsZXQgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuZGF0YSlcblxuICAgIGlmIChjb250ZXh0LnByb3BzLmxpbmsgJiYgY29udGV4dC5wYXJlbnQuJHJvdXRlcikge1xuICAgICAgLy8gcm91dGVyLWxpbmsgY2FzZVxuICAgICAgZWxlbWVudCA9IGNvbnRleHQucGFyZW50LiRyb290LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ10gXG4gICAgICBkYXRhLnByb3BzID0gT2JqZWN0LmFzc2lnbih7dGFnOiBjb250ZXh0LnByb3BzLnRhZ30sIGNvbnRleHQucHJvcHMubGluaylcbiAgICAgIGRhdGEuYXR0cnMucm9sZSA9ICdidXR0b24nXG4gICAgICBpZiAoZGF0YS5vbi5jbGljaykge1xuICAgICAgICBkYXRhLm5hdGl2ZU9uID0ge2NsaWNrOiBkYXRhLm9uLmNsaWNrIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5ocmVmKSB7XG4gICAgICAvLyBocmVmIGNhc2VcbiAgICAgIGVsZW1lbnQgPSAnYScgXG4gICAgICBkYXRhLmF0dHJzLnJvbGUgPSAnYnV0dG9uJ1xuICAgIH0gIGVsc2Uge1xuICAgICAgLy8gYnV0dG9uIGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gJ2J1dHRvbidcbiAgICB9IFxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tQnV0dG9uTWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgaHJlZjogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpbmsgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG8gJiYge1xuICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHMgOiB7IFxuICAgIEN1c3RvbUJ1dHRvbiBcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJY29uUHJvcCAoaWNvblByb3ApIHtcbiAgICBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogeyAnbWF0ZXJpYWwtaWNvbnMnIDogdHJ1ZX0sXG4gICAgICAgIGNvbnRlbnQ6IGljb25Qcm9wIFxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpY29uUHJvcCBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjbGFzc2VzOiBpY29uUHJvcC5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgdmFsdWUpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LHtbdmFsdWVdOnRydWV9KSxcbiAgICAgICAgICB7fSksXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnb2JqZWN0Jyl7XG4gICAgICByZXR1cm4geyBcbiAgICAgICAgY2xhc3NlczogaWNvblByb3AuY2xhc3NOYW1lLnNwbGl0KCcgJykucmVkdWNlKFxuICAgICAgICAgIChyZXN1bHQsIHZhbHVlKSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCx7W3ZhbHVlXTp0cnVlfSksXG4gICAgICAgICAge30pLFxuICAgICAgICBjb250ZW50OiBpY29uUHJvcC50ZXh0Q29udGVudCBcbiAgICAgIH1cbiAgICB9XG4gIH1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEV2ZW50TWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgJ2V2ZW50JzogU3RyaW5nLFxuICAgICdldmVudC10YXJnZXQnOiBPYmplY3QsXG4gICAgJ2V2ZW50LWFyZ3MnOiBBcnJheSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGRpc3BhdGNoRXZlbnQgKGV2dCkge1xuICAgICAgdGhpcy4kZW1pdChldnQudHlwZSlcbiAgICAgIGlmICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0IHx8IHRoaXMuJHJvb3RcbiAgICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV2ZW50QXJncyB8fCBbXVxuICAgICAgICB0YXJnZXQuJGVtaXQodGhpcy5ldmVudCwgLi4uYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEZvY3VzTWl4aW4gPSB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiAge2hhc0ZvY3VzOiBmYWxzZX1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uTW91c2VEb3duKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZVxuICAgIH0sXG4gICAgb25Nb3VzZVVwICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlXG4gICAgfSxcbiAgICBvbkZvY3VzRXZlbnQgKCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksMClcbiAgICB9LFxuICAgIG9uQmx1ckV2ZW50ICgpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGFzeW5jIHRvIGxldCB0aW1lIHRvIG90aGVyIGZvY3VzIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICAgICAgLy8gYWxzbyBmaWx0dXIgYmx1ciBpZiBtb3VzZWRvd25cbiAgICAgIHRoaXMuX2FjdGl2ZSB8fCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksMClcbiAgICB9LFxuICAgIGRpc3BhdGNoRm9jdXNFdmVudCgpIHtcbiAgICAgIGxldCBoYXNGb2N1cyA9IHRoaXMuJGVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IHRoaXMuJGVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgaWYgKGhhc0ZvY3VzICE9IHRoaXMuaGFzRm9jdXMpIHtcbiAgICAgICAgdGhpcy4kZW1pdChoYXNGb2N1cyA/ICdmb2N1cycgOiAnYmx1cicpXG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBoYXNGb2N1c1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMub25Gb2N1c0V2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5vbkJsdXJFdmVudClcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMub25Gb2N1c0V2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5vbkJsdXJFdmVudClcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcClcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgUmlwcGxlLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIENTUyB2YXJpYWJsZXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBzY3JvbGwgcG9zaXRpb25cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gdW5ib3VuZGVkLCBhY3RpdmUgYW5kIGRpc2FibGVkIHN0YXRlc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmlwcGxlQWRhcHRlciB7XG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBicm93c2VyU3VwcG9ydHNDc3NWYXJzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNVbmJvdW5kZWQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VBY3RpdmUoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VEaXNhYmxlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldCAqL1xuICBjb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhck5hbWVcbiAgICogQHBhcmFtIHs/bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICovXG4gIHVwZGF0ZUNzc1ZhcmlhYmxlKHZhck5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshQ2xpZW50UmVjdH0gKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19ICovXG4gIGdldFdpbmRvd1BhZ2VPZmZzZXQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgLy8gZ2l2ZW4gdGhhdCBpdCdzIGFuICd1cGdyYWRlJyB0byBhbiBleGlzdGluZyBjb21wb25lbnQuIFRoYXQgYmVpbmcgc2FpZCBpdCBpcyB0aGUgcm9vdFxuICAvLyBDU1MgY2xhc3MgdGhhdCBhbGwgb3RoZXIgQ1NTIGNsYXNzZXMgZGVyaXZlIGZyb20uXG4gIFJPT1Q6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkJyxcbiAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbiAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXG4gIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBWQVJfTEVGVDogJy0tbWRjLXJpcHBsZS1sZWZ0JyxcbiAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxuICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtc3RhcnQnLFxuICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbn07XG5cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBRERJTkc6IDEwLFxuICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxuICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS1mYWRlLW91dC1kdXJhdGlvbiAoaS5lLiBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBUQVBfREVMQVlfTVM6IDMwMCwgLy8gRGVsYXkgYmV0d2VlbiB0b3VjaCBhbmQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBvbiB0b3VjaCBkZXZpY2VzXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIHN1cHBvcnRzQ3NzVmFyaWFibGVzIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBDU1MgY3VzdG9tIHZhcmlhYmxlIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIGFwcGx5UGFzc2l2ZSB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopIHtcbiAgLy8gRGV0ZWN0IHZlcnNpb25zIG9mIEVkZ2Ugd2l0aCBidWdneSB2YXIoKSBzdXBwb3J0XG4gIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTE0OTU0NDgvXG4gIGNvbnN0IGRvY3VtZW50ID0gd2luZG93T2JqLmRvY3VtZW50O1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG5vZGUuY2xhc3NOYW1lID0gJ21kYy1yaXBwbGUtc3VyZmFjZS0tdGVzdC1lZGdlLXZhci1idWcnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gIC8vIFRoZSBidWcgZXhpc3RzIGlmIDo6YmVmb3JlIHN0eWxlIGVuZHMgdXAgcHJvcGFnYXRpbmcgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAvLyBBZGRpdGlvbmFsbHksIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBudWxsIGluIGlmcmFtZXMgd2l0aCBkaXNwbGF5OiBcIm5vbmVcIiBpbiBGaXJlZm94LFxuICAvLyBidXQgRmlyZWZveCBpcyBrbm93biB0byBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyBjb3JyZWN0bHkuXG4gIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3dPYmouZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgY29uc3QgaGFzUHNldWRvVmFyQnVnID0gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLmJvcmRlclRvcFN0eWxlID09PSAnc29saWQnO1xuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gaGFzUHNldWRvVmFyQnVnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvd09iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgfVxuXG4gIGNvbnN0IHN1cHBvcnRzRnVuY3Rpb25QcmVzZW50ID0gd2luZG93T2JqLkNTUyAmJiB0eXBlb2Ygd2luZG93T2JqLkNTUy5zdXBwb3J0cyA9PT0gJ2Z1bmN0aW9uJztcbiAgaWYgKCFzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgPSB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzKCctLWNzcy12YXJzJywgJ3llcycpO1xuICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTQ2NjlcbiAgLy8gU2VlOiBSRUFETUUgc2VjdGlvbiBvbiBTYWZhcmlcbiAgY29uc3Qgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzID0gKFxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJygtLWNzcy12YXJzOiB5ZXMpJykgJiZcbiAgICB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzKCdjb2xvcicsICcjMDAwMDAwMDAnKVxuICApO1xuXG4gIGlmIChleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIHx8IHdlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cykge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9ICFkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaik7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7IXt4OiBudW1iZXIsIHk6IG51bWJlcn19IHBhZ2VPZmZzZXRcbiAqIEBwYXJhbSB7IUNsaWVudFJlY3R9IGNsaWVudFJlY3RcbiAqIEByZXR1cm4geyF7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXYsIHBhZ2VPZmZzZXQsIGNsaWVudFJlY3QpIHtcbiAgY29uc3Qge3gsIHl9ID0gcGFnZU9mZnNldDtcbiAgY29uc3QgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgY29uc3QgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuXG4gIGxldCBub3JtYWxpemVkWDtcbiAgbGV0IG5vcm1hbGl6ZWRZO1xuICAvLyBEZXRlcm1pbmUgdG91Y2ggcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHJpcHBsZSBjb250YWluZXIuXG4gIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9XG5cbiAgcmV0dXJuIHt4OiBub3JtYWxpemVkWCwgeTogbm9ybWFsaXplZFl9O1xufVxuXG5leHBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBhcHBseVBhc3NpdmUsIGdldE1hdGNoZXNQcm9wZXJ0eSwgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZGVhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBmb2N1czogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBibHVyOiAoc3RyaW5nfHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lckluZm9UeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAoKSA9PiB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKVxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IXtsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSAqL1xuICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdTY2FsZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0V2ZW50fSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICogdW50aWwgdGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdGhlIGZvdW5kYXRpb24gcmVxdWVzdHMgaXQuIFRoaXMgcHJldmVudHMgc2NlbmFyaW9zIHdoZXJlXG4gICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1N1cHBvcnRlZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBY3RpdmF0aW9uU3RhdGVUeXBlfVxuICAgKi9cbiAgZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uRXZlbnQ6IG51bGwsXG4gICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhST09UKTtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcbiAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFJPT1QpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgdGhpcy5yZW1vdmVDc3NWYXJzXygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpIHtcbiAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSkge1xuICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpIHtcbiAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVtb3ZlQ3NzVmFyc18oKSB7XG4gICAgY29uc3Qge3N0cmluZ3N9ID0gTURDUmlwcGxlRm91bmRhdGlvbjtcbiAgICBPYmplY3Qua2V5cyhzdHJpbmdzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoay5pbmRleE9mKCdWQVJfJykgPT09IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShzdHJpbmdzW2tdLCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGVfKGUpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VEaXNhYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCByZWFjdGluZyB0byBmb2xsb3ctb24gZXZlbnRzIGZpcmVkIGJ5IHRvdWNoIGRldmljZSBhZnRlciBhbiBhbHJlYWR5LXByb2Nlc3NlZCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3QgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgPSB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XztcbiAgICBjb25zdCBpc1NhbWVJbnRlcmFjdGlvbiA9IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ICYmIGUgJiYgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQudHlwZSAhPT0gZS50eXBlO1xuICAgIGlmIChpc1NhbWVJbnRlcmFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCA9IHRydWU7XG4gICAgYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljID0gZSA9PT0gbnVsbDtcbiAgICBhY3RpdmF0aW9uU3RhdGUuYWN0aXZhdGlvbkV2ZW50ID0gZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzQWN0aXZhdGVkQnlQb2ludGVyID0gYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljID8gZmFsc2UgOiAoXG4gICAgICBlLnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGUudHlwZSA9PT0gJ3BvaW50ZXJkb3duJ1xuICAgICk7XG5cbiAgICBjb25zdCBoYXNBY3RpdmF0ZWRDaGlsZCA9XG4gICAgICBlICYmIGFjdGl2YXRlZFRhcmdldHMubGVuZ3RoID4gMCAmJiBhY3RpdmF0ZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGhpcy5hZGFwdGVyXy5jb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkpO1xuICAgIGlmIChoYXNBY3RpdmF0ZWRDaGlsZCkge1xuICAgICAgLy8gSW1tZWRpYXRlbHkgcmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSwgd2hpbGUgcHJlc2VydmluZyBsb2dpYyB0aGF0IHByZXZlbnRzIHRvdWNoIGZvbGxvdy1vbiBldmVudHNcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUpIHtcbiAgICAgIGFjdGl2YXRlZFRhcmdldHMucHVzaCgvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGUudGFyZ2V0KSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIHdyYXBwZWQgaW4gYW4gckFGIGNhbGwgYi9jIHdlYiBicm93c2Vyc1xuICAgICAgLy8gcmVwb3J0IGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW5cbiAgICAgIC8vIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAvLyAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzNTk3MVxuICAgICAgLy8gLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkzNzQxXG4gICAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSAoZSAmJiBlLnR5cGUgPT09ICdrZXlkb3duJykgPyB0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpIDogdHJ1ZTtcbiAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlQWN0aXZhdGlvbl8oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc2V0IGFjdGl2YXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgaWYgZWxlbWVudCB3YXMgbm90IG1hZGUgYWN0aXZlLlxuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5hY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGFuaW1hdGVBY3RpdmF0aW9uXygpIHtcbiAgICBjb25zdCB7VkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgVkFSX0ZHX1RSQU5TTEFURV9FTkR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT04sIEZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtERUFDVElWQVRJT05fVElNRU9VVF9NU30gPSBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnM7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGwsIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlXyhlKSB7XG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBzY2VuYXJpb3Mgc3VjaCBhcyB3aGVuIHlvdSBoYXZlIGEga2V5dXAgZXZlbnQgdGhhdCBibHVycyB0aGUgZWxlbWVudC5cbiAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gKi8gKE9iamVjdC5hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSkpO1xuXG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYykge1xuICAgICAgY29uc3QgZXZ0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGV2dE9iamVjdCwgc3RhdGUpKTtcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmhhc0RlYWN0aXZhdGlvblVYUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZGVhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHt3YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlfSkge1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZyYW1lXyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWVfLmhlaWdodCwgdGhpcy5mcmFtZV8ud2lkdGgpO1xuXG4gICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgLy8gdG8gZXh0ZW5kIHRoZSBoaXRib3gsIGFuZCB0aGUgcmlwcGxlIGlzIGV4cGVjdGVkIHRvIG1lZXQgdGhlIGVkZ2VzIG9mIHRoZSBwYWRkZWQgaGl0Ym94ICh3aGljaCBpcyB0eXBpY2FsbHlcbiAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgLy8gYG92ZXJmbG93OiBoaWRkZW5gLlxuICAgIGNvbnN0IGdldEJvdW5kZWRSYWRpdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuZnJhbWVfLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuZnJhbWVfLmhlaWdodCwgMikpO1xuICAgICAgcmV0dXJuIGh5cG90ZW51c2UgKyBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuUEFERElORztcbiAgICB9O1xuXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuXG4gICAgLy8gUmlwcGxlIGlzIHNpemVkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBzdXJmYWNlLCB0aGVuIHNjYWxlcyB1cCB1c2luZyBhIENTUyBzY2FsZSB0cmFuc2Zvcm1cbiAgICB0aGlzLmluaXRpYWxTaXplXyA9IG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRTtcbiAgICB0aGlzLmZnU2NhbGVfID0gdGhpcy5tYXhSYWRpdXNfIC8gdGhpcy5pbml0aWFsU2l6ZV87XG5cbiAgICB0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdXBkYXRlTGF5b3V0Q3NzVmFyc18oKSB7XG4gICAgY29uc3Qge1xuICAgICAgVkFSX0ZHX1NJWkUsIFZBUl9MRUZULCBWQVJfVE9QLCBWQVJfRkdfU0NBTEUsXG4gICAgfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIGAke3RoaXMuaW5pdGlhbFNpemVffXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZV8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLmxlZnR9cHhgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcH1weGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXRVbmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgY29uc3Qge1VOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHVuYm91bmRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4iLCJpbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMnXG5pbXBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBnZXRNYXRjaGVzUHJvcGVydHksIGFwcGx5UGFzc2l2ZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJ1xuXG5leHBvcnQgY2xhc3MgUmlwcGxlQmFzZSBleHRlbmRzIE1EQ1JpcHBsZUZvdW5kYXRpb24ge1xuXG4gIHN0YXRpYyBnZXQgTUFUQ0hFUyAoKSB7XG4gICAgLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4gICAgcmV0dXJuIFJpcHBsZUJhc2UuX21hdGNoZXMgfHxcbiAgICAgICggUmlwcGxlQmFzZS5fbWF0Y2hlcyA9IGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpKVxuICB9XG5cbiAgc3RhdGljIGlzU3VyZmFjZUFjdGl2ZSAocmVmKSB7XG4gICAgcmV0dXJuIHJlZltSaXBwbGVCYXNlLk1BVENIRVNdKCc6YWN0aXZlJylcbiAgfVxuXG4gIGNvbnN0cnVjdG9yICh2bSwgb3B0aW9ucykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KVxuICAgICAgfSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdm0uJGVsW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICAgICAgfSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2bS5kaXNhYmxlZFxuICAgICAgfSxcbiAgICAgIGFkZENsYXNzIChjbGFzc05hbWUpIHtcbiAgICAgICAgdm0uJHNldCh2bS5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3MgKGNsYXNzTmFtZSkge1xuICAgICAgICB2bS4kZGVsZXRlKHZtLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiB2bS4kZWwuY29udGFpbnModGFyZ2V0KSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHZtLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHZtLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHZtLiRzZXQodm0uc3R5bGVzLCB2YXJOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2bS4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH0sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoe3g6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0fSlcbiAgICAgIH0sXG4gICAgfSwgb3B0aW9ucykpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJpcHBsZU1peGluID0ge1xuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9XG59ICAiLCI8dGVtcGxhdGU+XG4gIDxjdXN0b20tZWxlbWVudCA6dGFnPVwidGFnXCIgY2xhc3M9XCJtZGMtcmlwcGxlXCJcbiAgICA6Y2xhc3Nlcz1cImNsYXNzZXNcIiA6c3R5bGVzPVwic3R5bGVzXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tZWxlbWVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0N1c3RvbUVsZW1lbnRNaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlTWl4aW59IGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmlwcGxlJyxcbiAgbWl4aW5zOltDdXN0b21FbGVtZW50TWl4aW4sIFJpcHBsZU1peGluXSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IFN0cmluZ1xuICB9LFxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjUmlwcGxlIGZyb20gJy4vbWRjLXJpcHBsZS52dWUnXG5cbmV4cG9ydCAqIGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlLmpzJ1xuXG5leHBvcnQge1xuICBtZGNSaXBwbGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1JpcHBsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1idXR0b24gcmVmPVwicm9vdFwiXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpocmVmPVwiaHJlZlwiIDpsaW5rPVwibGlua1wiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1JpcHBsZU1peGlufSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24tYmFzZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4sIFJpcHBsZU1peGluXSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IG1kY0J1dHRvbkJhc2UgZnJvbSAnLi9tZGMtYnV0dG9uLWJhc2UudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWJ1dHRvbicsXG4gIGV4dGVuZHM6IG1kY0J1dHRvbkJhc2UsXG4gIHByb3BzOiB7XG4gICAgcmFpc2VkOiBCb29sZWFuLFxuICAgIHVuZWxldmF0ZWQ6IEJvb2xlYW4sXG4gICAgc3Ryb2tlZDogQm9vbGVhbixcbiAgICBkZW5zZTogQm9vbGVhbixcbiAgICBhY2NlbnQ6IEJvb2xlYW4sXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1idXR0b24nOiB0cnVlLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tcmFpc2VkJzogdGhpcy5yYWlzZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJzogdGhpcy51bmVsZXZhdGVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tc3Ryb2tlZCc6IHRoaXMuc3Ryb2tlZCxcbiAgICAgICAgJ21kYy1idXR0b24tLWRlbnNlJzogdGhpcy5kZW5zZSxcbiAgICAgICAgJ21kYy1idXR0b24tLWFjY2VudCc6IHRoaXMuYWNjZW50LFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgIHJhaXNlZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZCk7XG4gICAgfSxcbiAgICB1bmVsZXZhdGVkKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLXVuZWxldmF0ZWQnLCB0aGlzLnVuZWxldmF0ZWQpO1xuICAgIH0sXG4gICAgc3Ryb2tlZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1zdHJva2VkJywgdGhpcy5zdHJva2VkKTtcbiAgICB9LFxuICAgIGRlbnNlKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSk7XG4gICAgfSxcbiAgICBhY2NlbnQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tYWNjZW50JywgdGhpcy5hY2NlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQnV0dG9uIGZyb20gJy4vbWRjLWJ1dHRvbi52dWUnXG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCB7bWRjQnV0dG9uQmFzZSwgbWRjQnV0dG9ufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjQnV0dG9uXG59KVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtY2FyZFwiIDpjbGFzcz1cInsnbWRjLWNhcmQtLXN0cm9rZWQnOiBzdHJva2VkfVwiPlxyXG4gICAgPHNsb3Q+XHJcbiAgICA8L3Nsb3Q+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogXCJtZGMtY2FyZFwiLFxyXG4gIHByb3BzOiB7XHJcbiAgICBzdHJva2VkOiBCb29sZWFuXHJcbiAgfVxyXG59O1xyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcclxuICAgIGNsYXNzPVwibWRjLWNhcmQtcHJpbWFyeS1hY3Rpb24gbWRjLWNhcmRfX3ByaW1hcnktYWN0aW9uXCJcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIiBcclxuICAgIDpsaW5rPVwibGlua1wiIFxyXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUvaW5kZXgnO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLXByaW1hcnktYWN0aW9uJyxcclxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbiwgUmlwcGxlTWl4aW5dLFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLW1lZGlhIG1kYy1jYXJkX19tZWRpYVwiIFxyXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkX19tZWRpYS1jb250ZW50XCIgdi1pZj1cIiRzbG90cy5kZWZhdWx0XCI+XHJcbiAgICAgIDxzbG90PlxyXG4gICAgICA8L3Nsb3Q+XHJcbiAgICA8L2Rpdj5cclxuICA8L3NlY3Rpb24+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogXCJtZGMtY2FyZC1tZWRpYVwiLFxyXG4gIHByb3BzOiB7XHJcbiAgICBzcmM6IFN0cmluZyxcclxuICAgICdzcXVhcmUnOiBCb29sZWFuXHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgc3R5bGVzKCkge1xyXG4gICAgICB2YXIgc3R5bGVzID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke3RoaXMuc3JjfSlgXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gc3R5bGVzO1xyXG4gICAgfSwgXHJcbiAgICBjbGFzc2VzKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zcXVhcmUgPyAnbWRjLWNhcmRfX21lZGlhLS1zcXVhcmUnOiAnbWRjLWNhcmRfX21lZGlhLS0xNi05J1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWhlYWRlciBtZGMtY2FyZF9fcHJpbWFyeVwiPlxuICAgIDxzbG90PlxuICAgICAgPGgxIGNsYXNzPVwibWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2VUaXRsZX1cIlxuICAgICAgICB2LWlmPVwidGl0bGVcIlxuICAgICAgICA+XG4gICAgICAgIHt7IHRpdGxlIH19XG4gICAgICA8L2gxPlxuICAgICAgPGgyIGNsYXNzPVwibWRjLWNhcmRfX3N1YnRpdGxlXCJcbiAgICAgICAgdi1pZj1cInN1YnRpdGxlXCJcbiAgICAgID5cbiAgICAgICB7eyBzdWJ0aXRsZSB9fSBcbiAgICAgIDwvaDI+XG4gICAgPC9zbG90PlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtaGVhZGVyJyxcbiAgcHJvcHM6IHtcbiAgICAndGl0bGUnOiBTdHJpbmcsXG4gICAgJ3N1YnRpdGxlJzogU3RyaW5nLFxuICAgICdsYXJnZS10aXRsZSc6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDEgY2xhc3M9XCJtZGMtY2FyZC10aXRsZSBtZGMtY2FyZF9fdGl0bGVcIlxuICAgICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2V9XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2gxPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLXRpdGxlJyxcbiAgcHJvcHM6IHtcbiAgICAnbGFyZ2UnOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDIgY2xhc3M9XCJtZGMtY2FyZC1zdWJ0aXRsZSBtZGMtY2FyZF9fc3VidGl0bGVcIj5cbiAgICA8c2xvdD5cbiAgICA8L3Nsb3Q+XG4gIDwvaDI+XG48L3RlbXBsYXRlPlxuXG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLXN1YnRpdGxlJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxzZWN0aW9uIGNsYXNzPVwibWRjLWNhcmQtdGV4dCBtZGMtY2FyZF9fc3VwcG9ydGluZy10ZXh0XCI+XG4gICAgPHNsb3Q+XG4gICAgPC9zbG90PlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtdGV4dCdcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxzZWN0aW9uIGNsYXNzPVwibWRjLWNhcmQtYWN0aW9ucyBtZGMtY2FyZF9fYWN0aW9uc1wiIFxyXG4gICAgICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiPlxyXG4gICAgPHNsb3Q+XHJcbiAgICA8L3Nsb3Q+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9ucycsXHJcbiAgcHJvcHM6IHtcclxuICAgIGZ1bGxCbGVlZDogQm9vbGVhblxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGNsYXNzZXMgKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgJ21kYy1jYXJkX19hY3Rpb25zLS1mdWxsLWJsZWVkJzogdGhpcy5mdWxsQmxlZWQsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1idXR0b25zIG1kYy1jYXJkX19hY3Rpb24tYnV0dG9uc1wiPlxyXG4gICAgPHNsb3Q+XHJcbiAgICA8L3Nsb3Q+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogXCJtZGMtY2FyZC1hY3Rpb24tYnV0dG9uc1wiXHJcbn07XHJcbjwvc2NyaXB0PlxyXG4iLCI8c2NyaXB0PlxyXG5pbXBvcnQge21kY0J1dHRvbkJhc2V9IGZyb20gJy4uL2J1dHRvbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbicsXHJcbiAgZXh0ZW5kczogbWRjQnV0dG9uQmFzZSxcclxuICBwcm9wczoge1xyXG4gICAgY29tcGFjdDogQm9vbGVhbixcclxuICAgIGFjY2VudDogQm9vbGVhblxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy1idXR0b24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1idXR0b24tLWNvbXBhY3QnOiB0aGlzLmNvbXBhY3QsXHJcbiAgICAgICAgJ21kYy1idXR0b24tLWFjY2VudCc6IHRoaXMuYWNjZW50LFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgY29tcGFjdCAoKSB7XHJcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1jb21wYWN0JywgdGhpcy5jb21wYWN0IClcclxuICAgIH0sXHJcbiAgICBhY2NlbnQgKCkge1xyXG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tYWNjZW50JywgdGhpcy5hY2NlbnQgKVxyXG4gICAgfSxcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmQtYWN0aW9uLWljb25zIG1kYy1jYXJkX19hY3Rpb24taWNvbnNcIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmQtYWN0aW9uLWljb25zXCJcclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c3BhbiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgXHJcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XHJcbiAgICA8c2xvdD57eyBpY29uIH19PC9zbG90PlxyXG4gIDwvc3Bhbj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWljb24nLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGljb246IFN0cmluZ1xyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1pY29uJzogdHJ1ZSwgXHJcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzohIXRoaXMuaWNvbixcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24tLWljb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUnOiB0cnVlXHJcbiAgICAgIH0sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9LFxyXG4gIHdhdGNoOiB7XHJcbiAgICBpY29uICgpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgISF0aGlzLmljb24pXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcyx7XHJcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxyXG4gICAgfSlcclxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0NhcmQgZnJvbSAnLi9tZGMtY2FyZC52dWUnXHJcbmltcG9ydCBtZGNDYXJkUHJpbWFyeUFjdGlvbiBmcm9tICcuL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRNZWRpYSBmcm9tICcuL21kYy1jYXJkLW1lZGlhLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRIZWFkZXIgZnJvbSAnLi9tZGMtY2FyZC1oZWFkZXIudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRpdGxlIGZyb20gJy4vbWRjLWNhcmQtdGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFN1YnRpdGxlIGZyb20gJy4vbWRjLWNhcmQtc3VidGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRleHQgZnJvbSAnLi9tZGMtY2FyZC10ZXh0LnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25zIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25CdXR0b24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25JY29ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbiBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjQ2FyZCxcclxuICBtZGNDYXJkUHJpbWFyeUFjdGlvbiwgXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvbiBcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XHJcbiAgbWRjQ2FyZCwgXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvblxyXG59KVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgRlxuICovXG5jbGFzcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDQ29tcG9uZW50fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgLy8gcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50IHdpdGggaXRzIHJvb3Qgc2V0IHRvIHRoYXQgZWxlbWVudC4gQWxzbyBub3RlIHRoYXQgaW4gdGhlIGNhc2VzIG9mXG4gICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgcmV0dXJuIG5ldyBNRENDb21wb25lbnQocm9vdCwgbmV3IE1EQ0ZvdW5kYXRpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge0Y9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJvb3RfID0gcm9vdDtcbiAgICB0aGlzLmluaXRpYWxpemUoLi4uYXJncyk7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHQgcGFyYW0gc28gdGhhdFxuICAgIC8vIHRoaXMucm9vdF8gaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZSBmb3VuZGF0aW9uIGNsYXNzLlxuICAgIC8qKiBAcHJvdGVjdGVkIHshRn0gKi9cbiAgICB0aGlzLmZvdW5kYXRpb25fID0gZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgvKiAuLi5hcmdzICovKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgIC8vIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUZ9IGZvdW5kYXRpb25cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgIC8vIGNvbXBvbmVudC5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXREZWZhdWx0Rm91bmRhdGlvbiB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkICcgK1xuICAgICAgJ2ZvdW5kYXRpb24gY2xhc3MnKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IG5lZWQgdG8gcGVyZm9ybSB3b3JrIHRvIHN5bmNocm9uaXplIHdpdGggYSBob3N0IERPTVxuICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgIC8vIHJlYWRzL3dyaXRlcyB0aGF0IHdvdWxkIGNhdXNlIGxheW91dCAvIHBhaW50LCBhcyB0aGlzIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcyAvIGRlcmVnaXN0ZXIgYW55IGxpc3RlbmVycyB0aGV5IGhhdmVcbiAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIGxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogdW5saXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICB1bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSxcbiAgICogd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0fSBldnREYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICAgKi9cbiAgZW1pdChldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICAgIGxldCBldnQ7XG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMucm9vdF8uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NvbXBvbmVudDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1JpcHBsZUZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ1JpcHBsZUZvdW5kYXRpb24+XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZSBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKiBAcGFyYW0gey4uLj99IGFyZ3MgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge3tpc1VuYm91bmRlZDogKGJvb2xlYW58dW5kZWZpbmVkKX09fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGV9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCwge2lzVW5ib3VuZGVkID0gdW5kZWZpbmVkfSA9IHt9KSB7XG4gICAgY29uc3QgcmlwcGxlID0gbmV3IE1EQ1JpcHBsZShyb290KTtcbiAgICAvLyBPbmx5IG92ZXJyaWRlIHVuYm91bmRlZCBiZWhhdmlvciBpZiBvcHRpb24gaXMgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgICBpZiAoaXNVbmJvdW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmlwcGxlLnVuYm91bmRlZCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGlzVW5ib3VuZGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSaXBwbGVDYXBhYmxlU3VyZmFjZX0gaW5zdGFuY2VcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWRhcHRlcihpbnN0YW5jZSkge1xuICAgIGNvbnN0IE1BVENIRVMgPSB1dGlsLmdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IHV0aWwuc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiBpbnN0YW5jZS51bmJvdW5kZWQsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGluc3RhbmNlLnJvb3RfW01BVENIRVNdKCc6YWN0aXZlJyksXG4gICAgICBpc1N1cmZhY2VEaXNhYmxlZDogKCkgPT4gaW5zdGFuY2UuZGlzYWJsZWQsXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gaW5zdGFuY2Uucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICh0YXJnZXQpID0+IGluc3RhbmNlLnJvb3RfLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgaW5zdGFuY2Uucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiBpbnN0YW5jZS5yb290Xy5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YWx1ZSksXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiBpbnN0YW5jZS5yb290Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+ICh7eDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXR9KSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCB1bmJvdW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5ib3VuZGVkXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXQgdW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIHRoaXMudW5ib3VuZGVkXyA9IEJvb2xlYW4odW5ib3VuZGVkKTtcbiAgICB0aGlzLnNldFVuYm91bmRlZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zdXJlIENvbXBpbGVyIHRocm93cyBhbiBhY2Nlc3MgY29udHJvbCBlcnJvciB3aGVuIGRpcmVjdGx5IGFjY2Vzc2luZyBhXG4gICAqIHByb3RlY3RlZCBvciBwcml2YXRlIHByb3BlcnR5IGluc2lkZSBhIGdldHRlci9zZXR0ZXIsIGxpa2UgdW5ib3VuZGVkIGFib3ZlLlxuICAgKiBCeSBhY2Nlc3NpbmcgdGhlIHByb3RlY3RlZCBwcm9wZXJ0eSBpbnNpZGUgYSBtZXRob2QsIHdlIHNvbHZlIHRoYXQgcHJvYmxlbS5cbiAgICogVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFVuYm91bmRlZF8oKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRVbmJvdW5kZWQodGhpcy51bmJvdW5kZWRfKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGUoKTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5sYXlvdXQoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDUmlwcGxlRm91bmRhdGlvbn0gKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENSaXBwbGVGb3VuZGF0aW9uKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKHRoaXMpKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLnVuYm91bmRlZCA9ICdtZGNSaXBwbGVJc1VuYm91bmRlZCcgaW4gdGhpcy5yb290Xy5kYXRhc2V0O1xuICB9XG59XG5cbi8qKlxuICogU2VlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGZvciBtb3JlIGRldGFpbHMgb24gd2hlbiB0byB1c2UgcmlwcGxlcy5cbiAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9tb3Rpb24vY2hvcmVvZ3JhcGh5Lmh0bWwjY2hvcmVvZ3JhcGh5LWNyZWF0aW9uXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIFJpcHBsZUNhcGFibGVTdXJmYWNlIHt9XG5cbi8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS5yb290XztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGJsZWVkcyBvdXQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLnVuYm91bmRlZDtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGlzIGF0dGFjaGVkIHRvIGEgZGlzYWJsZWQgY29tcG9uZW50LlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUuZGlzYWJsZWQ7XG5cbmV4cG9ydCB7TURDUmlwcGxlLCBNRENSaXBwbGVGb3VuZGF0aW9uLCBSaXBwbGVDYXBhYmxlU3VyZmFjZSwgdXRpbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDUmlwcGxlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgY2hlY2tlZDogYm9vbGVhbixcbiAqICAgaW5kZXRlcm1pbmF0ZTogYm9vbGVhbixcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIHZhbHVlOiA/c3RyaW5nXG4gKiB9fVxuICovXG5sZXQgTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlO1xuXG4vKipcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2VsZWN0aW9uQ29udHJvbCB7XG4gIC8qKiBAcmV0dXJuIHs/TURDUmlwcGxlfSAqL1xuICBnZXQgcmlwcGxlKCkge31cbn1cblxuZXhwb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGUsIE1EQ1NlbGVjdGlvbkNvbnRyb2x9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIENoZWNrYm94LiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGVja2JveEFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0TmF0aXZlQ29udHJvbEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVOYXRpdmVDb250cm9sQXR0cihhdHRyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlckNoYW5nZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gKi9cbiAgZ2V0TmF0aXZlQ29udHJvbCgpIHt9XG5cbiAgZm9yY2VMYXlvdXQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0F0dGFjaGVkVG9ET00oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGVja2JveEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgUk9PVCA9ICdtZGMtY2hlY2tib3gnO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFVQR1JBREVEOiAnbWRjLWNoZWNrYm94LS11cGdyYWRlZCcsXG4gIENIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWNoZWNrZWQnLFxuICBJTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1pbmRldGVybWluYXRlJyxcbiAgRElTQUJMRUQ6ICdtZGMtY2hlY2tib3gtLWRpc2FibGVkJyxcbiAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtY2hlY2tlZCcsXG4gIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0NIRUNLRURfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtdW5jaGVja2VkJyxcbiAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC1pbmRldGVybWluYXRlJyxcbiAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkJyxcbiAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLXVuY2hlY2tlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiBgLiR7Uk9PVH1fX25hdGl2ZS1jb250cm9sYCxcbiAgVFJBTlNJVElPTl9TVEFURV9JTklUOiAnaW5pdCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRDogJ2NoZWNrZWQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDogJ3VuY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTogJ2luZGV0ZXJtaW5hdGUnLFxuICBBUklBX0NIRUNLRURfQVRUUjogJ2FyaWEtY2hlY2tlZCcsXG4gIEFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFOiAnbWl4ZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBBTklNX0VORF9MQVRDSF9NUzogMjUwLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENDaGVja2JveEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKiogQGNvbnN0IHshQXJyYXk8c3RyaW5nPn0gKi9cbmNvbnN0IENCX1BST1RPX1BST1BTID0gWydjaGVja2VkJywgJ2luZGV0ZXJtaW5hdGUnXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hlY2tib3hBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDQ2hlY2tib3hGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGVja2JveEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0TmF0aXZlQ29udHJvbEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlTmF0aXZlQ29udHJvbEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gLyogIU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSAqLyB7fSxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB7fSxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBzdHJpbmdzLlRSQU5TSVRJT05fU1RBVEVfSU5JVDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyA9ICcnO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8gPSAwO1xuXG4gICAgdGhpcy5hbmltRW5kSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCgpKTtcblxuICAgIHRoaXMuY2hhbmdlSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUNoYW5nZSgpKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSB0aGlzLmRldGVybWluZUNoZWNrU3RhdGVfKHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcih0aGlzLmNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKHRoaXMuY2hhbmdlSGFuZGxlcl8pO1xuICAgIHRoaXMudW5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNJbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuaW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGluZGV0ZXJtaW5hdGUgKi9cbiAgc2V0SW5kZXRlcm1pbmF0ZShpbmRldGVybWluYXRlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBhbmltYXRpb25lbmQgZXZlbnQgZm9yIHRoZSBjaGVja2JveFxuICAgKi9cbiAgaGFuZGxlQW5pbWF0aW9uRW5kKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG4gICAgdGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIodGhpcy5hbmltRW5kSGFuZGxlcl8pO1xuICAgIH0sIG51bWJlcnMuQU5JTV9FTkRfTEFUQ0hfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmb3IgdGhlIGNoZWNrYm94XG4gICAqL1xuICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBpbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCk7XG4gICAgY29uc3QgY2JQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuYXRpdmVDYik7XG5cbiAgICBDQl9QUk9UT19QUk9QUy5mb3JFYWNoKChjb250cm9sU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNiUHJvdG8sIGNvbnRyb2xTdGF0ZSk7XG4gICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGZvciB0aGlzIGRlc2NyaXB0b3IsIHNpbmNlIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSkgZG9uJ3Qgc3VwcG9ydCBpdHMgcmV0dXJuLlxuICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDk3MzlcbiAgICAgIGlmICh2YWxpZERlc2NyaXB0b3IoZGVzYykpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlQ2JEZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoe1xuICAgICAgICAgIGdldDogZGVzYy5nZXQsXG4gICAgICAgICAgc2V0OiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwobmF0aXZlQ2IsIHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2MuY29uZmlndXJhYmxlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYiwgY29udHJvbFN0YXRlLCBuYXRpdmVDYkRlc2MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5nZXROYXRpdmVDb250cm9sXygpO1xuICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpO1xuXG4gICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaCgoY29udHJvbFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2JQcm90bywgY29udHJvbFN0YXRlKSk7XG4gICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYiwgY29udHJvbFN0YXRlLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUNvbnRyb2woKTtcbiAgICBpZiAoIW5hdGl2ZUNiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV87XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLmRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKTtcbiAgICBpZiAob2xkU3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGFyaWEtY2hlY2tlZCBpcyBzZXQgdG8gbWl4ZWQgaWYgY2hlY2tib3ggaXMgaW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cbiAgICBpZiAodGhpcy5pc0luZGV0ZXJtaW5hdGUoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXROYXRpdmVDb250cm9sQXR0cihcbiAgICAgICAgc3RyaW5ncy5BUklBX0NIRUNLRURfQVRUUiwgc3RyaW5ncy5BUklBX0NIRUNLRURfSU5ERVRFUk1JTkFURV9WQUxVRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIoc3RyaW5ncy5BUklBX0NIRUNLRURfQVRUUik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXNuJ3QgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGFuaW1hdGlvbiBjbGFzcywgaW4gY2FzZSBmb3IgZXhhbXBsZVxuICAgIC8vIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgY2hlY2tib3ggYmVmb3JlIHRoZSBhbmltYXRpb24gd2FzIGZpbmlzaGVkLlxuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9yY2VMYXlvdXQoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSB0aGlzLmdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IG5ld1N0YXRlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHBhcmVudE5vZGUgc28gdGhhdCBhbmltYXRpb25zIGFyZSBvbmx5IHJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIERPTS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0F0dGFjaGVkVG9ET00oKSAmJiB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIodGhpcy5hbmltRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IG5hdGl2ZUNiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFLFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBpZiAobmF0aXZlQ2IuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgcmV0dXJuIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUNiLmNoZWNrZWQgPyBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgOiBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkU3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTklULFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBjb25zdCB7XG4gICAgICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VELFxuICAgICAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQsXG4gICAgICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VELFxuICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gTURDQ2hlY2tib3hGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6XG4gICAgICBpZiAobmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA/IEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQgOiBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFO1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCA/IEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQgOiBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICAvLyBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgP1xuICAgICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCA6IEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVDb250cm9sXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCkgfHwge1xuICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdFByb3BlcnR5RGVzY3JpcHRvcnx1bmRlZmluZWR9IGlucHV0UHJvcERlc2NcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZhbGlkRGVzY3JpcHRvcihpbnB1dFByb3BEZXNjKSB7XG4gIHJldHVybiAhIWlucHV0UHJvcERlc2MgJiYgdHlwZW9mIGlucHV0UHJvcERlc2Muc2V0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGVja2JveEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIEZvcm0gRmllbGQuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gcmlwcGxlIGFjdGl2YXRpb25cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0Zvcm1GaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIGFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxuXG4gIGRlYWN0aXZhdGVJbnB1dFJpcHBsZSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWZvcm0tZmllbGQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBMQUJFTF9TRUxFQ1RPUjogJy5tZGMtZm9ybS1maWVsZCA+IGxhYmVsJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRm9ybUZpZWxkQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0Zvcm1GaWVsZEFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDRm9ybUZpZWxkQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEB0eXBlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVDbGlja18oKSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaGFuZGxlQ2xpY2tfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVJbnB1dFJpcHBsZSgpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVJbnB1dFJpcHBsZSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgbm9QcmVmaXg6IHN0cmluZyxcbiAqICAgd2Via2l0UHJlZml4OiBzdHJpbmcsXG4gKiAgIHN0eWxlUHJvcGVydHk6IHN0cmluZ1xuICogfX1cbiAqL1xubGV0IFZlbmRvclByb3BlcnR5TWFwVHlwZTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBldmVudFR5cGVNYXAgPSB7XG4gICdhbmltYXRpb25zdGFydCc6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25TdGFydCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25lbmQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25pdGVyYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbicsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICd0cmFuc2l0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbmVuZCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ3RyYW5zaXRpb24nLFxuICB9LFxufTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBjc3NQcm9wZXJ0eU1hcCA9IHtcbiAgJ2FuaW1hdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC1hbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNmb3JtJyxcbiAgICB3ZWJraXRQcmVmaXg6ICctd2Via2l0LXRyYW5zZm9ybScsXG4gIH0sXG4gICd0cmFuc2l0aW9uJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlclNoYXBlKHdpbmRvd09iaikge1xuICByZXR1cm4gKHdpbmRvd09ialsnZG9jdW1lbnQnXSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpIHtcbiAgcmV0dXJuIChldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwIHx8IGV2ZW50VHlwZSBpbiBjc3NQcm9wZXJ0eU1hcCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59IG1hcFxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpIHtcbiAgcmV0dXJuIG1hcFtldmVudFR5cGVdLnN0eWxlUHJvcGVydHkgaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGJyb3dzZXIgcHJlZml4IGZvciBDU1MzIGFuaW1hdGlvbiBldmVudHNcbiAqIGFuZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgaWYgKCFoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHx8ICFldmVudEZvdW5kSW5NYXBzKGV2ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9XG5cbiAgY29uc3QgbWFwID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovIChcbiAgICBldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwID8gZXZlbnRUeXBlTWFwIDogY3NzUHJvcGVydHlNYXBcbiAgKTtcbiAgY29uc3QgZWwgPSB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSgnZGl2Jyk7XG4gIGxldCBldmVudE5hbWUgPSAnJztcblxuICBpZiAobWFwID09PSBldmVudFR5cGVNYXApIHtcbiAgICBldmVudE5hbWUgPSBnZXRKYXZhU2NyaXB0RXZlbnROYW1lKGV2ZW50VHlwZSwgbWFwLCBlbCk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnROYW1lID0gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIFB1YmxpYyBmdW5jdGlvbnMgdG8gYWNjZXNzIGdldEFuaW1hdGlvbk5hbWUoKSBmb3IgSmF2YVNjcmlwdCBldmVudHMgb3IgQ1NTXG4vLyBwcm9wZXJ0eSBuYW1lcy5cblxuY29uc3QgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzID0gWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01TVHJhbnNmb3JtJ107XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbmV4cG9ydCB7dHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzLCBnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiA6Y2xhc3M9Zm9ybUZpZWxkQ2xhc3NlcyBjbGFzcz1cIm1kYy1jaGVja2JveC13cmFwcGVyXCI+XG4gICAgPGRpdiByZWY9XCJyb290XCIgY2xhc3M9XCJtZGMtY2hlY2tib3hcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIj5cbiAgICAgIDxpbnB1dCByZWY9XCJjb250cm9sXCIgOmlkPVwiX3VpZFwiIHR5cGU9XCJjaGVja2JveFwiIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19uYXRpdmUtY29udHJvbFwiIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCIvPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1jaGVja2JveF9fYmFja2dyb3VuZFwiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmtcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGNsYXNzPVwiY2hlY2tib3hfX2NoZWNrbWFyay1wYXRoXCJcbiAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGQ9XCJNMS43MywxMi45MSA4LjEsMTkuMjggMjIuNzksNC41OVwiLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtY2hlY2tib3hfX21peGVkbWFya1wiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsIHJlZj1cImxhYmVsXCIgIDpmb3I9XCJfdWlkXCJcbiAgICA+PHNsb3Q+e3tsYWJlbH19PC9zbG90PjwvbGFiZWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uJztcbmltcG9ydCB7IGdldENvcnJlY3RFdmVudE5hbWUgfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uJztcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiB9IGZyb20gJy4uL2Jhc2UnO1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jaGVja2JveCcsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJyxcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjaGVja2VkOiBCb29sZWFuLFxuICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdvbic7XG4gICAgICB9LFxuICAgIH0sXG4gICAgbmFtZTogU3RyaW5nLFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgY2xhc3Nlczoge30sXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNMYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsIHx8IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgfSxcbiAgICBmb3JtRmllbGRDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkJzogdGhpcy5oYXNMYWJlbCxcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiB0aGlzLmhhc0xhYmVsICYmIHRoaXMuYWxpZ25FbmQsXG4gICAgICB9O1xuICAgIH0sXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgY2hlY2tlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodmFsdWUpO1xuICAgIH0sXG4gICAgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSk7XG4gICAgfSxcbiAgICBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZSk7XG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hlY2tib3hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTmF0aXZlQ29udHJvbEF0dHI6IGF0dHIgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICksXG4gICAgICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICksXG4gICAgICByZWdpc3RlckNoYW5nZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckNoYW5nZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sLFxuICAgICAgZm9yY2VMYXlvdXQ6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5vZmZzZXRXaWR0aCxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gQm9vbGVhbih0aGlzLiRlbC5wYXJlbnROb2RlKSxcbiAgICB9KTtcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IFJpcHBsZUJhc2UuaXNTdXJmYWNlQWN0aXZlKHRoaXMuJHJlZnMuY29udHJvbCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5mb3JtRmllbGQgPSBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKCk7XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlYWN0aXZhdGUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgIHRoaXMucmlwcGxlLmluaXQoKTtcbiAgICB0aGlzLmZvcm1GaWVsZC5pbml0KCk7XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodGhpcy5jaGVja2VkKTtcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZCk7XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldEluZGV0ZXJtaW5hdGUodGhpcy5pbmRldGVybWluYXRlKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KCk7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTppbmRldGVybWluYXRlJywgdGhpcy5mb3VuZGF0aW9uLmlzSW5kZXRlcm1pbmF0ZSgpKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKSk7XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGVja2JveCBmcm9tICcuL21kYy1jaGVja2JveC52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0NoZWNrYm94XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGVja2JveFxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBDaGlwIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGlwQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxlYWRpbmcgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc1RvTGVhZGluZ0ljb24oY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGVhZGluZyBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRhcmdldCBoYXMgY2xhc3NOYW1lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHRyYWlsaW5nIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0cmFpbGluZyBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIFwiTURDQ2hpcDppbnRlcmFjdGlvblwiIGV2ZW50IGRlbm90aW5nIHRoZSBjaGlwIGhhcyBiZWVuXG4gICAqIGludGVyYWN0ZWQgd2l0aCAodHlwaWNhbGx5IG9uIGNsaWNrIG9yIGtleWRvd24pLlxuICAgKi9cbiAgbm90aWZ5SW50ZXJhY3Rpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBcIk1EQ0NoaXA6dHJhaWxpbmdJY29uSW50ZXJhY3Rpb25cIiBldmVudCBkZW5vdGluZyB0aGUgdHJhaWxpbmcgaWNvbiBoYXMgYmVlblxuICAgKiBpbnRlcmFjdGVkIHdpdGggKHR5cGljYWxseSBvbiBjbGljayBvciBrZXlkb3duKS5cbiAgICovXG4gIG5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBJTlRFUkFDVElPTl9FVkVOVDogJ01EQ0NoaXA6aW50ZXJhY3Rpb24nLFxuICBMRUFESU5HX0lDT05fU0VMRUNUT1I6ICcubWRjLWNoaXBfX2ljb24tLWxlYWRpbmcnLFxuICBUUkFJTElOR19JQ09OX0lOVEVSQUNUSU9OX0VWRU5UOiAnTURDQ2hpcDp0cmFpbGluZ0ljb25JbnRlcmFjdGlvbicsXG4gIFRSQUlMSU5HX0lDT05fU0VMRUNUT1I6ICcubWRjLWNoaXBfX2ljb24tLXRyYWlsaW5nJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0hFQ0tNQVJLOiAnbWRjLWNoaXBfX2NoZWNrbWFyaycsXG4gIEhJRERFTl9MRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0taGlkZGVuLWxlYWRpbmcnLFxuICBMRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tbGVhZGluZycsXG4gIFNFTEVDVEVEOiAnbWRjLWNoaXAtLXNlbGVjdGVkJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ2hpcEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoaXBBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENDaGlwRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0NoaXBBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0NoaXBBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hpcEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzc1RvTGVhZGluZ0ljb246ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb246ICgpID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SW50ZXJhY3Rpb246ICgpID0+IHt9LFxuICAgICAgbm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb246ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGlwRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uXyhldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nLCAndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nLCAndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50cmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzZWxlY3RlZCBjbGFzcyBvbiB0aGUgY2hpcCBlbGVtZW50LlxuICAgKi9cbiAgdG9nZ2xlU2VsZWN0ZWQoKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb25fKGV2dCkge1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgdHJhbnNpdGlvbiBlbmQgZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogVGhpcyBpcyBhIHByb3h5IGZvciBoYW5kbGluZyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSBsZWFkaW5nIGljb24gb3IgY2hlY2ttYXJrLFxuICAgKiBzaW5jZSB0aGUgdHJhbnNpdGlvbiBlbmQgZXZlbnQgYnViYmxlcy5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgIT09ICdvcGFjaXR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuTEVBRElOR19JQ09OKSAmJlxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzVG9MZWFkaW5nSWNvbihjc3NDbGFzc2VzLkhJRERFTl9MRUFESU5HX0lDT04pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuQ0hFQ0tNQVJLKSAmJlxuICAgICAgICAgICAgICAgIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24oY3NzQ2xhc3Nlcy5ISURERU5fTEVBRElOR19JQ09OKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgdHJhaWxpbmcgaWNvbiBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG9cbiAgICogcHJldmVudCB0aGUgcmlwcGxlIGZyb20gYWN0aXZhdGluZyBvbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0cmFpbGluZyBpY29uLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbl8oZXZ0KSB7XG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIHRhYmluZGV4PVwiMFwiID5cbiAgPGkgcmVmPVwibGVhZGluZ0ljb25cIiBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS1sZWFkaW5nXCIgXG4gICAgOmNsYXNzPVwibGVhZGluZ0NsYXNzZXNcIiB2LWlmPVwiaGF2ZWxlYWRpbmdJY29uXCJcbiAgPnt7bGVhZGluZ0ljb259fTwvaT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1jaGlwX19jaGVja21hcmtcIiB2LWlmPVwiaXNGaWx0ZXJcIj5cbiAgICA8c3ZnIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFyay1zdmdcIiB2aWV3Qm94PVwiLTIgLTMgMzAgMzBcIj5cbiAgICAgIDxwYXRoIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFyay1wYXRoXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJibGFja1wiXG4gICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgPC9zdmc+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWRjLWNoaXBfX3RleHRcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuICA8aSByZWY9XCJ0cmFpbGluZ0ljb25cIiBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS10cmFpbGluZ1wiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIiBcbiAgICA6Y2xhc3M9XCJ0cmFpbGluZ0NsYXNzZXNcIiB2LWlmPVwiaGF2ZXRyYWlsaW5nSWNvblwiXG4gID57e3RyYWlsaW5nSWNvbn19PC9pPlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0NoaXBGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHsgQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW4sIGVtaXRDdXN0b21FdmVudCB9IGZyb20gJy4uL2Jhc2UnO1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jaGlwJyxcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGxlYWRpbmdJY29uOiBbU3RyaW5nXSxcbiAgICB0cmFpbGluZ0ljb246IFtTdHJpbmddLFxuICAgIGxlYWRpbmdJY29uQ2xhc3NlczogW09iamVjdF0sXG4gICAgdHJhaWxpbmdJY29uQ2xhc3NlczogW09iamVjdF0sXG4gIH0sXG4gIGluamVjdDogWydtZGNDaGlwU2V0J10sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1jaGlwJzogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB0b2dnbGVTZWxlY3RlZCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi50b2dnbGVTZWxlY3RlZCgpO1xuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0NoaXBGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzc1RvTGVhZGluZ0ljb246IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhdmVsZWFkaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb246IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhdmVsZWFkaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKSxcbiAgICAgIG5vdGlmeUludGVyYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdjbGljaycgfSk7XG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNUSU9OX0VWRU5ULFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaXA6IHRoaXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICd0cmFpbGluZ0ljb25DbGljaycgfSk7XG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpcDogdGhpcyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICByZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMudHJhaWxpbmdJY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy50cmFpbGluZ0ljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMudHJhaWxpbmdJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKTtcbiAgICB0aGlzLnJpcHBsZS5pbml0KCk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNGaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNDaGlwU2V0ICYmIHRoaXMubWRjQ2hpcFNldC5maWx0ZXI7XG4gICAgfSxcbiAgICBoYXZlbGVhZGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmxlYWRpbmdJY29uIHx8IHRoaXMubGVhZGluZ0ljb25DbGFzc2VzO1xuICAgIH0sXG4gICAgaGF2ZXRyYWlsaW5nSWNvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMudHJhaWxpbmdJY29uQ2xhc3NlcztcbiAgICB9LFxuICAgIGxlYWRpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmxlYWRpbmdJY29uLFxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmxlYWRpbmdJY29uQ2xhc3NlcyxcbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFpbGluZ0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHtcbiAgICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMudHJhaWxpbmdJY29uLFxuICAgICAgICB9LFxuICAgICAgICB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXMsXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIENoaXAgU2V0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgU2V0IGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGlwU2V0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwU2V0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQge01EQ1JpcHBsZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG5cbmltcG9ydCBNRENDaGlwQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ0NoaXBGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDQ29tcG9uZW50PCFNRENDaGlwRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcCBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0VsZW1lbnR9ICovXG4gICAgdGhpcy5sZWFkaW5nSWNvbl8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3Ioc3RyaW5ncy5MRUFESU5HX0lDT05fU0VMRUNUT1IpO1xuICAgIC8qKiBAcHJpdmF0ZSB7IU1EQ1JpcHBsZX0gKi9cbiAgICB0aGlzLnJpcHBsZV8gPSBuZXcgTURDUmlwcGxlKHRoaXMucm9vdF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NoaXB9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDQ2hpcChyb290KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGVfLmRlc3Ryb3koKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgY2hpcC5cbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8udG9nZ2xlU2VsZWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDQ2hpcEZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ0NoaXBGb3VuZGF0aW9uKC8qKiBAdHlwZSB7IU1EQ0NoaXBBZGFwdGVyfSAqLyAoT2JqZWN0LmFzc2lnbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFkZENsYXNzVG9MZWFkaW5nSWNvbjogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5sZWFkaW5nSWNvbl8pIHtcbiAgICAgICAgICB0aGlzLmxlYWRpbmdJY29uXy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbjogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5sZWFkaW5nSWNvbl8pIHtcbiAgICAgICAgICB0aGlzLmxlYWRpbmdJY29uXy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBjb25zdCB0cmFpbGluZ0ljb25FbCA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihzdHJpbmdzLlRSQUlMSU5HX0lDT05fU0VMRUNUT1IpO1xuICAgICAgICBpZiAodHJhaWxpbmdJY29uRWwpIHtcbiAgICAgICAgICB0cmFpbGluZ0ljb25FbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdJY29uRWwgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3Ioc3RyaW5ncy5UUkFJTElOR19JQ09OX1NFTEVDVE9SKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nSWNvbkVsKSB7XG4gICAgICAgICAgdHJhaWxpbmdJY29uRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUludGVyYWN0aW9uOiAoKSA9PiB0aGlzLmVtaXQoc3RyaW5ncy5JTlRFUkFDVElPTl9FVkVOVCwge2NoaXA6IHRoaXN9LCB0cnVlIC8qIHNob3VsZEJ1YmJsZSAqLyksXG4gICAgICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbjogKCkgPT4gdGhpcy5lbWl0KFxuICAgICAgICBzdHJpbmdzLlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQsIHtjaGlwOiB0aGlzfSwgdHJ1ZSAvKiBzaG91bGRCdWJibGUgKi8pLFxuICAgIH0pKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JpcHBsZX0gKi9cbiAgZ2V0IHJpcHBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yaXBwbGVfO1xuICB9XG59XG5cbmV4cG9ydCB7TURDQ2hpcCwgTURDQ2hpcEZvdW5kYXRpb259O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hJUF9TRUxFQ1RPUjogJy5tZGMtY2hpcCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENIT0lDRTogJ21kYy1jaGlwLXNldC0tY2hvaWNlJyxcbiAgRklMVEVSOiAnbWRjLWNoaXAtc2V0LS1maWx0ZXInLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDaGlwU2V0QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge01EQ0NoaXAsIE1EQ0NoaXBGb3VuZGF0aW9ufSBmcm9tICcuLi9jaGlwL2luZGV4JztcbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGlwU2V0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcFNldEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwU2V0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwU2V0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBTZXRBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcFNldEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBTZXRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgY2hpcHMgaW4gdGhlIHNldC4gT25seSB1c2VkIGZvciBjaG9pY2UgY2hpcCBzZXQgb3IgZmlsdGVyIGNoaXAgc2V0LlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IU1EQ0NoaXA+fVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0ZWRDaGlwc18gPSBbXTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuY2hpcEludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUNoaXBJbnRlcmFjdGlvbl8oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlQsIHRoaXMuY2hpcEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNUSU9OX0VWRU5ULCB0aGlzLmNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY2hpcCBpbnRlcmFjdGlvbiBldmVudFxuICAgKiBAcGFyYW0geyFPYmplY3R9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2hpcEludGVyYWN0aW9uXyhldnQpIHtcbiAgICBjb25zdCB7Y2hpcH0gPSBldnQuZGV0YWlsO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQ0hPSUNFKSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDaGlwc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwc19bMF0gPSBjaGlwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkQ2hpcHNfWzBdICE9PSBjaGlwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwc19bMF0udG9nZ2xlU2VsZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoaXBzX1swXSA9IGNoaXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfID0gW107XG4gICAgICB9XG4gICAgICBjaGlwLnRvZ2dsZVNlbGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuRklMVEVSKSkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNlbGVjdGVkQ2hpcHNfLmluZGV4T2YoY2hpcCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLnB1c2goY2hpcCk7XG4gICAgICB9XG4gICAgICBjaGlwLnRvZ2dsZVNlbGVjdGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBTZXRGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PiAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0NoaXBTZXRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNoaXAtc2V0JyxcbiAgcHJvcHM6IHtcbiAgICBjaG9pY2U6IFtCb29sZWFuXSxcbiAgICBmaWx0ZXI6IFtCb29sZWFuXSxcbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNDaGlwU2V0OiB0aGlzIH07XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1jaGlwLXNldCc6IHRydWUsXG4gICAgICAgICdtZGMtY2hpcC1zZXQtLWNob2ljZSc6IHRoaXMuY2hvaWNlLFxuICAgICAgICAnbWRjLWNoaXAtc2V0LS1maWx0ZXInOiB0aGlzLmZpbHRlcixcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgbWV0aG9kczoge30sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0NoaXBTZXRGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGlwIGZyb20gJy4vbWRjLWNoaXAudnVlJ1xuaW1wb3J0IG1kY0NoaXBTZXQgZnJvbSAnLi9tZGMtY2hpcC1zZXQudnVlJ1xuXG5leHBvcnQgeyBcbiAgbWRjQ2hpcCwgXG4gIG1kY0NoaXBTZXQgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGlwLCBcbiAgbWRjQ2hpcFNldCBcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQge01EQ0ZvdW5kYXRpb24sIE1EQ0NvbXBvbmVudH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kaWFsb2cnLFxuICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kaWFsb2ctLWFuaW1hdGluZycsXG4gIEJBQ0tEUk9QOiAnbWRjLWRpYWxvZ19fYmFja2Ryb3AnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxuICBBQ0NFUFRfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdCcsXG4gIENBTkNFTF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBPUEVOX0RJQUxPR19TRUxFQ1RPUjogJy5tZGMtZGlhbG9nLS1vcGVuJyxcbiAgRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc3VyZmFjZScsXG4gIEFDQ0VQVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQUNDRVBUX0VWRU5UOiAnTURDRGlhbG9nOmFjY2VwdCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ0RpYWxvZzpjYW5jZWwnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgbGF5b3V0Rm9vdGVyUmlwcGxlczogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuQkFDS0RST1ApKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEaWFsb2dDbGlja18oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCBkaWFsb2cgaXMgY2xlYW5lZCB1cCB3aGVuIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRGlhbG9nKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmxheW91dEZvb3RlclJpcHBsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICBjYW5kaWRhdGVJbmRleCA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSB8fCBjYW5kaWRhdGUudGFiSW5kZXg7XG5cbiAgICBpZiAoXG4gICAgICBjYW5kaWRhdGVJbmRleCA8IDBcbiAgICAgIHx8IChjYW5kaWRhdGUudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBjYW5kaWRhdGUudHlwZSA9PT0gJ2hpZGRlbicpXG4gICAgICB8fCBjYW5kaWRhdGUuZGlzYWJsZWRcbiAgICAgIHx8IGlzVW5hdmFpbGFibGUoY2FuZGlkYXRlLCBlbGVtZW50RG9jdW1lbnQpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FuZGlkYXRlSW5kZXggPT09IDApIHtcbiAgICAgIGJhc2ljVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVJbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmluZGV4IC0gYi5pbmRleCA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xuICAgIH0pXG4gICAgLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5ub2RlXG4gICAgfSk7XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGFiYmFibGVOb2RlcywgYmFzaWNUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJc1VuYXZhaWxhYmxlKGVsZW1lbnREb2N1bWVudCkge1xuICAvLyBOb2RlIGNhY2hlIG11c3QgYmUgcmVmcmVzaGVkIG9uIGV2ZXJ5IGNoZWNrLCBpbiBjYXNlXG4gIC8vIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gIHZhciBpc09mZkNhY2hlID0gW107XG5cbiAgLy8gXCJvZmZcIiBtZWFucyBgZGlzcGxheTogbm9uZTtgLCBhcyBvcHBvc2VkIHRvIFwiaGlkZGVuXCIsXG4gIC8vIHdoaWNoIG1lYW5zIGB2aXNpYmlsaXR5OiBoaWRkZW47YC4gZ2V0Q29tcHV0ZWRTdHlsZVxuICAvLyBhY2N1cmF0ZWx5IHJlZmxlY3RzIHZpc2libGl0eSBpbiBjb250ZXh0IGJ1dCBub3RcbiAgLy8gXCJvZmZcIiBzdGF0ZSwgc28gd2UgbmVlZCB0byByZWN1cnNpdmVseSBjaGVjayBwYXJlbnRzLlxuXG4gIGZ1bmN0aW9uIGlzT2ZmKG5vZGUsIG5vZGVDb21wdXRlZFN0eWxlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEZpbmQgdGhlIGNhY2hlZCBub2RlIChBcnJheS5wcm90b3R5cGUuZmluZCBub3QgYXZhaWxhYmxlIGluIElFOSlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaXNPZmZDYWNoZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzT2ZmQ2FjaGVbaV1bMF0gPT09IG5vZGUpIHJldHVybiBpc09mZkNhY2hlW2ldWzFdO1xuICAgIH1cblxuICAgIG5vZGVDb21wdXRlZFN0eWxlID0gbm9kZUNvbXB1dGVkU3R5bGUgfHwgZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAobm9kZUNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZXN1bHQgPSBpc09mZihub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIGlzT2ZmQ2FjaGUucHVzaChbbm9kZSwgcmVzdWx0XSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGlzVW5hdmFpbGFibGUobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbGVtZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnREb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKGlzT2ZmKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xuICB9XG59XG4iLCJ2YXIgdGFiYmFibGUgPSByZXF1aXJlKCd0YWJiYWJsZScpO1xuXG52YXIgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gW107XG4gIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IG51bGw7XG4gIHZhciBsYXN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IG51bGw7XG4gIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICB2YXIgdGFiRXZlbnQgPSBudWxsO1xuXG4gIHZhciBjb250YWluZXIgPSAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICAgIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gdXNlck9wdGlvbnMgfHwge307XG4gIGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGVcbiAgICA6IHRydWU7XG4gIGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMuZXNjYXBlRGVhY3RpdmF0ZXNcbiAgICA6IHRydWU7XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2UsXG4gIH07XG5cbiAgcmV0dXJuIHRyYXA7XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIG9uQWN0aXZhdGU6IChhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlLFxuICAgIH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUpIHtcbiAgICAgIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIHZhciBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIHJldHVybkZvY3VzOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1c1xuICAgICAgICA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSxcbiAgICAgIG9uRGVhY3RpdmF0ZTogKGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgfTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMobm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKHBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKCFwYXVzZWQgfHwgIWFjdGl2ZSkgcmV0dXJuO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgaWYgKGxpc3RlbmluZ0ZvY3VzVHJhcCkge1xuICAgICAgbGlzdGVuaW5nRm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgfVxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IHRyYXA7XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgdHJ5Rm9jdXMoZmlyc3RGb2N1c05vZGUoKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUgfHwgbGlzdGVuaW5nRm9jdXNUcmFwICE9PSB0cmFwKSByZXR1cm47XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGNoZWNrRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTtcbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3RGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5cXCd0IGhhdmUgYSBmb2N1cy10cmFwIHdpdGhvdXQgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnRcbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcyAmJiAhY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgZGVhY3RpdmF0ZSh7IHJldHVybkZvY3VzOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXMoZSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgLy8gQ2hlY2tpbmcgZm9yIGEgYmx1ciBtZXRob2QgaGVyZSByZXNvbHZlcyBhIEZpcmVmb3ggaXNzdWUgKCMxNSlcbiAgICBpZiAodHlwZW9mIGUudGFyZ2V0LmJsdXIgPT09ICdmdW5jdGlvbicpIGUudGFyZ2V0LmJsdXIoKTtcblxuICAgIGlmICh0YWJFdmVudCkge1xuICAgICAgcmVhZGp1c3RGb2N1cyh0YWJFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBoYW5kbGVUYWIoZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gZmFsc2UgJiYgaXNFc2NhcGVFdmVudChlKSkge1xuICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgaWYgKGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBOdW1iZXIoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA8IDApIHtcbiAgICAgIHJldHVybiB0YWJFdmVudCA9IGU7XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjdXJyZW50Rm9jdXNJbmRleCA9IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihlLnRhcmdldCk7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZSB8fCB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCAtIDFdKTtcbiAgICB9XG5cbiAgICBpZiAoZS50YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGUpIHJldHVybiB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyh0YWJiYWJsZU5vZGVzW2N1cnJlbnRGb2N1c0luZGV4ICsgMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyKTtcbiAgICBmaXJzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbMF07XG4gICAgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRqdXN0Rm9jdXMoZSkge1xuICAgIGlmIChlLnNoaWZ0S2V5KSByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFc2NhcGVFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXkgPT09ICdFc2MnIHx8IGUua2V5Q29kZSA9PT0gMjc7XG59XG5cbmZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSByZXR1cm47XG4gIGlmIChub2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAgcmV0dXJuO1xuXG4gIG5vZGUuZm9jdXMoKTtcbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgbm9kZS5zZWxlY3QoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzVHJhcDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBjcmVhdGVGb2N1c1RyYXAgZnJvbSAnZm9jdXMtdHJhcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShzdXJmYWNlRWwsIGFjY2VwdEJ1dHRvbkVsLCBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwKSB7XG4gIHJldHVybiBmb2N1c1RyYXBGYWN0b3J5KHN1cmZhY2VFbCwge1xuICAgIGluaXRpYWxGb2N1czogYWNjZXB0QnV0dG9uRWwsXG4gICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IHRydWUsXG4gIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtZGlhbG9nXCIgcmVmPVwicm9vdFwiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIHJvbGU9XCJhbGVydGRpYWxvZ1wiXG4gICAgOmFyaWEtbGFiZWxsZWRieT1cIidsYWJlbCcgKyBfdWlkXCJcbiAgICA6YXJpYS1kZXNjcmliZWRieT1cIidkZXNjJyArIF91aWRcIlxuICA+XG4gICAgPGRpdiAgcmVmPVwic3VyZmFjZVwiIGNsYXNzPVwibWRjLWRpYWxvZ19fc3VyZmFjZVwiIDpjbGFzcz1cInN1cmZhY2VDbGFzc2VzXCI+XG4gICAgICA8aGVhZGVyIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyXCI+XG4gICAgICAgIDxoMiA6aWQ9XCInbGFiZWwnICsgX3VpZFwiIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyX190aXRsZVwiPlxuICAgICAgICAgIHt7IHRpdGxlIH19XG4gICAgICAgIDwvaDI+XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIDxzZWN0aW9uIDppZD1cIidkZXNjJyArIF91aWRcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2JvZHlcIiA6Y2xhc3M9XCJib2R5Q2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgICAgPGZvb3RlciBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3RlclwiPlxuICAgICAgICA8bWRjQnV0dG9uIHJlZj1cImNhbmNlbFwiIHYtaWY9XCJjYW5jZWxcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24gbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWNhbmNlbFwiXG4gICAgICAgICAgOmNsYXNzPVwieydtZGMtZGlhbG9nX19hY3Rpb24nOmFjY2VudH1cIlxuICAgICAgICAgIEBjbGljaz1cIm9uQ2FuY2VsXCJcbiAgICAgICAgICA+e3sgY2FuY2VsIH19PC9tZGNCdXR0b24+XG4gICAgICAgIDxtZGNCdXR0b24gIHJlZj1cImFjY2VwdFwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbiBtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0XCJcbiAgICAgICAgICA6Y2xhc3M9XCJ7J21kYy1kaWFsb2dfX2FjdGlvbic6YWNjZW50fVwiXG4gICAgICAgICAgOmRpc2FibGVkPVwiYWNjZXB0RGlzYWJsZWRcIlxuICAgICAgICAgIEBjbGljaz1cIm9uQWNjZXB0XCJcbiAgICAgICAgPnt7IGFjY2VwdCB9fTwvbWRjQnV0dG9uPlxuICAgICAgPC9mb290ZXI+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1kaWFsb2dfX2JhY2tkcm9wXCI+PC9kaXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RpYWxvZy9mb3VuZGF0aW9uJztcbmltcG9ydCB7IGNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlIH0gZnJvbSAnQG1hdGVyaWFsL2RpYWxvZy91dGlsJztcbmltcG9ydCB7IG1kY0J1dHRvbiB9IGZyb20gJy4uL2J1dHRvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kaWFsb2cnLFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBhY2NlcHQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnT2snIH0sXG4gICAgYWNjZXB0RGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgY2FuY2VsOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ0NhbmNlbCcgfSxcbiAgICBhY2NlbnQ6IEJvb2xlYW4sXG4gICAgc2Nyb2xsYWJsZTogQm9vbGVhbixcbiAgfSxcbiAgY29tcG9uZW50czoge1xuICAgIG1kY0J1dHRvbjogbWRjQnV0dG9uLFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGhlbWUtLWRhcmsnOiB0aGlzLmRhcmssXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIHN1cmZhY2VDbGFzc2VzOiB7fSxcbiAgICAgIGJvZHlDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZGlhbG9nX19ib2R5LS1zY3JvbGxhYmxlJzogdGhpcy5zY3JvbGxhYmxlLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICB0aGlzLiRyZWZzLnN1cmZhY2UsXG4gICAgICB0aGlzLiRyZWZzLmFjY2VwdCxcbiAgICApO1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0RpYWxvZ0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgYWRkQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLypldnQsIGhhbmRsZXIqLykgPT4ge1xuICAgICAgICAvLyBWTUFfSEFDSzogaGFuZGxlIGJ1dHRvbiBjbGlja3Mgb3Vyc2VsdmVzXG4gICAgICAgIC8vIHRoaXMuJHJlZnMuc3VyZmFjZS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qZXZ0LCBoYW5kbGVyKi8pID0+IHtcbiAgICAgICAgLy8gVk1BX0hBQ0s6IGhhbmRsZSBidXR0b24gY2xpY2tzIG91cnNlbHZlc1xuICAgICAgICAvLyB0aGlzLiRyZWZzLnN1cmZhY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgbm90aWZ5QWNjZXB0OiAoKSA9PiB0aGlzLiRlbWl0KCdhY2NlcHQnKSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4gdGhpcy4kZW1pdCgnY2FuY2VsJyksXG4gICAgICB0cmFwRm9jdXNPblN1cmZhY2U6ICgpID0+IHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCksXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4gdGhpcy5mb2N1c1RyYXAuZGVhY3RpdmF0ZSgpLFxuICAgICAgaXNEaWFsb2c6IGVsID0+IHRoaXMuJHJlZnMuc3VyZmFjZSA9PT0gZWwsXG4gICAgICBsYXlvdXRGb290ZXJSaXBwbGVzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuYWNjZXB0LnJpcHBsZS5sYXlvdXQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWwgJiYgdGhpcy4kcmVmcy5jYW5jZWwucmlwcGxlLmxheW91dCgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNhbmNlbCh0cnVlKTtcbiAgICB9LFxuICAgIG9uQWNjZXB0KCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGUnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZScsIHtcbiAgICAgICAgICBhY2NlcHQ6IChub3RpZnkgPSB0cnVlKSA9PiB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KG5vdGlmeSksXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjY2VwdCh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3coKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpO1xuICAgIH0sXG4gICAgY2xvc2UoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0RpYWxvZyBmcm9tICcuL21kYy1kaWFsb2cudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEaWFsb2dcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0RpYWxvZ1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPG5hdiBjbGFzcz1cIm1kYy1wZXJtYW5lbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcm1hbmVudCBtZGMtdHlwb2dyYXBoeVwiPlxuICAgIDxuYXYgY2xhc3M9XCJtZGMtZHJhd2VyX19jb250ZW50XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIiBcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1wZXJtYW5lbnQtZHJhd2VyJyxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfRUxFTUVOVFMgPVxuICAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksICcgK1xuICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBbdGFiaW5kZXhdLCBbY29udGVudGVkaXRhYmxlXSc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6ICgvKiB2YWx1ZTogbnVtYmVyIHwgbnVsbCAqLykgPT4ge30sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4gLyogTm9kZUxpc3QgKi8ge30sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIHJvb3RDc3NDbGFzcywgYW5pbWF0aW5nQ3NzQ2xhc3MsIG9wZW5Dc3NDbGFzcykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLnJvb3RDc3NDbGFzc18gPSByb290Q3NzQ2xhc3M7XG4gICAgdGhpcy5hbmltYXRpbmdDc3NDbGFzc18gPSBhbmltYXRpbmdDc3NDbGFzcztcbiAgICB0aGlzLm9wZW5Dc3NDbGFzc18gPSBvcGVuQ3NzQ2xhc3M7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcblxuICAgIHRoaXMuaW5lcnRfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hTdGFydF8oZXZ0KTtcbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaE1vdmVfKGV2dCk7XG4gICAgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaEVuZF8oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBST09UID0gdGhpcy5yb290Q3NzQ2xhc3NfO1xuICAgIGNvbnN0IE9QRU4gPSB0aGlzLm9wZW5Dc3NDbGFzc187XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoUk9PVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtST09UfSBjbGFzcyByZXF1aXJlZCBpbiByb290IGVsZW1lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc05lY2Vzc2FyeURvbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIERPTSBub2RlcyBtaXNzaW5nIGluICR7Uk9PVH0gY29tcG9uZW50LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE9QRU4pKSB7XG4gICAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRldGFiaW5hdGVfKCk7XG4gICAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNobW92ZScsIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoZW5kJywgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2htb3ZlJywgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyk7XG4gICAgLy8gRGVyZWdpc3RlciB0aGUgZG9jdW1lbnQga2V5ZG93biBoYW5kbGVyIGp1c3QgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCB3aGlsZSB0aGUgbWVudSBpcyBvcGVuLlxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pO1xuICAgIHRoaXMucmV0YWJpbmF0ZV8oKTtcbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBjYWxsc1xuICAgIGlmICghdGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeU9wZW4oKTtcbiAgICB9XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMub3BlbkNzc0NsYXNzXyk7XG4gICAgdGhpcy5kZXRhYmluYXRlXygpO1xuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIGNhbGxzXG4gICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgLyoqXG4gICAqICBSZW5kZXIgYWxsIGNoaWxkcmVuIG9mIHRoZSBkcmF3ZXIgaW5lcnQgd2hlbiBpdCdzIGNsb3NlZC5cbiAgICovXG4gIGRldGFiaW5hdGVfKCkge1xuICAgIGlmICh0aGlzLmluZXJ0Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNhdmVFbGVtZW50VGFiU3RhdGUoZWxlbWVudHNbaV0pO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm1ha2VFbGVtZW50VW50YWJiYWJsZShlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmVydF8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqICBNYWtlIGFsbCBjaGlsZHJlbiBvZiB0aGUgZHJhd2VyIHRhYmJhYmxlIGFnYWluIHdoZW4gaXQncyBvcGVuLlxuICAgKi9cbiAgcmV0YWJpbmF0ZV8oKSB7XG4gICAgaWYgKCF0aGlzLmluZXJ0Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5lcnRfID0gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVUb3VjaFN0YXJ0XyhldnQpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlyZWN0aW9uXyA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKSA/IC0xIDogMTtcbiAgICB0aGlzLmRyYXdlcldpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VyV2lkdGgoKTtcbiAgICB0aGlzLnN0YXJ0WF8gPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLnBhZ2VYIDogZXZ0LnBhZ2VYO1xuICAgIHRoaXMuY3VycmVudFhfID0gdGhpcy5zdGFydFhfO1xuXG4gICAgdGhpcy51cGRhdGVSYWZfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlRHJhd2VyXy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoTW92ZV8oZXZ0KSB7XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRYXyA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0ucGFnZVggOiBldnQucGFnZVg7XG4gIH1cblxuICBoYW5kbGVUb3VjaEVuZF8oZXZ0KSB7XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXBhcmVGb3JUb3VjaEVuZF8oKTtcblxuICAgIC8vIERpZCB0aGUgdXNlciBjbG9zZSB0aGUgZHJhd2VyIGJ5IG1vcmUgdGhhbiA1MCU/XG4gICAgaWYgKE1hdGguYWJzKHRoaXMubmV3UG9zaXRpb25fIC8gdGhpcy5kcmF3ZXJXaWR0aF8pID49IDAuNSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmlnZ2VyaW5nIGFuIG9wZW4gaGVyZSBtZWFucyB3ZSdsbCBnZXQgYSBuaWNlIGFuaW1hdGlvbiBiYWNrIHRvIHRoZSBmdWxseSBvcGVuIHN0YXRlLlxuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZUZvclRvdWNoRW5kXygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZVJhZl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNsYXRlWChudWxsKTtcbiAgfVxuXG4gIHVwZGF0ZURyYXdlcl8oKSB7XG4gICAgdGhpcy51cGRhdGVSYWZfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlRHJhd2VyXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zbGF0ZVgodGhpcy5uZXdQb3NpdGlvbl8pO1xuICB9XG5cbiAgZ2V0IG5ld1Bvc2l0aW9uXygpIHtcbiAgICBsZXQgbmV3UG9zID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmRpcmVjdGlvbl8gPT09IDEpIHtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKDAsIHRoaXMuY3VycmVudFhfIC0gdGhpcy5zdGFydFhfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50WF8gLSB0aGlzLnN0YXJ0WF8pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlXG4gICAgLy8gaWYgdGhlIGV2ZW50IHRhcmdldCBpcyB0aGUgcm9vdCBldmVudCB0YXJnZXQgY3VycmVudGx5IHRyYW5zaXRpb25pbmcuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhldnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4vY29uc3RhbnRzJztcbmV4cG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZHJhd2VyLS1wZXJzaXN0ZW50JyxcbiAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxuICBBTklNQVRJTkc6ICdtZGMtZHJhd2VyLS1hbmltYXRpbmcnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIERSQVdFUl9TRUxFQ1RPUjogJy5tZGMtZHJhd2VyLS1wZXJzaXN0ZW50IC5tZGMtZHJhd2VyX19kcmF3ZXInLFxuICBGT0NVU0FCTEVfRUxFTUVOVFMsXG4gIE9QRU5fRVZFTlQ6ICdNRENQZXJzaXN0ZW50RHJhd2VyOm9wZW4nLFxuICBDTE9TRV9FVkVOVDogJ01EQ1BlcnNpc3RlbnREcmF3ZXI6Y2xvc2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwge1xuICAgICAgaXNEcmF3ZXI6ICgpID0+IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlciksXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QsXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNEcmF3ZXIoZWwpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBUQUJfREFUQSA9ICdkYXRhLW1kYy10YWJpbmRleCc7XG5jb25zdCBUQUJfREFUQV9IQU5ETEVEID0gJ2RhdGEtbWRjLXRhYmluZGV4LWhhbmRsZWQnO1xuXG5sZXQgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbmxldCBzdXBwb3J0c1Bhc3NpdmVfO1xuXG4vLyBSZW1hcCB0b3VjaCBldmVudHMgdG8gcG9pbnRlciBldmVudHMsIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0b3VjaCBldmVudHMuXG5leHBvcnQgZnVuY3Rpb24gcmVtYXBFdmVudChldmVudE5hbWUsIGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoISgnb250b3VjaHN0YXJ0JyBpbiBnbG9iYWxPYmouZG9jdW1lbnQpKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgIHJldHVybiAncG9pbnRlcmRvd24nO1xuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJtb3ZlJztcbiAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJ1cCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxuLy8gQ2hvb3NlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2Ugb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGVsID0gZ2xvYmFsT2JqLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRyYW5zZm9ybVByb3BlcnR5TmFtZSA9ICgndHJhbnNmb3JtJyBpbiBlbC5zdHlsZSA/ICd0cmFuc2Zvcm0nIDogJy13ZWJraXQtdHJhbnNmb3JtJyk7XG4gICAgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9IHRyYW5zZm9ybVByb3BlcnR5TmFtZTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIENTUyBwcm9wZXJ0aWVzLlxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcyhnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCdDU1MnIGluIGdsb2JhbE9iaikge1xuICAgIHJldHVybiBnbG9iYWxPYmouQ1NTLnN1cHBvcnRzKCcoLS1jb2xvcjogcmVkKScpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLy8gU2F2ZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LlxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVFbGVtZW50VGFiU3RhdGUoZWwpIHtcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQSwgZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcbiAgfVxuICBlbC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCwgdHJ1ZSk7XG59XG5cbi8vIFJlc3RvcmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudCwgaWYgaXQgd2FzIHNhdmVkLlxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpIHtcbiAgLy8gT25seSBtb2RpZnkgZWxlbWVudHMgd2UndmUgYWxyZWFkeSBoYW5kbGVkLCBpbiBjYXNlIGFueXRoaW5nIHdhcyBkeW5hbWljYWxseSBhZGRlZCBzaW5jZSB3ZSBzYXZlZCBzdGF0ZS5cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVEKSkge1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEEpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgZWwuZ2V0QXR0cmlidXRlKFRBQl9EQVRBKSk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVEKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtcGVyc2lzdGVudC1kcmF3ZXIgbWRjLWRyYXdlci0tcGVyc2lzdGVudCBtZGMtdHlwb2dyYXBoeVwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8bmF2IHJlZj1cImRyYXdlclwiIGNsYXNzPVwibWRjLWRyYXdlcl9fZHJhd2VyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIiBcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9mb3VuZGF0aW9uJ1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW4sXG4gICAgJ29wZW4nOkJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgdGhpcy5fcmVmcmVzaCgpXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX3JlZnJlc2goKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ub3BlbigpICAgICAgICAgIFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKSAgICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIGNvbnN0IHtGT0NVU0FCTEVfRUxFTUVOVFN9ID0gTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiAodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgdXRpbC5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoKSxcbiAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBgdHJhbnNsYXRlWCgke3ZhbHVlfXB4KWBcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIH0sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5zYXZlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IChlbCkgPT4ge1xuICAgICAgICB1dGlsLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiAoZWwpID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyx0cnVlKVxuICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpXG4gICAgICB9LFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgLyogZ2xvYmFsIGdldENvbXB1dGVkU3R5bGUgKi9cbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJ1xuICAgICAgfSxcbiAgICAgIGlzRHJhd2VyOiAoZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsID09PSB0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5pbml0KCkgIFxuICAgIHRoaXMuX3JlZnJlc2goKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXRlbXBvcmFyeScsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbiAgU0NST0xMX0xPQ0s6ICdtZGMtZHJhd2VyLXNjcm9sbC1sb2NrJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tdGVtcG9yYXJ5IC5tZGMtZHJhd2VyX19kcmF3ZXInLFxuICBPUEFDSVRZX1ZBUl9OQU1FOiAnLS1tZGMtdGVtcG9yYXJ5LWRyYXdlci1vcGFjaXR5JyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDVGVtcG9yYXJ5RHJhd2VyOm9wZW4nLFxuICBDTE9TRV9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAoLyogdGFyZ2V0OiBFdmVudFRhcmdldCwgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QsXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuXG4gICAgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyhldnQudGFyZ2V0LCBjc3NDbGFzc2VzLlJPT1QpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgc3VwZXIuaW5pdCgpO1xuXG4gICAgLy8gTWFrZSBicm93c2VyIGF3YXJlIG9mIGN1c3RvbSBwcm9wZXJ0eSBiZWluZyB1c2VkIGluIHRoaXMgZWxlbWVudC5cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBjZXJ0YWluIHR5cGVzIG9mIGhhcmQtdG8tcmVwcm9kdWNlIGhlaXNlbmJ1Z3MuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgwKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIHN0YXJ0aW5nLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuXG4gICAgc3VwZXIub3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIG1ha2luZyBhbnkgY2hhbmdlcy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLmNsb3NlKCk7XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIHN1cGVyLnByZXBhcmVGb3JUb3VjaEVuZF8oKTtcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICBzdXBlci51cGRhdGVEcmF3ZXJfKCk7XG5cbiAgICBjb25zdCBuZXdPcGFjaXR5ID0gTWF0aC5tYXgoMCwgMSArIHRoaXMuZGlyZWN0aW9uXyAqICh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShuZXdPcGFjaXR5KTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBzdXBlci5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuICAgIGlmICghdGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgICB9XG4gIH07XG5cbiAgZGlzYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cblxuICBlbmFibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZSBjbGFzcz1cIm1kYy10ZW1wb3JhcnktZHJhd2VyIG1kYy1kcmF3ZXItLXRlbXBvcmFyeSBtZGMtdHlwb2dyYXBoeVwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8bmF2IHJlZj1cImRyYXdlclwiIGNsYXNzPVwibWRjLWRyYXdlcl9fZHJhd2VyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIiB2LWlmPVwidG9vbGJhclNwYWNlclwiPjwvZGl2PlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9mb3VuZGF0aW9uJ1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10ZW1wb3JhcnktZHJhd2VyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ29wZW4nOiBCb29sZWFuLFxuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW4sXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2goKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIF9yZWZyZXNoKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKSAgICAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICBjb25zdCB7Rk9DVVNBQkxFX0VMRU1FTlRTLCBPUEFDSVRZX1ZBUl9OQU1FfSA9IFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5zdHJpbmdzXG4gICAgXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBhZGRCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT4gdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiAodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgdXRpbC5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoKSxcbiAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBgdHJhbnNsYXRlWCgke3ZhbHVlfXB4KWBcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHV0aWwuc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKCkpIHtcbiAgICAgICAgICB0aGlzLiRlbC5zdHlsZS5zZXRQcm9wZXJ0eShPUEFDSVRZX1ZBUl9OQU1FLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIH0sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5zYXZlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IChlbCkgPT4ge1xuICAgICAgICB1dGlsLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiAoZWwpID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyx0cnVlKVxuICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpXG4gICAgICB9LFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgLyogZ2xvYmFsIGdldENvbXB1dGVkU3R5bGUgKi9cbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJ1xuICAgICAgfSxcbiAgICAgIGlzRHJhd2VyOiAoZWwpID0+IGVsID09PSB0aGlzLiRyZWZzLmRyYXdlcixcbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpICBcbiAgICB0aGlzLl9yZWZyZXNoKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjb21wb25lbnQgIHJlZj1cImRyYXdlclwiIGNsYXNzPVwibWRjLWRyYXdlclwiXHJcbiAgICAgIDppcz1cInR5cGVcIiB2LW1vZGVsPVwib3Blbl9cIlxyXG4gICAgICA6dG9vbGJhci1zcGFjZXI9XCJ0b29sYmFyU3BhY2VyXCJcclxuICAgICAgQGNoYW5nZT1cIiRyb290LiRlbWl0KCdtZGM6bGF5b3V0JylcIiBcclxuICAgICAgQG9wZW49XCIkZW1pdCgnb3BlbicpXCIgXHJcbiAgICAgIEBjbG9zZT1cIiRlbWl0KCdjbG9zZScpXCIgPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2NvbXBvbmVudD5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBtZGNQZXJtYW5lbnREcmF3ZXIgZnJvbSAnLi9tZGMtcGVybWFuZW50LWRyYXdlci52dWUnXHJcbmltcG9ydCBtZGNQZXJzaXN0ZW50RHJhd2VyIGZyb20gJy4vbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSdcclxuaW1wb3J0IG1kY1RlbXBvcmFyeURyYXdlciBmcm9tICcuL21kYy10ZW1wb3JhcnktZHJhd2VyLnZ1ZSdcclxuXHJcbmNvbnN0IG1lZGlhID0gbmV3IGNsYXNzIHtcclxuICBnZXQgc21hbGwgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NtYWxsIHx8ICh0aGlzLl9zbWFsbCA9XHJcbiAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA4MzlweCknKSlcclxuICB9XHJcblxyXG4gIGdldCBsYXJnZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFyZ2UgfHwgKHRoaXMuX2xhcmdlID1cclxuICAgICAgd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEyMDBweCknKSlcclxuICB9XHJcbn0oKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtZHJhd2VyJyxcclxuICBwcm9wczoge1xyXG4gICAgcGVybWFuZW50OiBCb29sZWFuLFxyXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcclxuICAgIHRlbXBvcmFyeTogQm9vbGVhbixcclxuICAgIGRyYXdlclR5cGU6IHtcclxuICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICB2YWxpZGF0b3I6ICh2YWwpID0+IHtcclxuICAgICAgICByZXR1cm4gdmFsIGluIFsndGVtcG9yYXJ5JywgJ3BlcnNpc3RlbnQnLCAncGVybWFuZW50J11cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXHJcbiAgICB0b2dnbGVPbjogU3RyaW5nLFxyXG4gICAgdG9nZ2xlT25Tb3VyY2U6IHt0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZX0sXHJcbiAgICBvcGVuT246IFN0cmluZyxcclxuICAgIG9wZW5PblNvdXJjZToge3R5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlfSxcclxuICAgIGNsb3NlT246IFN0cmluZyxcclxuICAgIGNsb3NlT25Tb3VyY2U6IHt0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZX0sXHJcbiAgfSxcclxuICBwcm92aWRlICgpIHtcclxuICAgIHJldHVybiB7IG1kY0RyYXdlcjogdGhpcyB9XHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNtYWxsOiBmYWxzZSxcclxuICAgICAgbGFyZ2U6IGZhbHNlLFxyXG4gICAgICBvcGVuXzogZmFsc2UsXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICAnbWRjLXBlcm1hbmVudC1kcmF3ZXInOiBtZGNQZXJtYW5lbnREcmF3ZXIsXHJcbiAgICAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJzogbWRjUGVyc2lzdGVudERyYXdlcixcclxuICAgICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic6IG1kY1RlbXBvcmFyeURyYXdlclxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHR5cGUgKCkge1xyXG4gICAgICBpZiAodGhpcy5wZXJtYW5lbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGVyc2lzdGVudCkge1xyXG4gICAgICAgIHJldHVybiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGVtcG9yYXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuICdtZGMtdGVtcG9yYXJ5LWRyYXdlcidcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhd2VyVHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAncGVybWFuZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcic7XHJcbiAgICAgICAgICBjYXNlICdwZXJzaXN0ZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInO1xyXG4gICAgICAgICAgY2FzZSAndGVtcG9yYXJ5JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbWFsbCA/ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicgOiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSAgXHJcbiAgICB9LFxyXG4gICAgaXNQZXJtYW5lbnQgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wZXJtYW5lbnQgfHwgdGhpcy50eXBlID09PSAnbWRjLXBlcm1hbmVudC1kcmF3ZXInXHJcbiAgICB9LFxyXG4gICAgaXNQZXJzaXN0ZW50ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnR5cGUgPT09ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXHJcbiAgICB9LFxyXG4gICAgaXNUZW1wb3JhcnkgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZW1wb3JhcnkgfHwgdGhpcy50eXBlID09PSAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXHJcbiAgICB9LFxyXG4gICAgaXNSZXNwb25zaXZlICgpIHtcclxuICAgICAgcmV0dXJuICEodGhpcy5wZXJtYW5lbnQgfHwgdGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMuZHJhd2VyVHlwZSlcclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9wZW4gKCkge1xyXG4gICAgICB0aGlzLm9wZW5fID0gdHJ1ZVxyXG4gICAgfSxcclxuICAgIGNsb3NlICgpIHtcclxuICAgICAgdGhpcy5pc1Blcm1hbmVudCB8fCAodGhpcy5vcGVuXyA9IGZhbHNlKVxyXG4gICAgfSxcclxuICAgIHRvZ2dsZSAoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMuaXNPcGVuKCkgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKSlcclxuICAgIH0sXHJcbiAgICBpc09wZW4gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pc1Blcm1hbmVudHx8ICggdGhpcy5vcGVuXyApXHJcbiAgICB9LFxyXG4gICAgcmVmcmVzaE1lZGlhICgpIHtcclxuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcclxuICAgICAgdGhpcy5sYXJnZSA9IG1lZGlhLmxhcmdlLm1hdGNoZXNcclxuICAgICAgaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFyZ2UpIHtcclxuICAgICAgICAgIHRoaXMub3BlbigpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjcmVhdGVkICgpIHtcclxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93Lm1hdGNoTWVkaWEpIHtcclxuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcclxuICAgICAgdGhpcy5sYXJnZSA9IG1lZGlhLmxhcmdlLm1hdGNoZXNcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgaWYgKHRoaXMudG9nZ2xlT24pIHtcclxuICAgICAgbGV0IHNvdXJjZSA9IHRoaXMudG9nZ2xlT25Tb3VyY2UgfHwgdGhpcy4kcm9vdFxyXG4gICAgICBzb3VyY2UuJG9uKHRoaXMudG9nZ2xlT24sICgpID0+IHRoaXMudG9nZ2xlKCkpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcGVuT24pIHtcclxuICAgICAgbGV0IHNvdXJjZSA9IHRoaXMub3Blbk9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgc291cmNlLiRvbih0aGlzLm9wZW5PbiwgKCkgPT4gdGhpcy5vcGVuKCkpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jbG9zZU9uKSB7XHJcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLmNsb3NlT25Tb3VyY2UgfHwgdGhpcy4kcm9vdFxyXG4gICAgICBzb3VyY2UuJG9uKHRoaXMuY2xvc2VPbiwgKCkgPT4gdGhpcy5jbG9zZSgpKVxyXG4gICAgfVxyXG4gICAgbWVkaWEuc21hbGwuYWRkTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgICBtZWRpYS5sYXJnZS5hZGRMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVmcmVzaE1lZGlhKCkpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIG1lZGlhLnNtYWxsLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgbWVkaWEubGFyZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyLWxheW91dFwiPlxuICAgICAgPHNsb3QgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1sYXlvdXQnLFxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgY2xhc3M9XCJtZGMtZHJhd2VyLWhlYWRlciBtZGMtZHJhd2VyX19oZWFkZXJcIiB2LWlmPVwic2hvd1wiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX19oZWFkZXItY29udGVudFwiPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L2Rpdj5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1oZWFkZXInLFxuICBwcm9wczoge1xuICAgICdwZXJtYW5lbnQnOiBCb29sZWFuLFxuICAgICdwZXJzaXN0ZW50JzogQm9vbGVhbixcbiAgICAndGVtcG9yYXJ5JzogQm9vbGVhblxuICB9LFxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2hvdyAoKSB7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnkgfHwgdGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMucGVybWFuZW50KSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ZW1wb3JhcnkgJiYgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkpIHx8XG4gICAgICAgICAgKHRoaXMucGVyc2lzdGVudCAmJiB0aGlzLm1kY0RyYXdlci5pc1BlcnNpc3RlbnQpIHx8XG4gICAgICAgICAgICAodGhpcy5wZXJtYW5lbnQgJiYgdGhpcy5tZGNEcmF3ZXIuaXNQZXJtYW5lbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtZHJhd2VyLWxpc3QgbWRjLWxpc3RcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxpc3QnLFxuICBwcm9wczoge1xuICAgICdkZW5zZSc6IEJvb2xlYW4sXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtbGlzdC0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxufVxuPC9zY3JpcHQ+IiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayA6bGluaz1cImxpbmtcIiBcclxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1pdGVtIG1kYy1saXN0LWl0ZW1cIiBcclxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIiA6c3R5bGU9XCJzdHlsZXNcIlxyXG4gICAgQGNsaWNrPVwib25DbGlja1wiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19ncmFwaGljXCIgdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCI+XHJcbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj5cclxuICAgICAgICA8aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3tzdGFydEljb259fTwvaT5cclxuICAgICAgPC9zbG90PlxyXG4gICAgPC9zcGFuPlxyXG4gICAgPHNsb3Q+PC9zbG90PlxyXG4gIDwvY3VzdG9tLWxpbms+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGlufSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlci1pdGVtJyxcclxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBzdGFydEljb246IFN0cmluZyxcclxuICAgIHRlbXBvcmFyeUNsb3NlOiB7IFxyXG4gICAgICB0eXBlOiBCb29sZWFuLCBcclxuICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIGFjdGl2YXRlZDogQm9vbGVhbixcclxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHsgXHJcbiAgICAgIHR5cGU6IFN0cmluZywgXHJcbiAgICAgIGRlZmF1bHQ6ICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnIFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7fSxcclxuICAgICAgc3R5bGVzOiB7fVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGl0ZW1DbGFzc2VzICgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGhhc1N0YXJ0RGV0YWlsICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJY29uIHx8IHRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgb25DbGljayAoZXZ0KSB7XHJcbiAgICAgIHRoaXMubWRjRHJhd2VyLmlzVGVtcG9yYXJ5ICYmIHRoaXMudGVtcG9yYXJ5Q2xvc2UgXHJcbiAgICAgICAgJiYgdGhpcy5tZGNEcmF3ZXIuY2xvc2UoKVxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZSA9IG51bGxcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPGhyIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItZGl2aWRlcicsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMYXlvdXQgZnJvbSAnLi9tZGMtZHJhd2VyLWxheW91dC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySGVhZGVyIGZyb20gJy4vbWRjLWRyYXdlci1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckxpc3QgZnJvbSAnLi9tZGMtZHJhd2VyLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckl0ZW0gZnJvbSAnLi9tZGMtZHJhd2VyLWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0RyYXdlckRpdmlkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59KSIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1lbGV2YXRpb25cIj48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZWxldmF0aW9uJyxcbiAgcHJvcHM6IHtcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRWxldmF0aW9uIGZyb20gJy4vbWRjLWVsZXZhdGlvbi52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0VsZXZhdGlvblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRWxldmF0aW9uXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiBjbGFzcz1cIm1kYy1mYWJcIiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6aHJlZj1cImhyZWZcIiA6bGluaz1cImxpbmtcIiBcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCIgPlxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWZhYl9faWNvblwiPlxuICAgICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1JpcHBsZU1peGlufSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1mYWInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nLFxuICAgIG1pbmk6IEJvb2xlYW4sXG4gICAgYWJzb2x1dGU6IEJvb2xlYW4sXG4gICAgZml4ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogdGhpcy5pY29uLFxuICAgICAgICAnbWRjLWZhYi0tbWluaSc6IHRoaXMubWluaSxcbiAgICAgICAgJ21kYy1mYWItLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgJ21kYy1mYWItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaWNvbiAoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWF0ZXJpYWwtaWNvbnMnLCB0aGlzLmljb24gKVxuICAgIH0sXG4gICAgbWluaSAoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWZhYi0tbWluaScsIHRoaXMubWluaSApXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNGQUIgZnJvbSAnLi9tZGMtZmFiLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRkFCXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNGQUJcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJTEVTX1NFTEVDVE9SOiAnLm1kYy1ncmlkLWxpc3RfX3RpbGVzJyxcbiAgVElMRV9TRUxFQ1RPUjogJy5tZGMtZ3JpZC10aWxlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENHcmlkTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvclRpbGVzRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDR3JpZExpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWxpZ25DZW50ZXIoKTtcbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IDA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGFsaWduQ2VudGVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUZyYW1lXyAhPT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFsaWduQ2VudGVyXygpO1xuICAgICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG4gIGFsaWduQ2VudGVyXygpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRpbGVzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncmlkV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4KDApO1xuICAgIGNvbnN0IHRpbGVzV2lkdGggPSBpdGVtV2lkdGggKiBNYXRoLmZsb29yKGdyaWRXaWR0aCAvIGl0ZW1XaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpbGVzRWxlbWVudCgnd2lkdGgnLCBgJHt0aWxlc1dpZHRofXB4YCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLWxpc3RcIj5cbiAgICA8dWwgY2xhc3M9XCJtZGMtZ3JpZC1saXN0X190aWxlc1wiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9c3R5bGVzPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0dyaWRMaXN0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZ3JpZC1saXN0L2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1ncmlkLWxpc3QnLFxuICBwcm9wczoge1xuICAgICd3aWR0aCc6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgJ3JhdGlvJzogU3RyaW5nLFxuICAgICduYXJyb3ctZ3V0dGVyJzogQm9vbGVhbixcbiAgICAnaGVhZGVyLWNhcHRpb24nOiBCb29sZWFuLFxuICAgICdpY29uLWFsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1lbmQnOiBCb29sZWFuLFxuICAgICd3aXRoLXN1cHBvcnQtdGV4dCc6IEJvb2xlYW4sXG4gICAgJ2ludGVyYWN0aXZlJzogQm9vbGVhblxuICB9LFxuICBwcm92aWRlICgpIHtcbiAgICByZXR1cm4geyBtZGNHcmlkOiB0aGlzIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzICgpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0tdGlsZS1ndXR0ZXItMSddID0gdGhpcy5uYXJyb3dHdXR0ZXJcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLWhlYWRlci1jYXB0aW9uJ10gPSB0aGlzLmhlYWRlckNhcHRpb25cbiAgICAgIGNsYXNzZXNbYG1kYy1ncmlkLWxpc3QtLXRpbGUtYXNwZWN0LSR7dGhpcy5yYXRpb31gXSA9IHRoaXMucmF0aW9cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1zdGFydCddID0gdGhpcy5pY29uQWxpZ25TdGFydFxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0td2l0aC1pY29uLWFsaWduLWVuZCddID0gdGhpcy5pY29uQWxpZ25FbmRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXR3b2xpbmUtY2FwdGlvbiddID0gdGhpcy53aXRoU3VwcG9ydFRleHRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSddID0gIXRoaXMuaW50ZXJhY3RpdmVcblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9LFxuICAgIHN0eWxlcyAoKSB7XG4gICAgICB2YXIgZGVmYXVsdFdpZHRoID0gMjAwXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnLS1tZGMtZ3JpZC1saXN0LXRpbGUtd2lkdGgnOiBgJHt0aGlzLndpZHRoIHx8IGRlZmF1bHRXaWR0aH1weGBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENHcmlkTGlzdEZvdW5kYXRpb24oe1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICBNRENHcmlkTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5USUxFX1NFTEVDVE9SKS5sZW5ndGhcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUilbaW5kZXhdLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENHcmlkTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5USUxFU19TRUxFQ1RPUikuc3R5bGVbcHJvcGVydHldID0gdmFsdWVcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiIEBjbGljaz1cIm9uQ2xpY2tcIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIHYtb249XCJpc0ludGVyYWN0aXZlID8gJGxpc3RlbmVycyA6IHt9XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnlcIiB2LWlmPVwiY292ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5LWNvbnRlbnRcIlxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCIgdi1lbHNlPlxuICAgICAgICA8aW1nIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgOnNyYz1cInNyY1wiIC8+XG4gICAgPC9kaXY+XG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zZWNvbmRhcnlcIiB2LWlmPVwidGl0bGUgfHwgc3VwcG9ydFRleHRcIj5cbiAgICAgIDxpIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiIHYtaWY9XCJpY29uXCI+e3sgaWNvbiB9fTwvaT5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIiB2LWlmPVwidGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fc3VwcG9ydC10ZXh0XCIgdi1pZj1cInN1cHBvcnRUZXh0XCI+e3sgc3VwcG9ydFRleHQgfX08L3NwYW4+XG4gICAgPC9zcGFuPlxuICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgJ3NyYyc6IFN0cmluZyxcbiAgICAnY292ZXInOiBCb29sZWFuLFxuICAgICdpY29uJzogU3RyaW5nLFxuICAgICd0aXRsZSc6IFN0cmluZyxcbiAgICAnc3VwcG9ydC10ZXh0JzogU3RyaW5nLFxuICAgICdzZWxlY3RlZCc6IEJvb2xlYW4sXG4gICAgJ2FjdGl2YXRlZCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpdGVtQ2xhc3NlcyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjR3JpZCAmJiB0aGlzLm1kY0dyaWQuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0SWNvbiB8fCB0aGlzLiRzbG90c1snc3RhcnQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DbGljayAoZXZ0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KVxuICAgIH0sXG4gICAgYWRkUmlwcGxlICgpIHtcbiAgICAgIGlmICghdGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgICAgIHJpcHBsZS5pbml0KClcbiAgICAgICAgdGhpcy5yaXBwbGUgPSByaXBwbGVcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZVJpcHBsZSAoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgJiYgdGhpcy5hZGRSaXBwbGUoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjR3JpZExpc3QsXG4gIG1kY0dyaWRUaWxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNHcmlkTGlzdCxcbiAgbWRjR3JpZFRpbGVcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCIgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtaWNvbicsXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgbWRjSWNvbiBmcm9tICcuL21kYy1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjSWNvblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcclxuICBtZGNJY29uXHJcbn0pXHJcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgSWNvbiBUb2dnbGUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gaW5uZXIgdGV4dFxuICogLSBldmVudCBoYW5kbGVyc1xuICogLSBldmVudCBkaXNwYXRjaFxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuXG5jbGFzcyBNRENJY29uVG9nZ2xlQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IHRleHQgKi9cbiAgc2V0VGV4dCh0ZXh0KSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFRhYkluZGV4KCkge31cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHRhYkluZGV4ICovXG4gIHNldFRhYkluZGV4KHRhYkluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihuYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbiAgcm1BdHRyKG5hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUljb25Ub2dnbGVFdmVudH0gZXZ0RGF0YSAqL1xuICBub3RpZnlDaGFuZ2UoZXZ0RGF0YSkge31cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgaXNPbjogYm9vbGVhbixcbiAqIH19XG4gKi9cbmxldCBJY29uVG9nZ2xlRXZlbnQ7XG5cbmV4cG9ydCB7TURDSWNvblRvZ2dsZUFkYXB0ZXIsIEljb25Ub2dnbGVFdmVudH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWljb24tdG9nZ2xlJyxcbiAgRElTQUJMRUQ6ICdtZGMtaWNvbi10b2dnbGUtLWRpc2FibGVkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgREFUQV9UT0dHTEVfT046ICdkYXRhLXRvZ2dsZS1vbicsXG4gIERBVEFfVE9HR0xFX09GRjogJ2RhdGEtdG9nZ2xlLW9mZicsXG4gIEFSSUFfUFJFU1NFRDogJ2FyaWEtcHJlc3NlZCcsXG4gIEFSSUFfRElTQUJMRUQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgQVJJQV9MQUJFTDogJ2FyaWEtbGFiZWwnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENJY29uVG9nZ2xlOmNoYW5nZScsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDSWNvblRvZ2dsZUFkYXB0ZXIsIEljb25Ub2dnbGVFdmVudH0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENJY29uVG9nZ2xlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHNldFRleHQ6ICgvKiB0ZXh0OiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0VGFiSW5kZXg6ICgvKiB0YWJJbmRleDogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIGdldEF0dHI6ICgvKiBuYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldEF0dHI6ICgvKiBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1BdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IEljb25Ub2dnbGVFdmVudCAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5vbl8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IC0xO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUgez9JY29uVG9nZ2xlU3RhdGV9ICovXG4gICAgdGhpcy50b2dnbGVPZmZEYXRhXyA9IG51bGw7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZyb21FdnRfKCkpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovICgoLyoqIEB0eXBlIHshS2V5Ym9hcmRLZXl9ICovIGV2dCkgPT4ge1xuICAgICAgaWYgKGlzU3BhY2UoZXZ0KSkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IHRydWU7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMua2V5dXBIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovICgoLyoqIEB0eXBlIHshS2V5Ym9hcmRLZXl9ICovIGV2dCkgPT4ge1xuICAgICAgaWYgKGlzU3BhY2UoZXZ0KSkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvZ2dsZUZyb21FdnRfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucmVmcmVzaFRvZ2dsZURhdGEoKTtcbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgfVxuXG4gIHJlZnJlc2hUb2dnbGVEYXRhKCkge1xuICAgIGNvbnN0IHtEQVRBX1RPR0dMRV9PTiwgREFUQV9UT0dHTEVfT0ZGfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgdGhpcy50b2dnbGVPbkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT04pO1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSB0aGlzLnBhcnNlSnNvbkRhdGFBdHRyXyhEQVRBX1RPR0dMRV9PRkYpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdG9nZ2xlRnJvbUV2dF8oKSB7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgICBjb25zdCB7b25fOiBpc09ufSA9IHRoaXM7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoLyoqIEB0eXBlIHshSWNvblRvZ2dsZUV2ZW50fSAqLyAoe2lzT259KSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPbigpIHtcbiAgICByZXR1cm4gdGhpcy5vbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFuPX0gaXNPbiAqL1xuICB0b2dnbGUoaXNPbiA9ICF0aGlzLm9uXykge1xuICAgIHRoaXMub25fID0gaXNPbjtcblxuICAgIGNvbnN0IHtBUklBX0xBQkVMLCBBUklBX1BSRVNTRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLm9uXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfUFJFU1NFRCwgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfUFJFU1NFRCwgJ2ZhbHNlJyk7XG4gICAgfVxuXG4gICAgY29uc3Qge2Nzc0NsYXNzOiBjbGFzc1RvUmVtb3ZlfSA9XG4gICAgICAgIHRoaXMub25fID8gdGhpcy50b2dnbGVPZmZEYXRhXyA6IHRoaXMudG9nZ2xlT25EYXRhXztcblxuICAgIGlmIChjbGFzc1RvUmVtb3ZlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNsYXNzVG9SZW1vdmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjb250ZW50LCBsYWJlbCwgY3NzQ2xhc3N9ID0gdGhpcy5vbl8gPyB0aGlzLnRvZ2dsZU9uRGF0YV8gOiB0aGlzLnRvZ2dsZU9mZkRhdGFfO1xuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGV4dChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQVJJQV9MQUJFTCwgbGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YUF0dHJcbiAgICogQHJldHVybiB7IUljb25Ub2dnbGVTdGF0ZX1cbiAgICovXG4gIHBhcnNlSnNvbkRhdGFBdHRyXyhkYXRhQXR0cikge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuYWRhcHRlcl8uZ2V0QXR0cihkYXRhQXR0cik7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUljb25Ub2dnbGVTdGF0ZX0gKi8gKEpTT04ucGFyc2UodmFsKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGVkICovXG4gIHNldERpc2FibGVkKGlzRGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGlzRGlzYWJsZWQ7XG5cbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7QVJJQV9ESVNBQkxFRH0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCgtMSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQVJJQV9ESVNBQkxFRCwgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRhYkluZGV4KHRoaXMuc2F2ZWRUYWJJbmRleF8pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUF0dHIoQVJJQV9ESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNLZXlib2FyZEFjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl87XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIiByb2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIlxuICAgIDpkYXRhLXRvZ2dsZS1vZmY9XCJ0b2dnbGVPZmZEYXRhXCI+XG4gICAgPGkgOmNsYXNzPVwiaWNvbkNsYXNzZXNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57e3RleHR9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtaWNvbi10b2dnbGUnLFxuICBwcm9wczoge1xuICAgIHRvZ2dsZU9uOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHRvZ2dsZU9mZjogW1N0cmluZywgT2JqZWN0XSxcbiAgICB2YWx1ZTogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhY2NlbnQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1pY29uLXRvZ2dsZS0tYWNjZW50JzogdGhpcy5hY2NlbnRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgaWNvbkNsYXNzZXM6IHt9LFxuICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnRvZ2dsZSh2YWx1ZSlcbiAgICB9LFxuICAgIGRpc2FibGVkIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZChkaXNhYmxlZClcbiAgICB9LFxuICAgIHRvZ2dsZU9uRGF0YSAoKSB7XG4gICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ucmVmcmVzaFRvZ2dsZURhdGEoKVxuICAgIH0sXG4gICAgdG9nZ2xlT2ZmRGF0YSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5yZWZyZXNoVG9nZ2xlRGF0YSgpXG4gICAgfSxcbiAgICBhY2NlbnQgKHZhbHVlKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWljb24tdG9nZ2xlLS1zZWNvbmRhcnknLCB2YWx1ZSlcbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHRvZ2dsZU9uRGF0YSAoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPblxuICAgICAgcmV0dXJuIHRvZ2dsZSAmJiBKU09OLnN0cmluZ2lmeSgodHlwZW9mIHRvZ2dsZSA9PT0gJ3N0cmluZycpID8geyBcbiAgICAgICAgY29udGVudDogdG9nZ2xlLCBcbiAgICAgICAgY3NzQ2xhc3M6ICdtYXRlcmlhbC1pY29ucycgXG4gICAgICB9IDoge1xuICAgICAgICBjb250ZW50OiB0b2dnbGUuaWNvbiB8fCB0b2dnbGUuY29udGVudCxcbiAgICAgICAgbGFiZWw6IHRvZ2dsZS5sYWJlbCxcbiAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgfSlcbiAgICB9ICxcbiAgICB0b2dnbGVPZmZEYXRhICgpIHtcbiAgICAgIGxldCB0b2dnbGUgPSB0aGlzLnRvZ2dsZU9mZlxuICAgICAgcmV0dXJuIHRvZ2dsZSAmJiBKU09OLnN0cmluZ2lmeSgodHlwZW9mIHRvZ2dsZSA9PT0gJ3N0cmluZycpID8geyBcbiAgICAgICAgY29udGVudDogdG9nZ2xlLCBcbiAgICAgICAgY3NzQ2xhc3M6ICdtYXRlcmlhbC1pY29ucycgXG4gICAgICB9IDoge1xuICAgICAgICBjb250ZW50OiB0b2dnbGUuaWNvbiB8fCB0b2dnbGUuY29udGVudCxcbiAgICAgICAgbGFiZWw6IHRvZ2dsZS5sYWJlbCxcbiAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgfSlcbiAgICB9LFxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDSWNvblRvZ2dsZUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIHNldFRleHQ6ICh0ZXh0KSA9PiB7IHRoaXMudGV4dCA9IHRleHQgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6ICh0YWJJbmRleCkgPT4geyB0aGlzLnRhYkluZGV4ID0gdGFiSW5kZXggfSxcbiAgICAgIGdldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSxcbiAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4geyB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIH0sXG4gICAgICBybUF0dHI6IChuYW1lKSA9PiB7IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoZXZ0RGF0YSkgPT4geyB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbikgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi50b2dnbGUodGhpcy52YWx1ZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IHRoaXMuZm91bmRhdGlvbi5pc0tleWJvYXJkQWN0aXZhdGVkKCksXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNJQ29uVG9nZ2xlIGZyb20gJy4vbWRjLWljb24tdG9nZ2xlLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjSUNvblRvZ2dsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLXRvb2xiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvb2xiYXJcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1tYWluLWNvbnRhaW5lclwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJkcmF3ZXJcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWFwcCcsXG59XG48L3NjcmlwdD4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGF5b3V0QXBwIGZyb20gJy4vbWRjLWxheW91dC1hcHAudnVlJ1xuXG5leHBvcnQge1xuICBtZGNMYXlvdXRBcHBcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xheW91dEFwcFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtZ3JpZFwiIDpjbGFzcz1jbGFzc2VzPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWdyaWRfX2lubmVyXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1ncmlkJyxcbiAgcHJvcHM6IHtcbiAgICAnZml4ZWQtY29sdW1uLXdpZHRoJzogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnOiB0aGlzLmZpeGVkQ29sdW1uV2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1jZWxsIG1kYy1sYXlvdXQtZ3JpZF9fY2VsbFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmNvbnN0IHNwYW5PcHRpb25zID0ge1xuICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWZhdWx0OiBudWxsLFxuICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpXG4gICAgcmV0dXJuIGlzRmluaXRlKG51bSkgJiYgKG51bSA8PSAxMikgJiYgKG51bSA+IDApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1jZWxsJyxcbiAgcHJvcHM6IHtcbiAgICBzcGFuOiBzcGFuT3B0aW9ucyxcbiAgICBvcmRlcjogc3Bhbk9wdGlvbnMsXG4gICAgcGhvbmU6IHNwYW5PcHRpb25zLFxuICAgIHRhYmxldDogc3Bhbk9wdGlvbnMsXG4gICAgZGVza3RvcDogc3Bhbk9wdGlvbnMsXG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgbGV0IGNsYXNzZXMgPSBbXVxuXG4gICAgICBpZiAodGhpcy5zcGFuKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5zcGFufWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9yZGVyKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1vcmRlci0ke3RoaXMub3JkZXJ9YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGhvbmUpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnBob25lfS1waG9uZWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhYmxldCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMudGFibGV0fS10YWJsZXRgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZXNrdG9wKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5kZXNrdG9wfS1kZXNrdG9wYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWxpZ24pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLWFsaWduLSR7dGhpcy5hbGlnbn1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3Nlc1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWlubmVyLWdyaWQgbWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1pbm5lci1ncmlkJyxcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWdyaWQudnVlJ1xuaW1wb3J0IG1kY0xheW91dENlbGwgZnJvbSAnLi9tZGMtbGF5b3V0LWNlbGwudnVlJ1xuaW1wb3J0IG1kY0xheW91dElubmVyR3JpZCBmcm9tICcuL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xheW91dEdyaWQsXG4gIG1kY0xheW91dENlbGwsXG4gIG1kY0xheW91dElubmVyR3JpZFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0R3JpZCxcbiAgbWRjTGF5b3V0Q2VsbCxcbiAgbWRjTGF5b3V0SW5uZXJHcmlkXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENMT1NFRF9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWNsb3NlZCcsXG4gIElOREVURVJNSU5BVEVfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1pbmRldGVybWluYXRlJyxcbiAgUkVWRVJTRURfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1yZXZlcnNlZCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgUFJJTUFSWV9CQVJfU0VMRUNUT1I6ICcubWRjLWxpbmVhci1wcm9ncmVzc19fcHJpbWFyeS1iYXInLFxuICBCVUZGRVJfU0VMRUNUT1I6ICcubWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7dHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcblxuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0QnVmZmVyOiAoKSA9PiAvKiBlbDogRWxlbWVudCAqLyB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IGZhbHNlLFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIGVsOiBFbGVtZW50LCBzdHlsZVByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENMaW5lYXJQcm9ncmVzc0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5kZXRlcm1pbmF0ZV8gPSAhdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0xBU1MpO1xuICAgIHRoaXMucmV2ZXJzZV8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gMDtcbiAgfVxuXG4gIHNldERldGVybWluYXRlKGlzRGV0ZXJtaW5hdGUpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9IGlzRGV0ZXJtaW5hdGU7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgdGhpcy5wcm9ncmVzc18pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgMSk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCAxKTtcbiAgICB9XG4gIH1cblxuICBzZXRQcm9ncmVzcyh2YWx1ZSkge1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEJ1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRldGVybWluYXRlXykge1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRCdWZmZXIoKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldFJldmVyc2UoaXNSZXZlcnNlZCkge1xuICAgIHRoaXMucmV2ZXJzZV8gPSBpc1JldmVyc2VkO1xuICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkNMT1NFRF9DTEFTUyk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIHNldFNjYWxlXyhlbCwgc2NhbGVWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gJ3NjYWxlWCgnICsgc2NhbGVWYWx1ZSArICcpJztcbiAgICB0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXMuZm9yRWFjaCgodHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZShlbCwgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcm9sZT1cInByb2dyZXNzYmFyXCIgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXJpbmctZG90c1wiPjwvZGl2PlxuICAgIDxkaXYgcmVmPVwiYnVmZmVyXCIgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXJcIj48L2Rpdj5cbiAgICA8ZGl2IHJlZj1cInByaW1hcnlcIiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yICh2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID49IDAgJiYgTnVtYmVyKHZhbHVlKSA8PSAxXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpbmVhci1wcm9ncmVzcycsXG4gIHByb3BzOiB7XG4gICAgJ29wZW4nOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICAnaW5kZXRlcm1pbmF0ZSc6IEJvb2xlYW4sXG4gICAgJ3JldmVyc2UnOiBCb29sZWFuLFxuICAgICdhY2NlbnQnOiBCb29sZWFuLFxuICAgICdwcm9ncmVzcyc6IFByb2dyZXNzUHJvcFR5cGUsXG4gICAgJ2J1ZmZlcic6IFByb2dyZXNzUHJvcFR5cGVcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHsnbWRjLWxpbmVhci1wcm9ncmVzcy0tYWNjZW50JzogdGhpcy5hY2NlbnR9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuICgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2dyZXNzICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRQcm9ncmVzcyhOdW1iZXIodGhpcy5wcm9ncmVzcykpXG4gICAgfSxcbiAgICBidWZmZXIgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICB9LFxuICAgIHJldmVyc2UgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFJldmVyc2UodGhpcy5yZXZlcnNlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5wcmltYXJ5XG4gICAgICB9LFxuICAgICAgZ2V0QnVmZmVyOiAoKSA9PiAvKiBlbDogRWxlbWVudCAqLyB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmJ1ZmZlclxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpbmVhclByb2dyZXNzIGZyb20gJy4vbWRjLWxpbmVhci1wcm9ncmVzcy52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xpbmVhclByb2dyZXNzXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSkiLCI8dGVtcGxhdGU+XG4gIDx1bCBjbGFzcz1cIm1kYy1saXN0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC91bD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgYXZhdGFyTGlzdDogQm9vbGVhbixcbiAgICB0d29MaW5lOiBCb29sZWFuLFxuICAgIGJvcmRlcmVkOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUgKCkge1xuICAgIHJldHVybiB7IG1kY0xpc3Q6IHRoaXMgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtbGlzdC0tYXZhdGFyLWxpc3QnOiB0aGlzLmF2YXRhckxpc3QsXG4gICAgICAgICdtZGMtbGlzdC0tdHdvLWxpbmUnOiB0aGlzLnR3b0xpbmUsXG4gICAgICAgICdtZGMtbGlzdC0tYm9yZGVyZWQnOiB0aGlzLmJvcmRlcmVkLFxuICAgICAgICAnbWRjLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSc6ICF0aGlzLmludGVyYWN0aXZlXG4gICAgICB9ICAgICAgXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIGNsYXNzPVwibWRjLWxpc3QtaXRlbVwiXG4gICAgOmNsYXNzPVwiW2NsYXNzZXMsIGl0ZW1DbGFzc2VzXVwiIDpzdHlsZT1cInN0eWxlc1wiICAgXG4gICAgOnRhYmluZGV4PVwiaXNJbnRlcmFjdGl2ZSA/ICcwJyA6IHVuZGVmaW5lZFwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyAkbGlzdGVuZXJzIDoge31cIj5cblxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiIHYtaWY9XCJoYXNTdGFydERldGFpbFwiPlxuICAgICAgPHNsb3QgbmFtZT1cInN0YXJ0LWRldGFpbFwiPjwvc2xvdD5cbiAgICA8L3NwYW4+XG5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3RleHRcIiB2LWlmPVwiaGFzU2Vjb25kYXJ5XCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3NlY29uZGFyeS10ZXh0XCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJzZWNvbmRhcnlcIj48L3Nsb3Q+XG4gICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuICAgIDxzbG90IHYtZWxzZT48L3Nsb3Q+XG5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX21ldGFcIiB2LWlmPVwiaGFzRW5kRGV0YWlsXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZW5kLWRldGFpbFwiPjwvc2xvdD5cbiAgICA8L3NwYW4+XG5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtaXRlbScsXG4gIGluamVjdDogWydtZGNMaXN0J10sXG4gIHByb3BzOiB7XG4gICAgc2VsZWN0ZWQ6IEJvb2xlYW4sXG4gICAgYWN0aXZhdGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9IFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1zZWxlY3RlZCc6IHRoaXMuc2VsZWN0ZWQsXG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnOiB0aGlzLmFjdGl2YXRlZFxuICAgICAgfVxuICAgIH0sXG4gICAgaXNJbnRlcmFjdGl2ZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNMaXN0ICYmIHRoaXMubWRjTGlzdC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU2Vjb25kYXJ5ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKFxuICAgICAgICB0aGlzLm1kY0xpc3QgJiYgdGhpcy5tZGNMaXN0LnR3b0xpbmVcbiAgICAgICkgXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwgKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ2VuZC1kZXRhaWwnXVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwgKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUgKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuYWRkUmlwcGxlKCkgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICAgICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgJiYgdGhpcy5hZGRSaXBwbGUoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUgKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZSAgICAgICAgICAgICAgICAgXG4gICAgICB9IFxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlICgpIHtcbiAgICAgIGlmICh0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gdGhpcy5yaXBwbGVcbiAgICAgICAgdGhpcy5yaXBwbGUgPSBudWxsIFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9ICAgICAgICAgICAgICAgIFxuICAgIH1cbiAgfVxuICBcbn1cbjwvc2NyaXB0PlxuICAiLCI8dGVtcGxhdGU+XG4gIDxsaSByb2xlPVwic2VwYXJhdG9yXCIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCIgXG4gIDpjbGFzcz1cImNsYXNzZXNcIj48L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWRpdmlkZXInLFxuICBwcm9wczoge1xuICAgIGluc2V0OiBCb29sZWFuLFxuICAgIHBhZGRlZDogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDMgY2xhc3M9XCJtZGMtbGlzdC1ncm91cC1oZWFkZXIgbWRjLWxpc3QtZ3JvdXBfX3N1YmhlYWRlclwiPjxzbG90Pjwvc2xvdD48L2gzPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWhlYWRlcicsXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhyIGNsYXNzPVwibWRjLWxpc3QtZ3JvdXAtZGl2aWRlciBtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtZGl2aWRlcicsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaXN0IGZyb20gJy4vbWRjLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0xpc3RJdGVtIGZyb20gJy4vbWRjLWxpc3QtaXRlbS52dWUnXG5pbXBvcnQgbWRjTGlzdERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1kaXZpZGVyLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXAgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC52dWUnXG5pbXBvcnQgbWRjTGlzdEdyb3VwSGVhZGVyIGZyb20gJy4vbWRjLWxpc3QtZ3JvdXAtaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBEaXZpZGVyIGZyb20gJy4vbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xpc3QsXG4gIG1kY0xpc3RJdGVtLFxuICBtZGNMaXN0RGl2aWRlcixcbiAgbWRjTGlzdEdyb3VwLFxuICBtZGNMaXN0R3JvdXBIZWFkZXIsXG4gIG1kY0xpc3RHcm91cERpdmlkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xpc3QsXG4gIG1kY0xpc3RJdGVtLFxuICBtZGNMaXN0RGl2aWRlcixcbiAgbWRjTGlzdEdyb3VwLFxuICBtZGNMaXN0R3JvdXBIZWFkZXIsXG4gIG1kY0xpc3RHcm91cERpdmlkZXJcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIE1lbnUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZm9jdXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTWVudUFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGhhc05lY2Vzc2FyeURvbSgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldCh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3sgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0SW5uZXJEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaGFzQW5jaG9yKCkge31cblxuICAvKiogQHJldHVybiB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19ICovXG4gIGdldEFuY2hvckRpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gIGdldFdpbmRvd0RpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldE51bWJlck9mSXRlbXMoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqIEBwYXJhbSB7e2luZGV4OiBudW1iZXJ9fSBldnREYXRhICovXG4gIG5vdGlmeVNlbGVjdGVkKGV2dERhdGEpIHt9XG5cbiAgbm90aWZ5Q2FuY2VsKCkge31cblxuICBzYXZlRm9jdXMoKSB7fVxuXG4gIHJlc3RvcmVGb2N1cygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRm9jdXNlZCgpIHt9XG5cbiAgZm9jdXMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldEZvY3VzZWRJdGVtSW5kZXgoKSAvKiBudW1iZXIgKi8ge31cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IGluZGV4ICovXG4gIGZvY3VzSXRlbUF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzUnRsKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAqL1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4ob3JpZ2luKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3tcbiAgKiAgIHRvcDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgcmlnaHQ6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgKiAgIGJvdHRvbTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgbGVmdDogKHN0cmluZ3x1bmRlZmluZWQpXG4gICogfX0gcG9zaXRpb24gKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgKi9cbiAgc2V0TWF4SGVpZ2h0KGhlaWdodCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJtQXR0ckZvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4KGluZGV4LCBjbGFzc05hbWUpIHt9XG59XG5cbmV4cG9ydCB7TURDTWVudUFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1tZW51JyxcbiAgT1BFTjogJ21kYy1tZW51LS1vcGVuJyxcbiAgQU5JTUFUSU5HX09QRU46ICdtZGMtbWVudS0tYW5pbWF0aW5nLW9wZW4nLFxuICBBTklNQVRJTkdfQ0xPU0VEOiAnbWRjLW1lbnUtLWFuaW1hdGluZy1jbG9zZWQnLFxuICBTRUxFQ1RFRF9MSVNUX0lURU06ICdtZGMtbGlzdC1pdGVtLS1zZWxlY3RlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElURU1TX1NFTEVDVE9SOiAnLm1kYy1tZW51X19pdGVtcycsXG4gIFNFTEVDVEVEX0VWRU5UOiAnTURDTWVudTpzZWxlY3RlZCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ01lbnU6Y2FuY2VsJyxcbiAgQVJJQV9ESVNBQkxFRF9BVFRSOiAnYXJpYS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIC8vIEFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRyaWdnZXJpbmcgYSBzZWxlY3RlZCBldmVudCBvbiB0aGUgbWVudS4gTm90ZSB0aGF0IHRoaXMgdGltZVxuICAvLyB3aWxsIG1vc3QgbGlrZWx5IGJlIGJ1bXBlZCB1cCBvbmNlIGludGVyYWN0aXZlIGxpc3RzIGFyZSBzdXBwb3J0ZWQgdG8gYWxsb3cgZm9yIHRoZSByaXBwbGUgdG9cbiAgLy8gYW5pbWF0ZSBiZWZvcmUgY2xvc2luZyB0aGUgbWVudVxuICBTRUxFQ1RFRF9UUklHR0VSX0RFTEFZOiA1MCxcbiAgLy8gVG90YWwgZHVyYXRpb24gb2YgbWVudSBvcGVuIGFuaW1hdGlvbi5cbiAgVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OOiAxMjAsXG4gIC8vIFRvdGFsIGR1cmF0aW9uIG9mIG1lbnUgY2xvc2UgYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OOiA3NSxcbiAgLy8gTWFyZ2luIGxlZnQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHdoZW4gbWVudSBpcyBhdCBtYXhpbXVtIHBvc3NpYmxlIGhlaWdodC5cbiAgTUFSR0lOX1RPX0VER0U6IDMyLFxuICAvLyBSYXRpbyBvZiBhbmNob3Igd2lkdGggdG8gbWVudSB3aWR0aCBmb3Igc3dpdGNoaW5nIGZyb20gY29ybmVyIHBvc2l0aW9uaW5nIHRvIGNlbnRlciBwb3NpdGlvbmluZy5cbiAgQU5DSE9SX1RPX01FTlVfV0lEVEhfUkFUSU86IDAuNjcsXG4gIC8vIFJhdGlvIG9mIHZlcnRpY2FsIG9mZnNldCB0byBtZW51IGhlaWdodCBmb3Igc3dpdGNoaW5nIGZyb20gY29ybmVyIHRvIG1pZC13YXkgb3JpZ2luIHBvc2l0aW9uaW5nLlxuICBPRkZTRVRfVE9fTUVOVV9IRUlHSFRfUkFUSU86IDAuMSxcbn07XG5cbi8qKlxuICogRW51bSBmb3IgYml0cyBpbiB0aGUge0BzZWUgQ29ybmVyKSBiaXRtYXAuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDb3JuZXJCaXQgPSB7XG4gIEJPVFRPTTogMSxcbiAgQ0VOVEVSOiAyLFxuICBSSUdIVDogNCxcbiAgRkxJUF9SVEw6IDgsXG59O1xuXG4vKipcbiAqIEVudW0gZm9yIHJlcHJlc2VudGluZyBhbiBlbGVtZW50IGNvcm5lciBmb3IgcG9zaXRpb25pbmcgdGhlIG1lbnUuXG4gKlxuICogVGhlIFNUQVJUIGNvbnN0YW50cyBtYXAgdG8gTEVGVCBpZiBlbGVtZW50IGRpcmVjdGlvbmFsaXR5IGlzIGxlZnRcbiAqIHRvIHJpZ2h0IGFuZCBSSUdIVCBpZiB0aGUgZGlyZWN0aW9uYWxpdHkgaXMgcmlnaHQgdG8gbGVmdC5cbiAqIExpa2V3aXNlIEVORCBtYXBzIHRvIFJJR0hUIG9yIExFRlQgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb25hbGl0eS5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDb3JuZXIgPSB7XG4gIFRPUF9MRUZUOiAwLFxuICBUT1BfUklHSFQ6IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX0xFRlQ6IENvcm5lckJpdC5CT1RUT00sXG4gIEJPVFRPTV9SSUdIVDogQ29ybmVyQml0LkJPVFRPTSB8IENvcm5lckJpdC5SSUdIVCxcbiAgVE9QX1NUQVJUOiBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIFRPUF9FTkQ6IENvcm5lckJpdC5GTElQX1JUTCB8IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX1NUQVJUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxuICBCT1RUT01fRU5EOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hUIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxufTtcblxuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIENvcm5lckJpdCwgQ29ybmVyfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHRvcDogbnVtYmVyLFxuICogICByaWdodDogbnVtYmVyLFxuICogICBib3R0b206IG51bWJlcixcbiAqICAgbGVmdDogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgQW5jaG9yTWFyZ2luO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2aWV3cG9ydDogeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LFxuICogICB2aWV3cG9ydERpc3RhbmNlOiB7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9LFxuICogICBhbmNob3JIZWlnaHQ6IG51bWJlcixcbiAqICAgYW5jaG9yV2lkdGg6IG51bWJlcixcbiAqICAgbWVudUhlaWdodDogbnVtYmVyLFxuICogICBtZW51V2lkdGg6IG51bWJlcixcbiAqIH19XG4gKi9cbmxldCBBdXRvTGF5b3V0TWVhc3VyZW1lbnRzO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7TURDTWVudUFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIENvcm5lciwgQ29ybmVyQml0fSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ01lbnVBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDTWVudUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJ9ICovXG4gIHN0YXRpYyBnZXQgQ29ybmVyKCkge1xuICAgIHJldHVybiBDb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTWVudUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTWVudUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENNZW51QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiBmYWxzZSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gZmFsc2UsXG4gICAgICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldDogKCkgPT4ge30sXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBoYXNBbmNob3I6ICgpID0+IGZhbHNlLFxuICAgICAgZ2V0QW5jaG9yRGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogKCkgPT4gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge30sXG4gICAgICBzYXZlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4gZmFsc2UsXG4gICAgICBmb2N1czogKCkgPT4ge30sXG4gICAgICBnZXRGb2N1c2VkSXRlbUluZGV4OiAoKSA9PiAtMSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IGZhbHNlLFxuICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luOiAoKSA9PiB7fSxcbiAgICAgIHNldFBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgICAgIHNldE1heEhlaWdodDogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBybUNsYXNzRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshTURDTWVudUFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTWVudUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlib2FyZERvd25fKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMua2V5dXBIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5Ym9hcmRVcF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2tfKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHsheyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICAgIHRoaXMuZGltZW5zaW9uc187XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pdGVtSGVpZ2h0XztcbiAgICAvKiogQHByaXZhdGUge0Nvcm5lcn0gKi9cbiAgICB0aGlzLmFuY2hvckNvcm5lcl8gPSBDb3JuZXIuVE9QX1NUQVJUO1xuICAgIC8qKiBAcHJpdmF0ZSB7QW5jaG9yTWFyZ2lufSAqL1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXyA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9O1xuICAgIC8qKiBAcHJpdmF0ZSB7P0F1dG9MYXlvdXRNZWFzdXJlbWVudHN9ICovXG4gICAgdGhpcy5tZWFzdXJlc18gPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSAtMTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbl8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5xdWlja09wZW5fID0gZmFsc2U7XG5cbiAgICAvLyBBIGtleXVwIGV2ZW50IG9uIHRoZSBtZW51IG5lZWRzIHRvIGhhdmUgYSBjb3JyZXNwb25kaW5nIGtleWRvd25cbiAgICAvLyBldmVudCBvbiB0aGUgbWVudS4gSWYgdGhlIHVzZXIgb3BlbnMgdGhlIG1lbnUgd2l0aCBhIGtleWRvd24gZXZlbnQgb24gYVxuICAgIC8vIGJ1dHRvbiwgdGhlIG1lbnUgd2lsbCBvbmx5IGdldCB0aGUga2V5IHVwIGV2ZW50IGNhdXNpbmcgYnVnZ3kgYmVoYXZpb3Igd2l0aCBzZWxlY3RlZCBlbGVtZW50cy5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBmYWxzZTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3Qge1JPT1QsIE9QRU59ID0gTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzTmVjZXNzYXJ5RG9tKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgRE9NIG5vZGVzIG1pc3NpbmcgaW4gJHtST09UfSBjb21wb25lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoT1BFTikpIHtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfKTtcbiAgICAvLyBDYW5jZWwgYW55IGN1cnJlbnRseSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcih0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ29ybmVyfSBjb3JuZXIgRGVmYXVsdCBhbmNob3IgY29ybmVyIGFsaWdubWVudCBvZiB0b3AtbGVmdCBtZW51IGNvcm5lci5cbiAgICovXG4gIHNldEFuY2hvckNvcm5lcihjb3JuZXIpIHtcbiAgICB0aGlzLmFuY2hvckNvcm5lcl8gPSBjb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQW5jaG9yTWFyZ2lufSBtYXJnaW4gNC1wbGV0IG9mIG1hcmdpbnMgZnJvbSBhbmNob3IuXG4gICAqL1xuICBzZXRBbmNob3JNYXJnaW4obWFyZ2luKSB7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnRvcCA9IHR5cGVvZiBtYXJnaW4udG9wID09PSAnbnVtYmVyJyA/IG1hcmdpbi50b3AgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA9IHR5cGVvZiBtYXJnaW4ucmlnaHQgPT09ICdudW1iZXInID8gbWFyZ2luLnJpZ2h0IDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tID0gdHlwZW9mIG1hcmdpbi5ib3R0b20gPT09ICdudW1iZXInID8gbWFyZ2luLmJvdHRvbSA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQgPSB0eXBlb2YgbWFyZ2luLmxlZnQgPT09ICdudW1iZXInID8gbWFyZ2luLmxlZnQgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtZW1iZXJTZWxlY3Rpb24gKi9cbiAgc2V0UmVtZW1iZXJTZWxlY3Rpb24ocmVtZW1iZXJTZWxlY3Rpb24pIHtcbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyA9IHJlbWVtYmVyU2VsZWN0aW9uO1xuICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleCgtMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBxdWlja09wZW4gKi9cbiAgc2V0UXVpY2tPcGVuKHF1aWNrT3Blbikge1xuICAgIHRoaXMucXVpY2tPcGVuXyA9IHF1aWNrT3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9udW1iZXJ9IGZvY3VzSW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvY3VzT25PcGVuXyhmb2N1c0luZGV4KSB7XG4gICAgaWYgKGZvY3VzSW5kZXggPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaW5zdGFuY2Ugb2YgTURDTWVudSByZW1lbWJlcnMgc2VsZWN0aW9ucywgYW5kIHRoZSB1c2VyIGhhc1xuICAgICAgLy8gbWFkZSBhIHNlbGVjdGlvbiwgdGhlbiBmb2N1cyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtXG4gICAgICBpZiAodGhpcy5yZW1lbWJlclNlbGVjdGlvbl8gJiYgdGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gICAgICAvLyBJZiB0aGF0IGRvZXNuJ3Qgd29yaywgZm9jdXMgZmlyc3QgaXRlbSBpbnN0ZWFkLlxuICAgICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCgwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGZvY3VzSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIGFuZCBjYW5jZWwgdGhlIG1lbnUgaWYgbm90IGEgY2hpbGQgbGlzdC1pdGVtXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZURvY3VtZW50Q2xpY2tfKGV2dCkge1xuICAgIGxldCBlbCA9IGV2dC50YXJnZXQ7XG5cbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhGb3JFdmVudFRhcmdldChlbCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNhbmNlbCgpO1xuICAgIHRoaXMuY2xvc2UoZXZ0KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGtleXMgdGhhdCB3ZSB3YW50IHRvIHJlcGVhdCBvbiBob2xkICh0YWIgYW5kIGFycm93cykuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUtleWJvYXJkRG93bl8oZXZ0KSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBBbHQsIEN0cmwgb3IgTWV0YSBhcmUgcHJlc3NlZC5cbiAgICBpZiAoZXZ0LmFsdEtleSB8fCBldnQuY3RybEtleSB8fCBldnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qge2tleUNvZGUsIGtleSwgc2hpZnRLZXl9ID0gZXZ0O1xuICAgIGNvbnN0IGlzVGFiID0ga2V5ID09PSAnVGFiJyB8fCBrZXlDb2RlID09PSA5O1xuICAgIGNvbnN0IGlzQXJyb3dVcCA9IGtleSA9PT0gJ0Fycm93VXAnIHx8IGtleUNvZGUgPT09IDM4O1xuICAgIGNvbnN0IGlzQXJyb3dEb3duID0ga2V5ID09PSAnQXJyb3dEb3duJyB8fCBrZXlDb2RlID09PSA0MDtcbiAgICBjb25zdCBpc1NwYWNlID0ga2V5ID09PSAnU3BhY2UnIHx8IGtleUNvZGUgPT09IDMyO1xuICAgIGNvbnN0IGlzRW50ZXIgPSBrZXkgPT09ICdFbnRlcicgfHwga2V5Q29kZSA9PT0gMTM7XG4gICAgLy8gVGhlIG1lbnUgbmVlZHMgdG8ga25vdyBpZiB0aGUga2V5ZG93biBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIHRoZSBtZW51XG4gICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBpc0VudGVyIHx8IGlzU3BhY2U7XG5cbiAgICBjb25zdCBmb2N1c2VkSXRlbUluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2VkSXRlbUluZGV4KCk7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZJdGVtcygpIC0gMTtcblxuICAgIGlmIChzaGlmdEtleSAmJiBpc1RhYiAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgobGFzdEl0ZW1JbmRleCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXNoaWZ0S2V5ICYmIGlzVGFiICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IGxhc3RJdGVtSW5kZXgpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCgwKTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBBcnJvd3tVcCxEb3dufSBhbmQgc3BhY2UgZG8gbm90IGNhdXNlIGluYWR2ZXJ0ZW50IHNjcm9sbGluZ1xuICAgIGlmIChpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24gfHwgaXNTcGFjZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyb3dVcCkge1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPT09IDAgfHwgdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgobGFzdEl0ZW1JbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNlZEl0ZW1JbmRleCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJvd0Rvd24pIHtcbiAgICAgIGlmIChmb2N1c2VkSXRlbUluZGV4ID09PSBsYXN0SXRlbUluZGV4IHx8IHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGZvY3VzZWRJdGVtSW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gcmVwZWF0IG9uIGhvbGQgKEVudGVyLCBTcGFjZSwgRXNjYXBlKS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlS2V5Ym9hcmRVcF8oZXZ0KSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBBbHQsIEN0cmwgb3IgTWV0YSBhcmUgcHJlc3NlZC5cbiAgICBpZiAoZXZ0LmFsdEtleSB8fCBldnQuY3RybEtleSB8fCBldnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qge2tleUNvZGUsIGtleX0gPSBldnQ7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICBjb25zdCBpc1NwYWNlID0ga2V5ID09PSAnU3BhY2UnIHx8IGtleUNvZGUgPT09IDMyO1xuICAgIGNvbnN0IGlzRXNjYXBlID0ga2V5ID09PSAnRXNjYXBlJyB8fCBrZXlDb2RlID09PSAyNztcblxuICAgIGlmIChpc0VudGVyIHx8IGlzU3BhY2UpIHtcbiAgICAgIC8vIElmIHRoZSBrZXlkb3duIGV2ZW50IGRpZG4ndCBvY2N1ciBvbiB0aGUgbWVudSwgdGhlbiBpdCBzaG91bGRcbiAgICAgIC8vIGRpc3JlZ2FyZCB0aGUgcG9zc2libGUgc2VsZWN0ZWQgZXZlbnQuXG4gICAgICBpZiAodGhpcy5rZXlEb3duV2l0aGluTWVudV8pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNFc2NhcGUpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQoZXZ0LnRhcmdldCwgc3RyaW5ncy5BUklBX0RJU0FCTEVEX0FUVFIpID09PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEluZGV4Rm9yRXZlbnRUYXJnZXQoZXZ0LnRhcmdldCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBzZWxlY3Rpb25zXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IDA7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBpZiAodGhpcy5yZW1lbWJlclNlbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KHRhcmdldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoe2luZGV4OiB0YXJnZXRJbmRleH0pO1xuICAgIH0sIG51bWJlcnMuU0VMRUNURURfVFJJR0dFUl9ERUxBWSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXV0b0xheW91dE1lYXN1cmVtZW50c30gTWVhc3VyZW1lbnRzIHVzZWQgdG8gcG9zaXRpb24gbWVudSBwb3B1cC5cbiAgICovXG4gIGdldEF1dG9MYXlvdXRNZWFzdXJlbWVudHNfKCkge1xuICAgIGNvbnN0IGFuY2hvclJlY3QgPSB0aGlzLmFkYXB0ZXJfLmdldEFuY2hvckRpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93RGltZW5zaW9ucygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2U6IHtcbiAgICAgICAgdG9wOiBhbmNob3JSZWN0LnRvcCxcbiAgICAgICAgcmlnaHQ6IHZpZXdwb3J0LndpZHRoIC0gYW5jaG9yUmVjdC5yaWdodCxcbiAgICAgICAgbGVmdDogYW5jaG9yUmVjdC5sZWZ0LFxuICAgICAgICBib3R0b206IHZpZXdwb3J0LmhlaWdodCAtIGFuY2hvclJlY3QuYm90dG9tLFxuICAgICAgfSxcbiAgICAgIGFuY2hvckhlaWdodDogYW5jaG9yUmVjdC5oZWlnaHQsXG4gICAgICBhbmNob3JXaWR0aDogYW5jaG9yUmVjdC53aWR0aCxcbiAgICAgIG1lbnVIZWlnaHQ6IHRoaXMuZGltZW5zaW9uc18uaGVpZ2h0LFxuICAgICAgbWVudVdpZHRoOiB0aGlzLmRpbWVuc2lvbnNfLndpZHRoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGNvcm5lciBvZiB0aGUgYW5jaG9yIGZyb20gd2hpY2ggdG8gYW5pbWF0ZSBhbmQgcG9zaXRpb24gdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge0Nvcm5lcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE9yaWdpbkNvcm5lcl8oKSB7XG4gICAgLy8gRGVmYXVsdHM6IG9wZW4gZnJvbSB0aGUgdG9wIGxlZnQuXG4gICAgbGV0IGNvcm5lciA9IENvcm5lci5UT1BfTEVGVDtcblxuICAgIGNvbnN0IHt2aWV3cG9ydERpc3RhbmNlLCBhbmNob3JIZWlnaHQsIGFuY2hvcldpZHRoLCBtZW51SGVpZ2h0LCBtZW51V2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNCb3R0b21BbGlnbmVkID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBjb25zdCBhdmFpbGFibGVUb3AgPSBpc0JvdHRvbUFsaWduZWQgPyB2aWV3cG9ydERpc3RhbmNlLnRvcCArIGFuY2hvckhlaWdodCArIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b21cbiAgICAgIDogdmlld3BvcnREaXN0YW5jZS50b3AgKyB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJvdHRvbSA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tIC0gdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG5cbiAgICBjb25zdCB0b3BPdmVyZmxvdyA9IG1lbnVIZWlnaHQgLSBhdmFpbGFibGVUb3A7XG4gICAgY29uc3QgYm90dG9tT3ZlcmZsb3cgPSBtZW51SGVpZ2h0IC0gYXZhaWxhYmxlQm90dG9tO1xuICAgIGlmIChib3R0b21PdmVyZmxvdyA+IDAgJiYgdG9wT3ZlcmZsb3cgPCBib3R0b21PdmVyZmxvdykge1xuICAgICAgY29ybmVyIHw9IENvcm5lckJpdC5CT1RUT007XG4gICAgfVxuXG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG4gICAgY29uc3QgaXNGbGlwUnRsID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuRkxJUF9SVEwpO1xuICAgIGNvbnN0IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgY29uc3QgaXNBbGlnbmVkUmlnaHQgPSAoYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiAhaXNSdGwpIHx8XG4gICAgICAoIWF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgJiYgaXNGbGlwUnRsICYmIGlzUnRsKTtcbiAgICBjb25zdCBhdmFpbGFibGVMZWZ0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLmxlZnQgKyBhbmNob3JXaWR0aCArIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6XG4gICAgICB2aWV3cG9ydERpc3RhbmNlLmxlZnQgKyB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcbiAgICBjb25zdCBhdmFpbGFibGVSaWdodCA9IGlzQWxpZ25lZFJpZ2h0ID8gdmlld3BvcnREaXN0YW5jZS5yaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6XG4gICAgICB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0ICsgYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcblxuICAgIGNvbnN0IGxlZnRPdmVyZmxvdyA9IG1lbnVXaWR0aCAtIGF2YWlsYWJsZUxlZnQ7XG4gICAgY29uc3QgcmlnaHRPdmVyZmxvdyA9IG1lbnVXaWR0aCAtIGF2YWlsYWJsZVJpZ2h0O1xuXG4gICAgaWYgKChsZWZ0T3ZlcmZsb3cgPCAwICYmIGlzQWxpZ25lZFJpZ2h0ICYmIGlzUnRsKSB8fFxuICAgICAgICAoYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiAhaXNBbGlnbmVkUmlnaHQgJiYgbGVmdE92ZXJmbG93IDwgMCkgfHxcbiAgICAgICAgKHJpZ2h0T3ZlcmZsb3cgPiAwICYmIGxlZnRPdmVyZmxvdyA8IHJpZ2h0T3ZlcmZsb3cpKSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LlJJR0hUO1xuICAgIH1cblxuICAgIHJldHVybiBjb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvcml6b250YWwgb2Zmc2V0IG9mIG1lbnUgb3JpZ2luIGNvcm5lciBmcm9tIGNvcnJlc3BvbmRpbmcgYW5jaG9yIGNvcm5lci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcikge1xuICAgIGNvbnN0IHthbmNob3JXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc1JpZ2h0QWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBhdm9pZEhvcml6b250YWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGxldCB4ID0gMDtcbiAgICBpZiAoaXNSaWdodEFsaWduZWQpIHtcbiAgICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA/IGFuY2hvcldpZHRoIC0gdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQgOiB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQ7XG4gICAgICB4ID0gcmlnaHRPZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQgOiB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcbiAgICAgIHggPSBsZWZ0T2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVmVydGljYWwgb2Zmc2V0IG9mIG1lbnUgb3JpZ2luIGNvcm5lciBmcm9tIGNvcnJlc3BvbmRpbmcgYW5jaG9yIGNvcm5lci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpIHtcbiAgICBjb25zdCB7dmlld3BvcnQsIHZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgbWVudUhlaWdodH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IHtNQVJHSU5fVE9fRURHRX0gPSBNRENNZW51Rm91bmRhdGlvbi5udW1iZXJzO1xuICAgIGNvbnN0IGF2b2lkVmVydGljYWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBjb25zdCBjYW5PdmVybGFwVmVydGljYWxseSA9ICFhdm9pZFZlcnRpY2FsT3ZlcmxhcDtcbiAgICBsZXQgeSA9IDA7XG5cbiAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICB5ID0gYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPyBhbmNob3JIZWlnaHQgLSB0aGlzLmFuY2hvck1hcmdpbl8udG9wIDogLXRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b207XG4gICAgICAvLyBhZGp1c3QgZm9yIHdoZW4gbWVudSBjYW4gb3ZlcmxhcCBhbmNob3IsIGJ1dCB0b28gdGFsbCB0byBiZSBhbGlnbmVkIHRvIGJvdHRvbVxuICAgICAgLy8gYW5jaG9yIGNvcm5lci4gQm90dG9tIG1hcmdpbiBpcyBpZ25vcmVkIGluIHN1Y2ggY2FzZXMuXG4gICAgICBpZiAoY2FuT3ZlcmxhcFZlcnRpY2FsbHkgJiYgbWVudUhlaWdodCA+IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0KSB7XG4gICAgICAgIHkgPSAtKE1hdGgubWluKG1lbnVIZWlnaHQsIHZpZXdwb3J0LmhlaWdodCAtIE1BUkdJTl9UT19FREdFKSAtICh2aWV3cG9ydERpc3RhbmNlLnRvcCArIGFuY2hvckhlaWdodCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPyAoYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbSkgOiB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuICAgICAgLy8gYWRqdXN0IGZvciB3aGVuIG1lbnUgY2FuIG92ZXJsYXAgYW5jaG9yLCBidXQgdG9vIHRhbGwgdG8gYmUgYWxpZ25lZCB0byB0b3BcbiAgICAgIC8vIGFuY2hvciBjb3JuZXJzLiBUb3AgbWFyZ2luIGlzIGlnbm9yZWQgaW4gdGhhdCBjYXNlLlxuICAgICAgaWYgKGNhbk92ZXJsYXBWZXJ0aWNhbGx5ICYmIG1lbnVIZWlnaHQgPiB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCkge1xuICAgICAgICB5ID0gLShNYXRoLm1pbihtZW51SGVpZ2h0LCB2aWV3cG9ydC5oZWlnaHQgLSBNQVJHSU5fVE9fRURHRSkgLSAodmlld3BvcnREaXN0YW5jZS5ib3R0b20gKyBhbmNob3JIZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heGltdW0gaGVpZ2h0IG9mIHRoZSBtZW51LCBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2UuIDAgaW5kaWNhdGVzIHNob3VsZCBub3QgYmUgc2V0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWVudU1heEhlaWdodF8oY29ybmVyKSB7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2V9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNCb3R0b21BbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuQk9UVE9NKTtcblxuICAgIC8vIFdoZW4gbWF4aW11bSBoZWlnaHQgaXMgbm90IHNwZWNpZmllZCwgaXQgaXMgaGFuZGxlZCBmcm9tIGNzcy5cbiAgICBpZiAodGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSkge1xuICAgICAgaWYgKGlzQm90dG9tQWxpZ25lZCkge1xuICAgICAgICBtYXhIZWlnaHQgPSB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhIZWlnaHQgPSB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSAtIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b207XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heEhlaWdodDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhdXRvUG9zaXRpb25fKCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNBbmNob3IoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgbWVhc3VyZW1lbnRzIGZvciBhdXRvcG9zaXRpb24gbWV0aG9kcyByZXVzZS5cbiAgICB0aGlzLm1lYXN1cmVzXyA9IHRoaXMuZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKTtcblxuICAgIGNvbnN0IGNvcm5lciA9IHRoaXMuZ2V0T3JpZ2luQ29ybmVyXygpO1xuICAgIGNvbnN0IG1heE1lbnVIZWlnaHQgPSB0aGlzLmdldE1lbnVNYXhIZWlnaHRfKGNvcm5lcik7XG4gICAgbGV0IHZlcnRpY2FsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICBsZXQgaG9yaXpvbnRhbEFsaWdubWVudCA9IChjb3JuZXIgJiBDb3JuZXJCaXQuUklHSFQpID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICBjb25zdCBob3Jpem9udGFsT2Zmc2V0ID0gdGhpcy5nZXRIb3Jpem9udGFsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGNvbnN0IHZlcnRpY2FsT2Zmc2V0ID0gdGhpcy5nZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8oY29ybmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgIFtob3Jpem9udGFsQWxpZ25tZW50XTogaG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXQgKyAncHgnIDogJzAnLFxuICAgICAgW3ZlcnRpY2FsQWxpZ25tZW50XTogdmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldCArICdweCcgOiAnMCcsXG4gICAgfTtcbiAgICBjb25zdCB7YW5jaG9yV2lkdGgsIG1lbnVIZWlnaHQsIG1lbnVXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICAvLyBDZW50ZXIgYWxpZ24gd2hlbiBhbmNob3Igd2lkdGggaXMgY29tcGFyYWJsZSBvciBncmVhdGVyIHRoYW4gbWVudSwgb3RoZXJ3aXNlIGtlZXAgY29ybmVyLlxuICAgIGlmIChhbmNob3JXaWR0aCAvIG1lbnVXaWR0aCA+IG51bWJlcnMuQU5DSE9SX1RPX01FTlVfV0lEVEhfUkFUSU8pIHtcbiAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdmVydGljYWwgb3JpZ2luIHdoZW4gbWVudSBpcyBwb3NpdGlvbmVkIHdpdGggc2lnbmlmaWNhbnQgb2Zmc2V0IGZyb20gYW5jaG9yLiBUaGlzIGlzIGRvbmUgc28gdGhhdFxuICAgIC8vIHNjYWxlIGFuaW1hdGlvbiBpcyBcImFuY2hvcmVkXCIgb24gdGhlIGFuY2hvci5cbiAgICBpZiAoISh0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKSAmJlxuICAgICAgICBNYXRoLmFicyh2ZXJ0aWNhbE9mZnNldCAvIG1lbnVIZWlnaHQpID4gbnVtYmVycy5PRkZTRVRfVE9fTUVOVV9IRUlHSFRfUkFUSU8pIHtcbiAgICAgIGNvbnN0IHZlcnRpY2FsT2Zmc2V0UGVyY2VudCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0IC8gbWVudUhlaWdodCkgKiAxMDA7XG4gICAgICBjb25zdCBvcmlnaW5QZXJjZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pID8gMTAwIC0gdmVydGljYWxPZmZzZXRQZXJjZW50IDogdmVydGljYWxPZmZzZXRQZXJjZW50O1xuICAgICAgdmVydGljYWxBbGlnbm1lbnQgPSBNYXRoLnJvdW5kKG9yaWdpblBlcmNlbnQgKiAxMDApIC8gMTAwICsgJyUnO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNmb3JtT3JpZ2luKGAke2hvcml6b250YWxBbGlnbm1lbnR9ICR7dmVydGljYWxBbGlnbm1lbnR9YCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNYXhIZWlnaHQobWF4TWVudUhlaWdodCA/IG1heE1lbnVIZWlnaHQgKyAncHgnIDogJycpO1xuXG4gICAgLy8gQ2xlYXIgbWVhc3VyZXMgYWZ0ZXIgcG9zaXRpb25pbmcgaXMgY29tcGxldGUuXG4gICAgdGhpcy5tZWFzdXJlc18gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7e2ZvY3VzSW5kZXg6ID9udW1iZXJ9PX0gb3B0aW9uc1xuICAgKi9cbiAgb3Blbih7Zm9jdXNJbmRleCA9IG51bGx9ID0ge30pIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNhdmVGb2N1cygpO1xuXG4gICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfT1BFTik7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuZGltZW5zaW9uc18gPSB0aGlzLmFkYXB0ZXJfLmdldElubmVyRGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5hdXRvUG9zaXRpb25fKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gICAgICB0aGlzLmZvY3VzT25PcGVuXyhmb2N1c0luZGV4KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfT1BFTik7XG4gICAgICAgIH0sIG51bWJlcnMuVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2dFxuICAgKi9cbiAgY2xvc2UoZXZ0ID0gbnVsbCkge1xuICAgIGNvbnN0IHRhcmdldElzRGlzYWJsZWQgPSBldnQgP1xuICAgICAgdGhpcy5hZGFwdGVyXy5nZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldChldnQudGFyZ2V0LCBzdHJpbmdzLkFSSUFfRElTQUJMRURfQVRUUikgPT09ICd0cnVlJyA6XG4gICAgICBmYWxzZTtcblxuICAgIGlmICh0YXJnZXRJc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcih0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyk7XG5cbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gICAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfQ0xPU0VEKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlc3RvcmVGb2N1cygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0U2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGl0ZW0gdG8gc2V0IGFzIHNlbGVjdGVkLlxuICAgKi9cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgICBpZiAocHJldlNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUF0dHJGb3JPcHRpb25BdEluZGV4KHByZXZTZWxlY3RlZEluZGV4LCAnYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUNsYXNzRm9yT3B0aW9uQXRJbmRleChwcmV2U2VsZWN0ZWRJbmRleCwgY3NzQ2xhc3Nlcy5TRUxFQ1RFRF9MSVNUX0lURU0pO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZkl0ZW1zKCkgPyBpbmRleCA6IC0xO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0ckZvck9wdGlvbkF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4XywgJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4XywgY3NzQ2xhc3Nlcy5TRUxFQ1RFRF9MSVNUX0lURU0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge01EQ01lbnVGb3VuZGF0aW9uLCBBbmNob3JNYXJnaW59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAcGFyYW0geyFXaW5kb3d9IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnd2Via2l0VHJhbnNmb3JtJyk7XG4gICAgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9IHRyYW5zZm9ybVByb3BlcnR5TmFtZTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xufVxuXG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gdGhlIG1pbmltdW0gYW5kIHRoZSBtYXhpbXVtLCByZXR1cm5pbmcgdGhlIGNsYW1wZWQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWFzaW5nIHZhbHVlIHRvIGFwcGx5IGF0IHRpbWUgdCwgZm9yIGEgZ2l2ZW4gY3ViaWMgYmV6aWVyIGN1cnZlLlxuICogQ29udHJvbCBwb2ludHMgUDAgYW5kIFAzIGFyZSBhc3N1bWVkIHRvIGJlICgwLDApIGFuZCAoMSwxKSwgcmVzcGVjdGl2ZWx5LlxuICogUGFyYW1ldGVycyBhcmUgYXMgZm9sbG93czpcbiAqIC0gdGltZTogVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgYW5pbWF0aW9uLCBzY2FsZWQgYmV0d2VlbiAwIGFuZCAxLlxuICogLSB4MTogVGhlIHggdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMS5cbiAqIC0geTE6IFRoZSB5IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDEuXG4gKiAtIHgyOiBUaGUgeCB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAyLlxuICogLSB5MjogVGhlIHkgdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYmV6aWVyUHJvZ3Jlc3ModGltZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIGdldEJlemllckNvb3JkaW5hdGVfKHNvbHZlUG9zaXRpb25Gcm9tWFZhbHVlXyh0aW1lLCB4MSwgeDIpLCB5MSwgeTIpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgYSBzaW5nbGUgY29vcmRpbmF0ZSBhdCBhIHBvc2l0aW9uIHBvaW50IGJldHdlZW4gMCBhbmQgMS5cbiAqIGMxIGFuZCBjMiBhcmUgdGhlIG1hdGNoaW5nIGNvb3JkaW5hdGUgb24gY29udHJvbCBwb2ludHMgUDEgYW5kIFAyLCByZXNwZWN0aXZlbHkuXG4gKiBDb250cm9sIHBvaW50cyBQMCBhbmQgUDMgYXJlIGFzc3VtZWQgdG8gYmUgKDAsMCkgYW5kICgxLDEpLCByZXNwZWN0aXZlbHkuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvYmV6aWVyLmpzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMVxuICogQHBhcmFtIHtudW1iZXJ9IGMyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJlemllckNvb3JkaW5hdGVfKHQsIGMxLCBjMikge1xuICAvLyBTcGVjaWFsIGNhc2Ugc3RhcnQgYW5kIGVuZC5cbiAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLy8gU3RlcCBvbmUgLSBmcm9tIDQgcG9pbnRzIHRvIDNcbiAgbGV0IGljMCA9IHQgKiBjMTtcbiAgbGV0IGljMSA9IGMxICsgdCAqIChjMiAtIGMxKTtcbiAgY29uc3QgaWMyID0gYzIgKyB0ICogKDEgLSBjMik7XG5cbiAgLy8gU3RlcCB0d28gLSBmcm9tIDMgcG9pbnRzIHRvIDJcbiAgaWMwICs9IHQgKiAoaWMxIC0gaWMwKTtcbiAgaWMxICs9IHQgKiAoaWMyIC0gaWMxKTtcblxuICAvLyBGaW5hbCBzdGVwIC0gbGFzdCBwb2ludFxuICByZXR1cm4gaWMwICsgdCAqIChpYzEgLSBpYzApO1xufVxuXG4vKipcbiAqIFByb2plY3QgYSBwb2ludCBvbnRvIHRoZSBCZXppZXIgY3VydmUsIGZyb20gYSBnaXZlbiBYLiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiB0IGFsb25nIHRoZSBjdXJ2ZS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9iZXppZXIuanMuXG4gKiBAcGFyYW0ge251bWJlcn0geFZhbFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc29sdmVQb3NpdGlvbkZyb21YVmFsdWVfKHhWYWwsIHgxLCB4Mikge1xuICBjb25zdCBFUFNJTE9OID0gMWUtNjtcbiAgY29uc3QgTUFYX0lURVJBVElPTlMgPSA4O1xuXG4gIGlmICh4VmFsIDw9IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh4VmFsID49IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUgb2YgdCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAgbGV0IHQgPSB4VmFsO1xuXG4gIC8vIFRyeSBncmFkaWVudCBkZXNjZW50IHRvIHNvbHZlIGZvciB0LiBJZiBpdCB3b3JrcywgaXQgaXMgdmVyeSBmYXN0LlxuICBsZXQgdE1pbiA9IDA7XG4gIGxldCB0TWF4ID0gMTtcbiAgbGV0IHZhbHVlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgdmFsdWUgPSBnZXRCZXppZXJDb29yZGluYXRlXyh0LCB4MSwgeDIpO1xuICAgIGNvbnN0IGRlcml2YXRpdmUgPSAoZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCArIEVQU0lMT04sIHgxLCB4MikgLSB2YWx1ZSkgLyBFUFNJTE9OO1xuICAgIGlmIChNYXRoLmFicyh2YWx1ZSAtIHhWYWwpIDwgRVBTSUxPTikge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZXJpdmF0aXZlKSA8IEVQU0lMT04pIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPCB4VmFsKSB7XG4gICAgICAgIHRNaW4gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdE1heCA9IHQ7XG4gICAgICB9XG4gICAgICB0IC09ICh2YWx1ZSAtIHhWYWwpIC8gZGVyaXZhdGl2ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZ3JhZGllbnQgZGVzY2VudCBnb3Qgc3R1Y2sgaW4gYSBsb2NhbCBtaW5pbXVtLCBlLmcuIGJlY2F1c2VcbiAgLy8gdGhlIGRlcml2YXRpdmUgd2FzIGNsb3NlIHRvIDAsIHVzZSBhIERpY2hvdG9teSByZWZpbmVtZW50IGluc3RlYWQuXG4gIC8vIFdlIGxpbWl0IHRoZSBudW1iZXIgb2YgaW50ZXJhdGlvbnMgdG8gOC5cbiAgZm9yIChsZXQgaSA9IDA7IE1hdGguYWJzKHZhbHVlIC0geFZhbCkgPiBFUFNJTE9OICYmIGkgPCBNQVhfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgaWYgKHZhbHVlIDwgeFZhbCkge1xuICAgICAgdE1pbiA9IHQ7XG4gICAgICB0ID0gKHQgKyB0TWF4KSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRNYXggPSB0O1xuICAgICAgdCA9ICh0ICsgdE1pbikgLyAyO1xuICAgIH1cbiAgICB2YWx1ZSA9IGdldEJlemllckNvb3JkaW5hdGVfKHQsIHgxLCB4Mik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCB7Z2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lLCBjbGFtcCwgYmV6aWVyUHJvZ3Jlc3N9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1tZW51IG1kYy1zaW1wbGUtbWVudVwiXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIHRhYmluZGV4PVwiLTFcIj5cbiAgICA8dWwgcmVmPVwiaXRlbXNcIiBjbGFzcz1cIm1kYy1zaW1wbGUtbWVudV9faXRlbXMgbWRjLWxpc3RcIiBcbiAgICAgIHJvbGU9XCJtZW51XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudUZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uJztcbmltcG9ydCB7IGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9tZW51L3V0aWwnO1xuaW1wb3J0IHsgZW1pdEN1c3RvbUV2ZW50IH0gZnJvbSAnLi4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51JyxcbiAgcHJvcHM6IHtcbiAgICAnb3Blbi1mcm9tLXRvcC1sZWZ0JzogQm9vbGVhbixcbiAgICAnb3Blbi1mcm9tLXRvcC1yaWdodCc6IEJvb2xlYW4sXG4gICAgJ29wZW4tZnJvbS1ib3R0b20tbGVmdCc6IEJvb2xlYW4sXG4gICAgJ29wZW4tZnJvbS1ib3R0b20tcmlnaHQnOiBCb29sZWFuLFxuICAgICdxdWljay1vcGVuJzogQm9vbGVhbixcbiAgICAnYW5jaG9yLWNvcm5lcic6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgJ2FuY2hvci1tYXJnaW4nOiBPYmplY3QsXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zaW1wbGUtbWVudS0tb3Blbi1mcm9tLXRvcC1sZWZ0JzogdGhpcy5vcGVuRnJvbVRvcExlZnQsXG4gICAgICAgICdtZGMtc2ltcGxlLW1lbnUtLW9wZW4tZnJvbS10b3AtcmlnaHQnOiB0aGlzLm9wZW5Gcm9tVG9wUmlnaHQsXG4gICAgICAgICdtZGMtc2ltcGxlLW1lbnUtLW9wZW4tZnJvbS1ib3R0b20tbGVmdCc6IHRoaXMub3BlbkZyb21Cb3R0b21MZWZ0LFxuICAgICAgICAnbWRjLXNpbXBsZS1tZW51LS1vcGVuLWZyb20tYm90dG9tLXJpZ2h0JzogdGhpcy5vcGVuRnJvbUJvdHRvbVJpZ2h0LFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpdGVtczogW10sXG4gICAgfTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNob3cob3B0aW9ucykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4ob3B0aW9ucyk7XG4gICAgfSxcbiAgICBoaWRlKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKCk7XG4gICAgfSxcbiAgICBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uID8gdGhpcy5mb3VuZGF0aW9uLmlzT3BlbigpIDogZmFsc2U7XG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCByZWZyZXNoSXRlbXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1zID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kcmVmcy5pdGVtcy5xdWVyeVNlbGVjdG9yQWxsKCcubWRjLWxpc3QtaXRlbVtyb2xlXScpLFxuICAgICAgKTtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZScpO1xuICAgIH07XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiByZWZyZXNoSXRlbXMoKSk7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG5cbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBCb29sZWFuKHRoaXMuJHJlZnMuaXRlbXMpLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpID0+XG4gICAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB0aGlzLiRyZWZzLml0ZW1zLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuJHJlZnMuaXRlbXMub2Zmc2V0SGVpZ2h0LFxuICAgICAgfSksXG4gICAgICBoYXNBbmNob3I6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbWRjLW1lbnUtYW5jaG9yJyksXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICB9KSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiB0YXJnZXQgPT4gdGhpcy5pdGVtcy5pbmRleE9mKHRhcmdldCksXG4gICAgICBub3RpZnlTZWxlY3RlZDogZXZ0RGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IGV2dCA9IHtcbiAgICAgICAgICBpbmRleDogZXZ0RGF0YS5pbmRleCxcbiAgICAgICAgICBpdGVtOiB0aGlzLml0ZW1zW2V2dERhdGEuaW5kZXhdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBldnQpO1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcbiAgICAgICAgICBldnQsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NhbmNlbCcpO1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQodGhpcy4kZWwsIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB7fSk7XG4gICAgICB9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHJlc3RvcmVGb2N1czogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNGb2N1cykge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy4kcmVmcy5yb290LFxuICAgICAgZm9jdXM6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5mb2N1cygpLFxuICAgICAgZ2V0Rm9jdXNlZEl0ZW1JbmRleDogKCkgPT4gdGhpcy5pdGVtcy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogaW5kZXggPT4gdGhpcy5pdGVtc1tpbmRleF0uZm9jdXMoKSxcbiAgICAgIGlzUnRsOiAoKSA9PlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMucm9vdCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09XG4gICAgICAgICdydGwnLFxuICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4gPT4ge1xuICAgICAgICB0aGlzLiRzZXQoXG4gICAgICAgICAgdGhpcy5zdHlsZXMsXG4gICAgICAgICAgYCR7Z2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKHdpbmRvdyl9LW9yaWdpbmAsXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNldFBvc2l0aW9uOiBwb3NpdGlvbiA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ2xlZnQnLCBwb3NpdGlvbi5sZWZ0KTtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAncmlnaHQnLCBwb3NpdGlvbi5yaWdodCk7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3RvcCcsIHBvc2l0aW9uLnRvcCk7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ2JvdHRvbScsIHBvc2l0aW9uLmJvdHRvbSk7XG4gICAgICB9LFxuICAgICAgc2V0TWF4SGVpZ2h0OiBoZWlnaHQgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsICdtYXgtaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0cikgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9LFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZWZyZXNoSXRlbXMoKTtcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgIGlmICh0aGlzLmFuY2hvckNvcm5lciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QW5jaG9yQ29ybmVyKE51bWJlcih0aGlzLmFuY2hvckNvcm5lcikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3JNYXJnaW4gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbih0aGlzLmFuY2hvck1hcmdpbik7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHF1aWNrT3Blbihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFF1aWNrT3Blbihudik7XG4gICAgfSxcbiAgICBhbmNob3JDb3JuZXIobnYpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRBbmNob3JDb3JuZXIoTnVtYmVyKG52KSk7XG4gICAgfSxcbiAgICBhbmNob3JNYXJnaW4obnYpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRBbmNob3JNYXJnaW4obnYpO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IG51bGw7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBjbGFzcz1cIm1kYy1tZW51LWl0ZW0gbWRjLWxpc3QtaXRlbVwiIHJvbGU9XCJtZW51aXRlbVwiIFxuICAgIDp0YWJpbmRleD1cImRpc2FibGVkPyctMSc6JzAnXCJcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICA+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LWl0ZW0nLFxuICBwcm9wczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgcm9sZT1cInNlcGFyYXRvclwiIGNsYXNzPVwibWRjLW1lbnUtZGl2aWRlciBtZGMtbGlzdC1kaXZpZGVyXCI+PC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1kaXZpZGVyJyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuPGRpdiBjbGFzcz1cIm1kYy1tZW51LWFuY2hvclwiPlxuICA8c2xvdD5cbiAgPC9zbG90PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtYW5jaG9yJyxcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY01lbnUgZnJvbSAnLi9tZGMtbWVudS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQge1xuICBtZGNNZW51LFxuICBtZGNNZW51SXRlbSxcbiAgbWRjTWVudURpdmlkZXIsXG4gIG1kY01lbnVBbmNob3Jcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY01lbnUsXG4gIG1kY01lbnVJdGVtLFxuICBtZGNNZW51RGl2aWRlcixcbiAgbWRjTWVudUFuY2hvclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBSYWRpby4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmFkaW9BZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gKi9cbiAgZ2V0TmF0aXZlQ29udHJvbCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JhZGlvQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiAnLm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2wnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXJhZGlvJyxcbiAgRElTQUJMRUQ6ICdtZGMtcmFkaW8tLWRpc2FibGVkJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5pbXBvcnQgTURDUmFkaW9BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmFkaW9BZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDUmFkaW9Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDUmFkaW9BZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENSYWRpb0FkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gLyogIU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSAqLyB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDUmFkaW9Gb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWU7XG4gIH1cblxuICAvKiogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVDb250cm9sXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCkgfHwge1xuICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JhZGlvRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiIGNsYXNzPVwibWRjLXJhZGlvLXdyYXBwZXJcIj5cbiAgPGRpdiByZWY9XCJyb290XCIgY2xhc3M9XCJtZGMtcmFkaW9cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCI+XG4gICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIHJlZj1cImNvbnRyb2xcIiA6aWQ9XCJfdWlkXCIgOm5hbWU9XCJuYW1lXCIgXG4gICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIiBAY2hhbmdlPVwic3luY1wiPlxuICBcbiAgICA8ZGl2IHJlZj1cImxhYmVsXCIgY2xhc3M9XCJtZGMtcmFkaW9fX2JhY2tncm91bmRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1yYWRpb19faW5uZXItY2lyY2xlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8bGFiZWwgcmVmPVwibGFiZWxcIiA6Zm9yPVwiX3VpZFwiPjxzbG90Pnt7bGFiZWx9fTwvc2xvdD48L2xhYmVsPlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1JhZGlvRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmFkaW8vZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1yYWRpbycsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3BpY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ25hbWUnOiB7dHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZX0sXG4gICAgJ3ZhbHVlJzogU3RyaW5nLFxuICAgICdwaWNrZWQnOiBTdHJpbmcsXG4gICAgJ2NoZWNrZWQnOiBCb29sZWFuLFxuICAgICdsYWJlbCc6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnZGlzYWJsZWQnOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgZm9ybUZpZWxkQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmxhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMubGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgLy8gYWRkIGZvdW5kYXRpb25cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDUmFkaW9Gb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2xcbiAgICB9KVxuXG4gICAgLy8gYWRkIHJpcHBsZVxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvcm1GaWVsZCA9IG5ldyBNRENGb3JtRmllbGRGb3VuZGF0aW9uKHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVhY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIHRoaXMuZm9ybUZpZWxkLmluaXQoKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlIDogdGhpcy5sYWJlbClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh0aGlzLmNoZWNrZWQgfHwgdGhpcy5waWNrZWQgPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG5cbiAgICAvLyByZWZyZXNoIG1vZGVsXG4gICAgdGhpcy5jaGVja2VkICYmIHRoaXMuc3luYygpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm9ybUZpZWxkLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkaXNhYmxlZCAodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpc0NoZWNrZWQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKVxuICAgIH0sXG4gICAgc3luYyAoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JhZGlvIGZyb20gJy4vbWRjLXJhZGlvLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjUmFkaW9cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1JhZGlvXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8c2VsZWN0IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1zZWxlY3QgbWRjLW5hdGl2ZS1zZWxlY3RcIiBcbiAgICB2LW1vZGVsPVwic2VsZWN0ZWRcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgPlxuICAgIDxvcHRpb24gZGlzYWJsZWQgdmFsdWU9XCJcIiB2LWlmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvb3B0aW9uPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9zZWxlY3Q+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW5hdGl2ZS1zZWxlY3QnLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDogdGhpcy52YWx1ZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlICgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuc2VsZWN0ZWQpXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHZhbHVlIChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgIH0sXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBCT1g6ICdtZGMtc2VsZWN0LS1ib3gnLFxuICBESVNBQkxFRDogJ21kYy1zZWxlY3QtLWRpc2FibGVkJyxcbiAgT1BFTjogJ21kYy1zZWxlY3QtLW9wZW4nLFxuICBST09UOiAnbWRjLXNlbGVjdCcsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLXNlbGVjdC1zY3JvbGwtbG9jaycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hBTkdFX0VWRU5UOiAnTURDU2VsZWN0OmNoYW5nZScsXG4gIEJPVFRPTV9MSU5FX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX2JvdHRvbS1saW5lJyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLXNlbGVjdF9fbGFiZWwnLFxuICBNRU5VX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX21lbnUnLFxuICBTVVJGQUNFX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX3N1cmZhY2UnLFxuICBTRUxFQ1RFRF9URVhUX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHQnLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQge2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZX0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7TURDTWVudUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCB7Q29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ01lbnVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENNZW51IGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqIEBwYXJhbSB7Li4uP30gYXJncyAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgLyoqIEBwcml2YXRlIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnByZXZpb3VzRm9jdXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ01lbnV9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDTWVudShyb290KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5pc09wZW4oKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG4gIHNldCBvcGVuKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb25fLm9wZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uXy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmb2N1c0luZGV4OiA/bnVtYmVyfT19IG9wdGlvbnMgKi9cbiAgc2hvdyh7Zm9jdXNJbmRleCA9IG51bGx9ID0ge30pIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLm9wZW4oe2ZvY3VzSW5kZXg6IGZvY3VzSW5kZXh9KTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgRGVmYXVsdCBhbmNob3IgY29ybmVyIGFsaWdubWVudCBvZiB0b3AtbGVmdFxuICAgKiAgICAgbWVudSBjb3JuZXIuXG4gICAqL1xuICBzZXRBbmNob3JDb3JuZXIoY29ybmVyKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRBbmNob3JDb3JuZXIoY29ybmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuY2hvck1hcmdpbn0gbWFyZ2luXG4gICAqL1xuICBzZXRBbmNob3JNYXJnaW4obWFyZ2luKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRBbmNob3JNYXJnaW4obWFyZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGl0ZW0gY29udGFpbmVyIGVsZW1lbnQgaW5zaWRlIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fVxuICAgKi9cbiAgZ2V0IGl0ZW1zQ29udGFpbmVyXygpIHtcbiAgICByZXR1cm4gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuSVRFTVNfU0VMRUNUT1IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbXMgd2l0aGluIHRoZSBtZW51LiBOb3RlIHRoYXQgdGhpcyBvbmx5IGNvbnRhaW5zIHRoZSBzZXQgb2YgZWxlbWVudHMgd2l0aGluXG4gICAqIHRoZSBpdGVtcyBjb250YWluZXIgdGhhdCBhcmUgcHJvcGVyIGxpc3QgaXRlbXMsIGFuZCBub3Qgc3VwcGxlbWVudGFsIC8gcHJlc2VudGF0aW9uYWwgRE9NXG4gICAqIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIGNvbnN0IHtpdGVtc0NvbnRhaW5lcl86IGl0ZW1zQ29udGFpbmVyfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaXRlbXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLm1kYy1saXN0LWl0ZW1bcm9sZV0nKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIHdpdGhpbiB0aGUgbWVudSB0aGF0IGlzIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7P0VsZW1lbnR9XG4gICAqL1xuICBnZXRPcHRpb25CeUluZGV4KGluZGV4KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuXG4gICAgaWYgKGluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gaW5kZXggKi9cbiAgc2V0IHNlbGVjdGVkSXRlbUluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldCBzZWxlY3RlZEl0ZW1JbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5nZXRTZWxlY3RlZEluZGV4KCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshYm9vbGVhbn0gcmVtZW1iZXJTZWxlY3Rpb24gKi9cbiAgc2V0IHJlbWVtYmVyU2VsZWN0aW9uKHJlbWVtYmVyU2VsZWN0aW9uKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRSZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbik7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBxdWlja09wZW4gKi9cbiAgc2V0IHF1aWNrT3BlbihxdWlja09wZW4pIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFF1aWNrT3BlbihxdWlja09wZW4pO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENNZW51Rm91bmRhdGlvbn0gKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENNZW51Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gQm9vbGVhbih0aGlzLml0ZW1zQ29udGFpbmVyXyksXG4gICAgICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldDogKHRhcmdldCwgYXR0cmlidXRlTmFtZSkgPT4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgICBjb25zdCB7aXRlbXNDb250YWluZXJfOiBpdGVtc0NvbnRhaW5lcn0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge3dpZHRoOiBpdGVtc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBpdGVtc0NvbnRhaW5lci5vZmZzZXRIZWlnaHR9O1xuICAgICAgfSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gdGhpcy5yb290Xy5wYXJlbnRFbGVtZW50ICYmIHRoaXMucm9vdF8ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21kYy1tZW51LWFuY2hvcicpLFxuICAgICAgZ2V0QW5jaG9yRGltZW5zaW9uczogKCkgPT4gdGhpcy5yb290Xy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgICByZXR1cm4ge3dpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHR9O1xuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiB0aGlzLml0ZW1zLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoZXZ0RGF0YSkgPT4gdGhpcy5lbWl0KE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHtcbiAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgIGl0ZW06IHRoaXMuaXRlbXNbZXZ0RGF0YS5pbmRleF0sXG4gICAgICB9KSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4gdGhpcy5lbWl0KE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB7fSksXG4gICAgICBzYXZlRm9jdXM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzRm9jdXNfKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnJvb3RfLFxuICAgICAgZm9jdXM6ICgpID0+IHRoaXMucm9vdF8uZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IChpbmRleCkgPT4gdGhpcy5pdGVtc1tpbmRleF0uZm9jdXMoKSxcbiAgICAgIGlzUnRsOiAoKSA9PiBnZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdF8pLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogKG9yaWdpbikgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlW2Ake2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gXSA9IG9yaWdpbjtcbiAgICAgIH0sXG4gICAgICBzZXRQb3NpdGlvbjogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8uc3R5bGUubGVmdCA9ICdsZWZ0JyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLmxlZnQgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLnJpZ2h0ID0gJ3JpZ2h0JyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLnJpZ2h0IDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290Xy5zdHlsZS50b3AgPSAndG9wJyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLnRvcCA6IG51bGw7XG4gICAgICAgIHRoaXMucm9vdF8uc3R5bGUuYm90dG9tID0gJ2JvdHRvbScgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi5ib3R0b20gOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogKGhlaWdodCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLm1heEhlaWdodCA9IGhlaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4gdGhpcy5pdGVtc1tpbmRleF0uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0cikgPT4gdGhpcy5pdGVtc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4gdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB0aGlzLml0ZW1zW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENNZW51Rm91bmRhdGlvbiwgTURDTWVudSwgQW5jaG9yTWFyZ2luLCBDb3JuZXIsIENvcm5lckJpdH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtNRENNZW51Rm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL21lbnUvaW5kZXgnO1xuXG5jb25zdCBPUEVORVJfS0VZUyA9IFtcbiAge2tleTogJ0Fycm93VXAnLCBrZXlDb2RlOiAzOCwgZm9yVHlwZTogJ2tleWRvd24nfSxcbiAge2tleTogJ0Fycm93RG93bicsIGtleUNvZGU6IDQwLCBmb3JUeXBlOiAna2V5ZG93bid9LFxuICB7a2V5OiAnU3BhY2UnLCBrZXlDb2RlOiAzMiwgZm9yVHlwZTogJ2tleXVwJ30sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENTZWxlY3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoLyogdmFsdWU6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1BdHRyOiAoLyogYXR0cjogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSAqLyAoe2xlZnQ6IDAsIHRvcDogMH0pLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBmb2N1czogKCkgPT4ge30sXG4gICAgICBtYWtlVGFiYmFibGU6ICgpID0+IHt9LFxuICAgICAgbWFrZVVudGFiYmFibGU6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldFN0eWxlOiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY3JlYXRlMmRSZW5kZXJpbmdDb250ZXh0OiAoKSA9PiAvKiB7Zm9udDogc3RyaW5nLCBtZWFzdXJlVGV4dDogKHN0cmluZykgPT4ge3dpZHRoOiBudW1iZXJ9fSAqLyAoe1xuICAgICAgICBmb250OiAnJyxcbiAgICAgICAgbWVhc3VyZVRleHQ6ICgpID0+ICh7d2lkdGg6IDB9KSxcbiAgICAgIH0pLFxuICAgICAgc2V0TWVudUVsU3R5bGU6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNZW51RWxBdHRyOiAoLyogYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtTWVudUVsQXR0cjogKC8qIGF0dHI6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRNZW51RWxPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgb3Blbk1lbnU6ICgvKiBmb2N1c0luZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgaXNNZW51T3BlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHNldFNlbGVjdGVkVGV4dENvbnRlbnQ6ICgvKiB0ZXh0Q29udGVudDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldE51bWJlck9mT3B0aW9uczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRUZXh0Rm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIGdldFZhbHVlRm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyLCBhdHRyOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0VG9wRm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge30sXG4gICAgICBnZXRXaW5kb3dJbm5lckhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmN0eF8gPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSAtMTtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcblxuICAgIHRoaXMuZGlzcGxheUhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNNZW51T3BlbigpKSB7XG4gICAgICAgIHRoaXMub3Blbl8oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURpc3BsYXlWaWFLZXlib2FyZF8oZXZ0KTtcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfID0gKHtkZXRhaWx9KSA9PiB7XG4gICAgICBjb25zdCB7aW5kZXh9ID0gZGV0YWlsO1xuXG4gICAgICBpZiAoaW5kZXggIT09IHRoaXMuc2VsZWN0ZWRJbmRleF8pIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VfKCk7XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbEhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZV8oKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfID09PSAtMSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuY3R4XyA9IHRoaXMuYWRhcHRlcl8uY3JlYXRlMmRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpc3BsYXlIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB0aGlzLmNhbmNlbEhhbmRsZXJfKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBEcm9wIHJlZmVyZW5jZSB0byBjb250ZXh0IG9iamVjdCB0byBwcmV2ZW50IHBvdGVudGlhbCBsZWFrc1xuICAgIHRoaXMuY3R4XyA9IG51bGw7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaXNwbGF5SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRpc3BsYXlWaWFLZXlib2FyZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgdGhpcy5zZWxlY3Rpb25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB0aGlzLmNhbmNlbEhhbmRsZXJfKTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfID49IDAgPyB0aGlzLmFkYXB0ZXJfLmdldFZhbHVlRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKSA6ICcnO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgfVxuXG4gIHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleF87XG4gICAgaWYgKHByZXZTZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCAnYXJpYS1zZWxlY3RlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZk9wdGlvbnMoKSA/IGluZGV4IDogLTE7XG4gICAgbGV0IHNlbGVjdGVkVGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwKSB7XG4gICAgICBzZWxlY3RlZFRleHRDb250ZW50ID0gdGhpcy5hZGFwdGVyXy5nZXRUZXh0Rm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKS50cmltKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sICdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzTWVudU9wZW4oKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNlbGVjdGVkVGV4dENvbnRlbnQoc2VsZWN0ZWRUZXh0Q29udGVudCk7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkXztcbiAgfVxuXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ1NlbGVjdEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlVW50YWJiYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKCdhcmlhLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm1ha2VUYWJiYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICBjb25zdCBmb250ID0gdGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ2ZvbnQnKTtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gcGFyc2VGbG9hdCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnbGV0dGVyLXNwYWNpbmcnKSk7XG5cbiAgICBpZiAoZm9udCkge1xuICAgICAgdGhpcy5jdHhfLmZvbnQgPSBmb250O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmltYXJ5Rm9udEZhbWlseSA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LWZhbWlseScpLnNwbGl0KCcsJylbMF07XG4gICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LXNpemUnKTtcbiAgICAgIHRoaXMuY3R4Xy5mb250ID0gYCR7Zm9udFNpemV9ICR7cHJpbWFyeUZvbnRGYW1pbHl9YDtcbiAgICB9XG5cbiAgICBsZXQgbWF4VGV4dExlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZPcHRpb25zKCk7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1cmZhY2VQYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLCAxMCk7XG4gICAgICBjb25zdCBzdXJmYWNlUGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksIDEwKTtcbiAgICAgIGNvbnN0IHNlbGVjdEJveEFkZGVkUGFkZGluZyA9IHN1cmZhY2VQYWRkaW5nUmlnaHQgKyBzdXJmYWNlUGFkZGluZ0xlZnQ7XG4gICAgICBjb25zdCB0eHQgPSB0aGlzLmFkYXB0ZXJfLmdldFRleHRGb3JPcHRpb25BdEluZGV4KGkpLnRyaW0oKTtcbiAgICAgIGNvbnN0IHt3aWR0aH0gPSB0aGlzLmN0eF8ubWVhc3VyZVRleHQodHh0KTtcbiAgICAgIGNvbnN0IGFkZGVkU3BhY2UgPSBsZXR0ZXJTcGFjaW5nICogdHh0Lmxlbmd0aDtcblxuICAgICAgbWF4VGV4dExlbmd0aCA9XG4gICAgICAgIE1hdGgubWF4KG1heFRleHRMZW5ndGgsIE1hdGguY2VpbCh3aWR0aCArIGFkZGVkU3BhY2UgKyBzZWxlY3RCb3hBZGRlZFBhZGRpbmcpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd3aWR0aCcsIGAke21heFRleHRMZW5ndGh9cHhgKTtcbiAgfVxuXG4gIG9wZW5fKCkge1xuICAgIHRoaXMuZGlzYWJsZVNjcm9sbF8oKTtcbiAgICBjb25zdCB7T1BFTn0gPSBNRENTZWxlY3RGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3QgZm9jdXNJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleF8gPCAwID8gMCA6IHRoaXMuc2VsZWN0ZWRJbmRleF87XG5cbiAgICB0aGlzLnNldE1lbnVTdHlsZXNGb3JPcGVuQXRJbmRleF8oZm9jdXNJbmRleCk7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVCb3R0b21MaW5lKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhPUEVOKTtcbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5vcGVuTWVudShmb2N1c0luZGV4KTtcbiAgICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBzZXRNZW51U3R5bGVzRm9yT3BlbkF0SW5kZXhfKGluZGV4KSB7XG4gICAgY29uc3QgaW5uZXJIZWlnaHQgPSB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd0lubmVySGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZnQsIHRvcH0gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsQXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsU3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICBjb25zdCBtZW51SGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRNZW51RWxPZmZzZXRIZWlnaHQoKTtcbiAgICBjb25zdCBpdGVtT2Zmc2V0VG9wID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRUb3BGb3JPcHRpb25BdEluZGV4KGluZGV4KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbFN0eWxlKCdkaXNwbGF5JywgJycpO1xuICAgIHRoaXMuYWRhcHRlcl8ucm1NZW51RWxBdHRyKCdhcmlhLWhpZGRlbicpO1xuXG4gICAgbGV0IGFkanVzdGVkVG9wID0gdG9wIC0gaXRlbU9mZnNldFRvcDtcbiAgICBjb25zdCBvdmVyZmxvd3NUb3AgPSBhZGp1c3RlZFRvcCA8IDA7XG4gICAgY29uc3Qgb3ZlcmZsb3dzQm90dG9tID0gYWRqdXN0ZWRUb3AgKyBtZW51SGVpZ2h0ID4gaW5uZXJIZWlnaHQ7XG4gICAgaWYgKG92ZXJmbG93c1RvcCkge1xuICAgICAgYWRqdXN0ZWRUb3AgPSAwO1xuICAgIH0gZWxzZSBpZiAob3ZlcmZsb3dzQm90dG9tKSB7XG4gICAgICBhZGp1c3RlZFRvcCA9IE1hdGgubWF4KDAsIGlubmVySGVpZ2h0IC0gbWVudUhlaWdodCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsU3R5bGUoJ2xlZnQnLCBgJHtsZWZ0fXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxTdHlsZSgndG9wJywgYCR7YWRqdXN0ZWRUb3B9cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgYGNlbnRlciAke2l0ZW1PZmZzZXRUb3B9cHhgKTtcbiAgfVxuXG4gIGNsb3NlXygpIHtcbiAgICBjb25zdCB7T1BFTn0gPSBNRENTZWxlY3RGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhPUEVOKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVCb3R0b21MaW5lKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5mb2N1cygpO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICB9XG5cbiAgaGFuZGxlRGlzcGxheVZpYUtleWJvYXJkXyhldnQpIHtcbiAgICAvLyBXZSB1c2UgYSBoYXJkLWNvZGVkIDIgaW5zdGVhZCBvZiBFdmVudC5BVF9UQVJHRVQgdG8gYXZvaWQgaGF2aW5nIHRvIHJlZmVyZW5jZSBhIGJyb3dzZXJcbiAgICAvLyBnbG9iYWwuXG4gICAgY29uc3QgRVZFTlRfUEhBU0VfQVRfVEFSR0VUID0gMjtcbiAgICBpZiAoZXZ0LmV2ZW50UGhhc2UgIT09IEVWRU5UX1BIQVNFX0FUX1RBUkdFVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcHJlc3Npbmcgc3BhY2UgZG93biBmcm9tIHNjcm9sbGluZyB0aGUgcGFnZVxuICAgIGNvbnN0IGlzU3BhY2VEb3duID0gZXZ0LnR5cGUgPT09ICdrZXlkb3duJyAmJiAoZXZ0LmtleSA9PT0gJ1NwYWNlJyB8fCBldnQua2V5Q29kZSA9PT0gMzIpO1xuICAgIGlmIChpc1NwYWNlRG93bikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPcGVuZXJLZXkgPSBPUEVORVJfS0VZUy5zb21lKCh7a2V5LCBrZXlDb2RlLCBmb3JUeXBlfSkgPT4ge1xuICAgICAgcmV0dXJuIGV2dC50eXBlID09PSBmb3JUeXBlICYmIChldnQua2V5ID09PSBrZXkgfHwgZXZ0LmtleUNvZGUgPT09IGtleUNvZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzT3BlbmVyS2V5KSB7XG4gICAgICB0aGlzLmRpc3BsYXlIYW5kbGVyXyhldnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTZWxlY3QgQm90dG9tIExpbmUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgU2VsZWN0IGxhYmVsIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3RCb3R0b21MaW5lQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGJvdHRvbSBsaW5lIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGJvdHRvbSBsaW5lIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0Qm90dG9tTGluZUFkYXB0ZXI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQk9UVE9NX0xJTkVfQUNUSVZFOiAnbWRjLXNlbGVjdF9fYm90dG9tLWxpbmUtLWFjdGl2ZScsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1NlbGVjdEJvdHRvbUxpbmVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU2VsZWN0Qm90dG9tTGluZUFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdEJvdHRvbUxpbmVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1NlbGVjdEJvdHRvbUxpbmVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdEJvdHRvbUxpbmVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2VsZWN0Qm90dG9tTGluZUFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgYWN0aXZlIGNsYXNzIHRvIGJvdHRvbSBsaW5lXG4gICAqL1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQk9UVE9NX0xJTkVfQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBhY3RpdmUgY2xhc3MgZnJvbSB0aGUgYm90dG9tIGxpbmVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkJPVFRPTV9MSU5FX0FDVElWRSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDU2VsZWN0Qm90dG9tTGluZUFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdEJvdHRvbUxpbmVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0Qm90dG9tTGluZUZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFNlbGVjdCBMYWJlbC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBTZWxlY3QgbGFiZWwgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdExhYmVsQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0TGFiZWxBZGFwdGVyO1xuIiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExBQkVMX0ZMT0FUX0FCT1ZFOiAnbWRjLXNlbGVjdF9fbGFiZWwtLWZsb2F0LWFib3ZlJyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDU2VsZWN0TGFiZWxBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU2VsZWN0TGFiZWxBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDU2VsZWN0TGFiZWxBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdExhYmVsQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1NlbGVjdExhYmVsQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3RMYWJlbEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdExhYmVsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gZmxvYXQgb3IgZGVmbG9hdCBhcyBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgKi9cbiAgc3R5bGVGbG9hdCh2YWx1ZSkge1xuICAgIGNvbnN0IHtMQUJFTF9GTE9BVF9BQk9WRX0gPSBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoISF2YWx1ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1zZWxlY3QgbWRjLW1lbnUtc2VsZWN0XCIgXHJcbiAgICByb2xlPVwibGlzdGJveFwiIFxyXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiPlxyXG4gICAgPGRpdiByZWY9XCJzdXJmYWNlXCIgY2xhc3M9XCJtZGMtc2VsZWN0X19zdXJmYWNlXCJcclxuICAgICAgOnN0eWxlPVwic3VyZmFjZVN0eWxlc1wiIDp0YWJpbmRleD1cInRhYkluZGV4XCI+XHJcbiAgICAgICAgPGRpdiByZWY9XCJsYWJlbFwiIGNsYXNzPVwibWRjLXNlbGVjdF9fbGFiZWxcIlxyXG4gICAgICAgICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzXCJcclxuICAgICAgICA+e3tsYWJlbH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiByZWY9XCJzZWxlY3RlZENvbnRlbnRcIiBjbGFzcz1cIm1kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHRcIiBcclxuICAgICAgICA+e3tzZWxlY3RlZFRleHRDb250ZW50fX08L2Rpdj5cclxuICAgICAgICA8ZGl2IHJlZj1cImJvdHRvbUxpbmVcIiBjbGFzcz1cIm1kYy1zZWxlY3RfX2JvdHRvbS1saW5lXCJcclxuICAgICAgICAgIDpjbGFzcz1cImJvdHRvbUxpbmVDbGFzc2VzXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxtZGMtbWVudSByZWY9XCJtZW51XCIgXHJcbiAgICAgIGNsYXNzPVwibWRjLXNlbGVjdF9fbWVudVwiXHJcbiAgICAgIEB1cGRhdGU9XCJyZWZyZXNoSW5kZXhcIj5cclxuICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgPC9tZGMtbWVudT5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IG1kY01lbnUgfSBmcm9tICcuLi9tZW51JztcclxuaW1wb3J0IE1EQ1NlbGVjdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uJztcclxuaW1wb3J0IE1EQ1NlbGVjdEJvdHRvbUxpbmVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zZWxlY3QvYm90dG9tLWxpbmUvZm91bmRhdGlvbic7XHJcbmltcG9ydCBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9mb3VuZGF0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLW1lbnUtc2VsZWN0JyxcclxuICBtb2RlbDoge1xyXG4gICAgcHJvcDogJ3ZhbHVlJyxcclxuICAgIGV2ZW50OiAnY2hhbmdlJyxcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBtdWx0aXBsZTogQm9vbGVhbixcclxuICAgIHZhbHVlOiBbU3RyaW5nLCBBcnJheV0sXHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGxhYmVsOiBTdHJpbmcsXHJcbiAgICBib3g6IEJvb2xlYW4sXHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtc2VsZWN0LS1ib3gnOiB0aGlzLmJveCxcclxuICAgICAgfSxcclxuICAgICAgbGFiZWxDbGFzc2VzOiB7fSxcclxuICAgICAgYm90dG9tTGluZUNsYXNzZXM6IHt9LFxyXG4gICAgICBzdXJmYWNlU3R5bGVzOiB7fSxcclxuICAgICAgdGFiSW5kZXg6IDAsXHJcbiAgICAgIHNlbGVjdGVkVGV4dENvbnRlbnQ6ICcnLFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXBvbmVudHM6IHtcclxuICAgICdtZGMtbWVudSc6IG1kY01lbnUsXHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgZGlzYWJsZWQodmFsdWUpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgdmFsdWUoKSB7XHJcbiAgICAgIHRoaXMucmVmcmVzaEluZGV4KCk7XHJcbiAgICB9LFxyXG4gICAgYm94KCkge1xyXG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXNlbGVjdC0tYm94JywgdGhpcy5ib3gpO1xyXG4gICAgfSxcclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIHJlZnJlc2hJbmRleCgpIHtcclxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xyXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy4kcmVmcy5tZW51Lml0ZW1zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IG9wdGlvblZhbHVlID1cclxuICAgICAgICAgICAgb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB8fFxyXG4gICAgICAgICAgICBvcHRpb25zW2ldLnRleHRDb250ZW50LnRyaW0oKTtcclxuICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09IG9wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTZWxlY3RlZEluZGV4KGkpO1xyXG4gICAgICAgICAgICAvL1RPRE86IE1EQ0ZJWCBmb3JjZSBmbG9hdCBhYm92ZSBpZiB2YWx1ZSBpcyB2YWxpZFxyXG4gICAgICAgICAgICB0aGlzLiRzZXQoXHJcbiAgICAgICAgICAgICAgdGhpcy5sYWJlbENsYXNzZXMsXHJcbiAgICAgICAgICAgICAgJ21kYy1zZWxlY3RfX2xhYmVsLS1mbG9hdC1hYm92ZScsXHJcbiAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE86IE1EQ0ZJWCBmb3JjZSBmbG9hdCBhYm92ZSBpZiB2YWx1ZSBpcyB2YWxpZFxyXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTZWxlY3RlZEluZGV4KC0xKTtcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsICdtZGMtc2VsZWN0X19sYWJlbC0tZmxvYXQtYWJvdmUnLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpOyAvLyBUT0RPOiBNRENGSVhcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24oe1xyXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSksXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uID0gbmV3IE1EQ1NlbGVjdEJvdHRvbUxpbmVGb3VuZGF0aW9uKHtcclxuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuYm90dG9tTGluZUNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xyXG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmJvdHRvbUxpbmVDbGFzc2VzLCBjbGFzc05hbWUpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uLmluaXQoKTtcclxuXHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU2VsZWN0Rm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxyXG4gICAgICBmbG9hdExhYmVsOiB2YWx1ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uc3R5bGVGbG9hdCh2YWx1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24uYWN0aXZhdGUoKTtcclxuICAgICAgfSxcclxuICAgICAgZGVhY3RpdmF0ZUJvdHRvbUxpbmU6ICgpID0+IHtcclxuICAgICAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uLmRlYWN0aXZhdGUoKTtcclxuICAgICAgfSxcclxuICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBybUF0dHI6IChhdHRyLCB2YWx1ZSkgPT4gdGhpcy4kZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcclxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gdGhpcy4kcmVmcy5zdXJmYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBmb2N1czogKCkgPT4gdGhpcy4kcmVmcy5zdXJmYWNlLmZvY3VzKCksXHJcbiAgICAgIG1ha2VUYWJiYWJsZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAwO1xyXG4gICAgICB9LFxyXG4gICAgICBtYWtlVW50YWJiYWJsZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAtMTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiBwcm9wID0+XHJcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5zdXJmYWNlKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApLFxyXG4gICAgICBzZXRTdHlsZTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3VyZmFjZVN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXHJcbiAgICAgIGNyZWF0ZTJkUmVuZGVyaW5nQ29udGV4dDogKCkgPT5cclxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICBzZXRNZW51RWxTdHlsZTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XHJcbiAgICAgICAgKHRoaXMuJHJlZnMubWVudS4kZWwuc3R5bGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlKSxcclxuICAgICAgc2V0TWVudUVsQXR0cjogKGF0dHIsIHZhbHVlKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS4kZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcclxuICAgICAgcm1NZW51RWxBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMubWVudS4kZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxyXG4gICAgICBnZXRNZW51RWxPZmZzZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMubWVudS4kZWwub2Zmc2V0SGVpZ2h0LFxyXG4gICAgICBvcGVuTWVudTogZm9jdXNJbmRleCA9PiB0aGlzLiRyZWZzLm1lbnUuc2hvdyh7IGZvY3VzSW5kZXggfSksXHJcbiAgICAgIGlzTWVudU9wZW46ICgpID0+IHRoaXMuJHJlZnMubWVudS5pc09wZW4oKSxcclxuICAgICAgc2V0U2VsZWN0ZWRUZXh0Q29udGVudDogc2VsZWN0ZWRUZXh0Q29udGVudCA9PiB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRleHRDb250ZW50ID0gc2VsZWN0ZWRUZXh0Q29udGVudDtcclxuICAgICAgfSxcclxuICAgICAgZ2V0TnVtYmVyT2ZPcHRpb25zOiAoKSA9PiB0aGlzLiRyZWZzLm1lbnUuaXRlbXMubGVuZ3RoLFxyXG4gICAgICBnZXRUZXh0Rm9yT3B0aW9uQXRJbmRleDogaW5kZXggPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLnRleHRDb250ZW50LnRyaW0oKSxcclxuICAgICAgZ2V0VmFsdWVGb3JPcHRpb25BdEluZGV4OiBpbmRleCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIHRoaXMuJHJlZnMubWVudS5pdGVtc1tpbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykgfHxcclxuICAgICAgICAgIHRoaXMuJHJlZnMubWVudS5pdGVtc1tpbmRleF0udGV4dENvbnRlbnQudHJpbSgpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGF0dHIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXHJcbiAgICAgIGdldE9mZnNldFRvcEZvck9wdGlvbkF0SW5kZXg6IGluZGV4ID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS5vZmZzZXRUb3AsXHJcbiAgICAgIHJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBkZXJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcclxuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFdpbmRvd0lubmVySGVpZ2h0OiAoKSA9PiB3aW5kb3cuaW5uZXJIZWlnaHQsXHJcbiAgICAgIGFkZEJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxyXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vVE9ETzogTURDRklYXHJcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvbjtcclxuICAgIGlmIChmb3VuZGF0aW9uKSB7XHJcbiAgICAgIGZvdW5kYXRpb24ucmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghZm91bmRhdGlvbi5jdHhfKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvbnQgPSBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udCcpO1xyXG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBwYXJzZUZsb2F0KFxyXG4gICAgICAgICAgZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ2xldHRlci1zcGFjaW5nJyksXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoZm9udCkge1xyXG4gICAgICAgICAgZm91bmRhdGlvbi5jdHhfLmZvbnQgPSBmb250O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBwcmltYXJ5Rm9udEZhbWlseSA9IGZvdW5kYXRpb24uYWRhcHRlcl9cclxuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udC1mYW1pbHknKVxyXG4gICAgICAgICAgICAuc3BsaXQoJywnKVswXTtcclxuICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoXHJcbiAgICAgICAgICAgICdmb250LXNpemUnLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGZvdW5kYXRpb24uY3R4Xy5mb250ID0gYCR7Zm9udFNpemV9ICR7cHJpbWFyeUZvbnRGYW1pbHl9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtYXhUZXh0TGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3VyZmFjZVBhZGRpbmdSaWdodCA9IHBhcnNlSW50KFxyXG4gICAgICAgICAgZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcclxuICAgICAgICAgIDEwLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qgc3VyZmFjZVBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoXHJcbiAgICAgICAgICBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXHJcbiAgICAgICAgICAxMCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdEJveEFkZGVkUGFkZGluZyA9IHN1cmZhY2VQYWRkaW5nUmlnaHQgKyBzdXJmYWNlUGFkZGluZ0xlZnQ7XHJcblxyXG4gICAgICAgIGZvciAoXHJcbiAgICAgICAgICBsZXQgaSA9IDAsIGwgPSBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldE51bWJlck9mT3B0aW9ucygpO1xyXG4gICAgICAgICAgaSA8IGw7XHJcbiAgICAgICAgICBpKytcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IHR4dCA9IGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0VGV4dEZvck9wdGlvbkF0SW5kZXgoaSkudHJpbSgpO1xyXG4gICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZm91bmRhdGlvbi5jdHhfLm1lYXN1cmVUZXh0KHR4dCk7XHJcbiAgICAgICAgICBjb25zdCBhZGRlZFNwYWNlID0gbGV0dGVyU3BhY2luZyAqIHR4dC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgbWF4VGV4dExlbmd0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBtYXhUZXh0TGVuZ3RoLFxyXG4gICAgICAgICAgICBNYXRoLmNlaWwod2lkdGggKyBhZGRlZFNwYWNlICsgc2VsZWN0Qm94QWRkZWRQYWRkaW5nKSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFR4dCA9IHRoaXMubGFiZWw7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZm91bmRhdGlvbi5jdHhfLm1lYXN1cmVUZXh0KGxhYmVsVHh0KTtcclxuICAgICAgICBjb25zdCBhZGRlZFNwYWNlID0gbGV0dGVyU3BhY2luZyAqIGxhYmVsVHh0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgbWF4VGV4dExlbmd0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgbWF4VGV4dExlbmd0aCxcclxuICAgICAgICAgIE1hdGguY2VpbCh3aWR0aCArIGFkZGVkU3BhY2UgKyBzZWxlY3RCb3hBZGRlZFBhZGRpbmcpLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGZvdW5kYXRpb24uYWRhcHRlcl8uc2V0U3R5bGUoJ3dpZHRoJywgYCR7bWF4VGV4dExlbmd0aH1weGApO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8vXHJcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5pbml0KCk7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpO1xyXG4gICAgdGhpcy5yZWZyZXNoSW5kZXgoKTtcclxuICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSkge1xyXG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgbGV0IGZvdW5kYXRpb24gPSB0aGlzLmZvdW5kYXRpb247XHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsO1xyXG4gICAgZm91bmRhdGlvbi5kZXN0cm95KCk7XHJcblxyXG4gICAgbGV0IGxhYmVsRm91bmRhdGlvbiA9IHRoaXMubGFiZWxGb3VuZGF0aW9uO1xyXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gPSBudWxsO1xyXG4gICAgbGFiZWxGb3VuZGF0aW9uLmRlc3Ryb3koKTtcclxuXHJcbiAgICBsZXQgYm90dG9tTGluZUZvdW5kYXRpb24gPSB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uO1xyXG4gICAgdGhpcy5ib3R0b21MaW5lRm91bmRhdGlvbiA9IG51bGw7XHJcbiAgICBib3R0b21MaW5lRm91bmRhdGlvbi5kZXN0cm95KCk7XHJcbiAgfSxcclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VsZWN0IDptdWx0aXBsZT1cIm11bHRpcGxlXCIgIHJlZj1cInJvb3RcIiB2LW1vZGVsPVwic2VsZWN0ZWRcIiBcclxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgIDpzdHlsZT1cInN0eWxlc1wiICBcclxuICAgIGNsYXNzPVwibWRjLXNlbGVjdCBtZGMtbXVsdGktc2VsZWN0IG1kYy1saXN0XCJcclxuICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXHJcbiAgPlxyXG4gICAgPG9wdGdyb3VwIHJlZj1cIm9wdGdyb3VwXCIgY2xhc3M9XCJtZGMtbGlzdC1ncm91cFwiIDpsYWJlbD1cImxhYmVsXCIgdi1pZj1cImxhYmVsXCI+XHJcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgPC9vcHRncm91cD5cclxuICAgIDxzbG90IHYtZWxzZT48L3Nsb3Q+XHJcbiAgPC9zZWxlY3Q+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1tdWx0aS1zZWxlY3QnLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXHJcbiAgICB2YWx1ZTogW1N0cmluZywgQXJyYXldLFxyXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXHJcbiAgICBsYWJlbDogU3RyaW5nLFxyXG4gICAgbWF4U2l6ZToge1xyXG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxyXG4gICAgICBkZWZhdWx0OiA0XHJcbiAgICB9XHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNlbGVjdGVkOiB0aGlzLnZhbHVlLFxyXG4gICAgICBzaXplOiB1bmRlZmluZWQsXHJcbiAgICAgIGNvdW50OiB1bmRlZmluZWRcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBzdHlsZXMgKCkge1xyXG4gICAgICBsZXQgc2Nyb2xsID0gKHRoaXMuY291bnQgPiB0aGlzLnNpemUpXHJcbiAgICAgIGxldCBzaXplID0gNDgqIHRoaXMuc2l6ZSArIChzY3JvbGw/IDAgOiAxNilcclxuXHJcbiAgICAgIGxldCBzdHlsZXMgPSAge1xyXG4gICAgICAgICdoZWlnaHQnOiBzaXplICsgJ3B4JyxcclxuICAgICAgICAnb3ZlcmZsb3cteSc6ICBzY3JvbGwgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nXHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzY3JvbGwpIHtcclxuICAgICAgICBzdHlsZXNbJ2JhY2tncm91bmQtaW1hZ2UnXSA9ICd1bnNldCdcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3R5bGVzXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBvbkNoYW5nZSAoKSB7XHJcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuc2VsZWN0ZWQpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuICAgIGNvbnN0IHJlZnJlc2hTaXplID0gKCkgPT4ge1xyXG4gICAgICBsZXQgY291bnQgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uLCBvcHRncm91cCcpLmxlbmd0aFxyXG4gICAgICB0aGlzLmNvdW50ID0gY291bnRcclxuICAgICAgbGV0IG1heCA9IE51bWJlcih0aGlzLm1heFNpemUpXHJcbiAgICAgIGlmICh0aGlzLmxhYmVsKSB7XHJcbiAgICAgICAgbWF4ICs9IDFcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1pbihjb3VudCwgbWF4KVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gcmVmcmVzaFNpemUoKSlcclxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pXHJcblxyXG4gICAgcmVmcmVzaFNpemUoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y29tcG9uZW50IDppcz1cInR5cGVcIiA6bXVsdGlwbGU9XCJtdWx0aXBsZVwiXHJcbiAgICA6bGFiZWw9XCJsYWJlbFwiIFxyXG4gICAgOnZhbHVlPVwidmFsdWVcIiBAY2hhbmdlPVwib25DaGFuZ2VcIlxyXG4gICAgdi1iaW5kPVwiJGF0dHJzXCJcclxuICA+XHJcbiAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgPC9jb21wb25lbnQ+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTURDTmF0aXZlU2VsZWN0IGZyb20gJy4vbWRjLW5hdGl2ZS1zZWxlY3QudnVlJztcclxuaW1wb3J0IE1EQ01lbnVTZWxlY3QgZnJvbSAnLi9tZGMtbWVudS1zZWxlY3QudnVlJztcclxuaW1wb3J0IE1EQ011bHRpU2VsZWN0IGZyb20gJy4vbWRjLW11bHRpLXNlbGVjdC52dWUnO1xyXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4gfSBmcm9tICcuLi9iYXNlJztcclxuXHJcbmNvbnN0IG1lZGlhID0gbmV3IGNsYXNzIHtcclxuICBnZXQgbW9iaWxlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5fbW9iaWxlIHx8XHJcbiAgICAgICh0aGlzLl9tb2JpbGUgPSB3aW5kb3cubWF0Y2hNZWRpYShcclxuICAgICAgICAnKG1heC13aWR0aDogNjAwcHgpIGFuZCAocG9pbnRlcjogY29hcnNlKScsXHJcbiAgICAgICkpXHJcbiAgICApO1xyXG4gIH1cclxufSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtc2VsZWN0JyxcclxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdjaGFuZ2UnLFxyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIG11bHRpcGxlOiBCb29sZWFuLFxyXG4gICAgdmFsdWU6IFtTdHJpbmcsIEFycmF5XSxcclxuICAgIGxhYmVsOiBTdHJpbmcsXHJcbiAgICBuYXRpdmU6IEJvb2xlYW4sXHJcbiAgICBtZW51OiBCb29sZWFuLFxyXG4gIH0sXHJcbiAgcHJvdmlkZSgpIHtcclxuICAgIHJldHVybiB7IG1kY1NlbGVjdDogdGhpcyB9O1xyXG4gIH0sXHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgJ21kYy1uYXRpdmUtc2VsZWN0JzogTURDTmF0aXZlU2VsZWN0LFxyXG4gICAgJ21kYy1tZW51LXNlbGVjdCc6IE1EQ01lbnVTZWxlY3QsXHJcbiAgICAnbWRjLW11bHRpLXNlbGVjdCc6IE1EQ011bHRpU2VsZWN0LFxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1vYmlsZTogd2luZG93ID8gbWVkaWEubW9iaWxlLm1hdGNoZXMgOiB0cnVlLFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICB0eXBlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZVxyXG4gICAgICAgID8gJ21kYy1tdWx0aS1zZWxlY3QnXHJcbiAgICAgICAgOiB0aGlzLm1lbnVcclxuICAgICAgICAgID8gJ21kYy1tZW51LXNlbGVjdCdcclxuICAgICAgICAgIDogdGhpcy5pc05hdGl2ZSA/ICdtZGMtbmF0aXZlLXNlbGVjdCcgOiAnbWRjLW1lbnUtc2VsZWN0JztcclxuICAgIH0sXHJcbiAgICBpc05hdGl2ZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubmF0aXZlIHx8IHRoaXMubXVsdGlwbGUgfHwgdGhpcy5tb2JpbGU7XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgb25DaGFuZ2UodmFsdWUpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHJlZnJlc2hNZWRpYSgpIHtcclxuICAgICAgdGhpcy5tb2JpbGUgPSBtZWRpYS5tb2JpbGUubWF0Y2hlcztcclxuICAgIH0sXHJcbiAgfSxcclxuICBiZWZvcmVNb3VudCgpIHtcclxuICAgIG1lZGlhLm1vYmlsZS5hZGRMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSk7XHJcbiAgICB0aGlzLnJlZnJlc2hNZWRpYSgpO1xyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgIG1lZGlhLm1vYmlsZS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSk7XHJcbiAgfSxcclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgIDxvcHRpb24gOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6dmFsdWU9XCJ2YWx1ZVwiIHYtaWY9XCJoYXNWYWx1ZVwiXG4gICAgY2xhc3M9XCJtZGMtb3B0aW9uIG1kYy1uYXRpdmUtb3B0aW9uXCI+XG4gICAgIDxzbG90Pjwvc2xvdD5cbiAgIDwvb3B0aW9uPlxuICAgPG9wdGlvbiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIHYtZWxzZVxuICAgIGNsYXNzPVwibWRjLW9wdGlvbiBtZGMtbmF0aXZlLW9wdGlvblwiPlxuICAgICA8c2xvdD48L3Nsb3Q+XG4gICA8L29wdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbmF0aXZlLW9wdGlvbicsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGhhc1ZhbHVlICgpIHtcbiAgICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLnZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgPGxpIGNsYXNzPVwibWRjLW9wdGlvbiBtZGMtbWVudS1vcHRpb24gbWRjLWxpc3QtaXRlbVwiIFxuICAgIHJvbGU9XCJvcHRpb25cIiBcbiAgICA6dGFiaW5kZXg9XCJkaXNhYmxlZD8tMTowXCJcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICA6ZGF0YS12YWx1ZT1cInZhbHVlXCI+XG4gICAgIDxzbG90Pjwvc2xvdD5cbiAgIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtb3B0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgPG9wdGlvbiBjbGFzcz1cIm1kYy1vcHRpb24gbWRjLW11bHRpLW9wdGlvbiBtZGMtbGlzdC1pdGVtXCIgXG4gICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6dmFsdWU9XCJ2YWx1ZVwiIHYtaWY9XCJoYXNWYWx1ZVwiPlxuICAgICA8c2xvdD48L3Nsb3Q+XG4gICA8L29wdGlvbj5cbiAgIDxvcHRpb24gY2xhc3M9XCJtZGMtb3B0aW9uIG1kYy1tdWx0aS1vcHRpb24gbWRjLWxpc3QtaXRlbVwiIFxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgdi1lbHNlPlxuICAgICA8c2xvdD48L3Nsb3Q+XG4gICA8L29wdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbXVsdGktb3B0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzVmFsdWUgKCkge1xuICAgICAgcmV0dXJuICEodHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxjb21wb25lbnQgOmlzPVwidHlwZVwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOnZhbHVlPXZhbHVlPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9jb21wb25lbnQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ05hdGl2ZU9wdGlvbiBmcm9tICcuL21kYy1uYXRpdmUtb3B0aW9uLnZ1ZSc7XG5pbXBvcnQgTURDTWVudU9wdGlvbiBmcm9tICcuL21kYy1tZW51LW9wdGlvbi52dWUnO1xuaW1wb3J0IE1EQ011bHRpT3B0aW9uIGZyb20gJy4vbWRjLW11bHRpLW9wdGlvbi52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtb3B0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICB9LFxuICBpbmplY3Q6IFsnbWRjU2VsZWN0J10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICAnbWRjLW5hdGl2ZS1vcHRpb24nOiBNRENOYXRpdmVPcHRpb24sXG4gICAgJ21kYy1tdWx0aS1vcHRpb24nOiBNRENNdWx0aU9wdGlvbixcbiAgICAnbWRjLW1lbnUtb3B0aW9uJzogTURDTWVudU9wdGlvbixcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc05hdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY1NlbGVjdC5pc05hdGl2ZTtcbiAgICB9LFxuICAgIG11bHRpcGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjU2VsZWN0Lm11bHRpcGxlO1xuICAgIH0sXG4gICAgbWVudSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY1NlbGVjdC5tZW51O1xuICAgIH0sXG4gICAgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlXG4gICAgICAgID8gJ21kYy1tdWx0aS1vcHRpb24nXG4gICAgICAgIDogdGhpcy5tZW51XG4gICAgICAgICAgPyAnbWRjLW1lbnUtb3B0aW9uJ1xuICAgICAgICAgIDogdGhpcy5pc05hdGl2ZSA/ICdtZGMtbmF0aXZlLW9wdGlvbicgOiAnbWRjLW1lbnUtb3B0aW9uJztcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NlbGVjdCBmcm9tICcuL21kYy1zZWxlY3QudnVlJ1xuaW1wb3J0IG1kY09wdGlvbiBmcm9tICcuL21kYy1vcHRpb24udnVlJ1xuXG5cbmV4cG9ydCB7XG4gIG1kY1NlbGVjdCxcbiAgbWRjT3B0aW9uLFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2VsZWN0LFxuICBtZGNPcHRpb24sXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy1zbGlkZXItLWFjdGl2ZScsXG4gIERJU0FCTEVEOiAnbWRjLXNsaWRlci0tZGlzYWJsZWQnLFxuICBESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgRk9DVVM6ICdtZGMtc2xpZGVyLS1mb2N1cycsXG4gIElOX1RSQU5TSVQ6ICdtZGMtc2xpZGVyLS1pbi10cmFuc2l0JyxcbiAgSVNfRElTQ1JFVEU6ICdtZGMtc2xpZGVyLS1kaXNjcmV0ZScsXG4gIEhBU19UUkFDS19NQVJLRVI6ICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBUUkFDS19TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjaycsXG4gIFRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcicsXG4gIExBU1RfVFJBQ0tfTUFSS0VSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlcjpsYXN0LWNoaWxkJyxcbiAgVEhVTUJfQ09OVEFJTkVSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lcicsXG4gIFBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlcicsXG4gIEFSSUFfVkFMVUVNSU46ICdhcmlhLXZhbHVlbWluJyxcbiAgQVJJQV9WQUxVRU1BWDogJ2FyaWEtdmFsdWVtYXgnLFxuICBBUklBX1ZBTFVFTk9XOiAnYXJpYS12YWx1ZW5vdycsXG4gIEFSSUFfRElTQUJMRUQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgU1RFUF9EQVRBX0FUVFI6ICdkYXRhLXN0ZXAnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENTbGlkZXI6Y2hhbmdlJyxcbiAgSU5QVVRfRVZFTlQ6ICdNRENTbGlkZXI6aW5wdXQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBQQUdFX0ZBQ1RPUjogNCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFNsaWRlci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBTbGlkZXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NsaWRlckFkYXB0ZXIge1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNsYXNzTmFtZSBleGlzdHMgZm9yIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIGlmIGF0dHJpYnV0ZSBuYW1lIGV4aXN0cyBvbiB0aGUgc2xpZGVyIEVsZW1lbnQsXG4gICAqIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGF0dHJpYnV0ZSBuYW1lIG9uIHNsaWRlciBFbGVtZW50IHRvIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGF0dHJpYnV0ZSBuYW1lIGZyb20gc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEByZXR1cm4gez9DbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYiBpbmRleCBvZiB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHRodW1iIGNvbnRhaW5lciBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBib2R5IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIHdpbmRvdyByZXNpemUgZXZlbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgTURDU2xpZGVyOmlucHV0IGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUlucHV0KCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgTURDU2xpZGVyOmNoYW5nZSBmcm9tIHRoZSByb290XG4gICAqL1xuICBub3RpZnlDaGFuZ2UoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIHRodW1iIGNvbnRhaW5lciBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIHRyYWNrIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VHJhY2tTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlubmVyIHRleHQgb2YgdGhlIHBpbiBtYXJrZXIgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHNldE1hcmtlclZhbHVlKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBwYXNzZWQgbnVtYmVyIG9mIHRyYWNrIG1hcmtlcnMgdG8gdGhlIHRyYWNrIG1hcmsgY29udGFpbmVyIGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bU1hcmtlcnNcbiAgICovXG4gIGFwcGVuZFRyYWNrTWFya2VycyhudW1NYXJrZXJzKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0cmFjayBtYXJrZXJzIGZyb210IGhlIHRyYWNrIG1hcmsgY29udGFpbmVyIGVsZW1lbnRcbiAgICovXG4gIHJlbW92ZVRyYWNrTWFya2VycygpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgbGFzdCB0cmFjayBtYXJrZXIgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgaXMgUlRMLCBvdGhlcndpc2UgZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUlRMKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBNRENTbGlkZXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5cbmltcG9ydCB7Z2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleCc7XG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBLRVlfSURTID0ge1xuICBBUlJPV19MRUZUOiAnQXJyb3dMZWZ0JyxcbiAgQVJST1dfUklHSFQ6ICdBcnJvd1JpZ2h0JyxcbiAgQVJST1dfVVA6ICdBcnJvd1VwJyxcbiAgQVJST1dfRE9XTjogJ0Fycm93RG93bicsXG4gIEhPTUU6ICdIb21lJyxcbiAgRU5EOiAnRW5kJyxcbiAgUEFHRV9VUDogJ1BhZ2VVcCcsXG4gIFBBR0VfRE9XTjogJ1BhZ2VEb3duJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgTU9WRV9FVkVOVF9NQVAgPSB7XG4gICdtb3VzZWRvd24nOiAnbW91c2Vtb3ZlJyxcbiAgJ3RvdWNoc3RhcnQnOiAndG91Y2htb3ZlJyxcbiAgJ3BvaW50ZXJkb3duJzogJ3BvaW50ZXJtb3ZlJyxcbn07XG5cbmNvbnN0IERPV05fRVZFTlRTID0gWydtb3VzZWRvd24nLCAncG9pbnRlcmRvd24nLCAndG91Y2hzdGFydCddO1xuY29uc3QgVVBfRVZFTlRTID0gWydtb3VzZXVwJywgJ3BvaW50ZXJ1cCcsICd0b3VjaGVuZCddO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENTbGlkZXJBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDU2xpZGVyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1NsaWRlckFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1NsaWRlckFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldEF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4gLyogc3RyaW5nfG51bGwgKi8gbnVsbCxcbiAgICAgIHNldEF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6ICgvKiBuYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyAoe1xuICAgICAgICB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICB9KSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUlucHV0OiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge30sXG4gICAgICBzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHk6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNYXJrZXJWYWx1ZTogKC8qIHZhbHVlOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgYXBwZW5kVHJhY2tNYXJrZXJzOiAoLyogbnVtTWFya2VyczogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZVRyYWNrTWFya2VyczogKCkgPT4ge30sXG4gICAgICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGlzUlRMOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTURDU2xpZGVyRm91bmRhdGlvblxuICAgKiBAcGFyYW0gez9NRENTbGlkZXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbGlkZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgLyoqIEBwcml2YXRlIHs/Q2xpZW50UmVjdH0gKi9cbiAgICB0aGlzLnJlY3RfID0gbnVsbDtcbiAgICAvLyBXZSBzZXQgdGhpcyB0byBOYU4gc2luY2Ugd2Ugd2FudCBpdCB0byBiZSBhIG51bWJlciwgYnV0IHdlIGNhbid0IHVzZSAnMCcgb3IgJy0xJ1xuICAgIC8vIGJlY2F1c2UgdGhvc2UgY291bGQgYmUgdmFsaWQgdGFiaW5kaWNlcyBzZXQgYnkgdGhlIGNsaWVudCBjb2RlLlxuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSBOYU47XG4gICAgdGhpcy5hY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gZmFsc2U7XG4gICAgdGhpcy5pc0Rpc2NyZXRlXyA9IGZhbHNlO1xuICAgIHRoaXMuaGFzVHJhY2tNYXJrZXJfID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IGZhbHNlO1xuICAgIHRoaXMubWluXyA9IDA7XG4gICAgdGhpcy5tYXhfID0gMTAwO1xuICAgIHRoaXMuc3RlcF8gPSAwO1xuICAgIHRoaXMudmFsdWVfID0gMDtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMucHJldmVudEZvY3VzU3RhdGVfID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IDA7XG4gICAgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8gPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURvd25fKGV2dCk7XG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWRvd25fKGV2dCk7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVGb2N1c18oKTtcbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlQmx1cl8oKTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5pc0Rpc2NyZXRlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5JU19ESVNDUkVURSk7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEFTX1RSQUNLX01BUktFUik7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4gdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXykpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMudGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMubGF5b3V0KCk7XG4gICAgLy8gQXQgbGFzdCBzdGVwLCBwcm92aWRlIGEgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlIHRvIGRpc2NyZXRlIHNsaWRlclxuICAgIGlmICh0aGlzLmlzRGlzY3JldGVfICYmIHRoaXMuZ2V0U3RlcCgpID09IDApIHtcbiAgICAgIHRoaXMuc3RlcF8gPSAxO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIERPV05fRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMudGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICBzZXR1cFRyYWNrTWFya2VyKCkge1xuICAgIGlmICh0aGlzLmlzRGlzY3JldGVfICYmIHRoaXMuaGFzVHJhY2tNYXJrZXJfJiYgdGhpcy5nZXRTdGVwKCkgIT0gMCkge1xuICAgICAgY29uc3QgbWluID0gdGhpcy5nZXRNaW4oKTtcbiAgICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0TWF4KCk7XG4gICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRTdGVwKCk7XG4gICAgICBsZXQgbnVtTWFya2VycyA9IChtYXggLSBtaW4pIC8gc3RlcDtcblxuICAgICAgLy8gSW4gY2FzZSBkaXN0YW5jZSBiZXR3ZWVuIG1heCAmIG1pbiBpcyBpbmRpdmlzaWJsZSB0byBzdGVwLFxuICAgICAgLy8gd2UgcGxhY2UgdGhlIHNlY29uZGFyeSB0byBsYXN0IG1hcmtlciBwcm9wb3J0aW9uYWxseSBhdCB3aGVyZSB0aHVtYlxuICAgICAgLy8gY291bGQgcmVhY2ggYW5kIHBsYWNlIHRoZSBsYXN0IG1hcmtlciBhdCBtYXggdmFsdWVcbiAgICAgIGNvbnN0IGluZGl2aXNpYmxlID0gTWF0aC5jZWlsKG51bU1hcmtlcnMpICE9PSBudW1NYXJrZXJzO1xuICAgICAgaWYgKGluZGl2aXNpYmxlKSB7XG4gICAgICAgIG51bU1hcmtlcnMgPSBNYXRoLmNlaWwobnVtTWFya2Vycyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlVHJhY2tNYXJrZXJzKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFwcGVuZFRyYWNrTWFya2VycyhudW1NYXJrZXJzKTtcblxuICAgICAgaWYgKGluZGl2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTdGVwUmF0aW8gPSAobWF4IC0gbnVtTWFya2VycyAqIHN0ZXApIC8gc3RlcCArIDE7XG4gICAgICAgIGNvbnN0IGZsZXggPSBnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ2ZsZXgnKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShmbGV4LCBTdHJpbmcobGFzdFN0ZXBSYXRpbykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICB0aGlzLnJlY3RfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWF4KCkge1xuICAgIHJldHVybiB0aGlzLm1heF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1heCAqL1xuICBzZXRNYXgobWF4KSB7XG4gICAgaWYgKG1heCA8IHRoaXMubWluXykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1heCB0byBiZSBsZXNzIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWluaW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1heF8gPSBtYXg7XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNQVgsIFN0cmluZyh0aGlzLm1heF8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldE1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5taW5fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBtaW4gKi9cbiAgc2V0TWluKG1pbikge1xuICAgIGlmIChtaW4gPiB0aGlzLm1heF8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBtaW4gdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSBzbGlkZXJcXCdzIG1heGltdW0gdmFsdWUnKTtcbiAgICB9XG4gICAgdGhpcy5taW5fID0gbWluO1xuICAgIHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX1ZBTFVFTUlOLCBTdHJpbmcodGhpcy5taW5fKSk7XG4gICAgdGhpcy5zZXR1cFRyYWNrTWFya2VyKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICovXG4gIHNldFN0ZXAoc3RlcCkge1xuICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGVwIGNhbm5vdCBiZSBzZXQgdG8gYSBuZWdhdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgKHR5cGVvZihzdGVwKSAhPT0gJ251bWJlcicgfHwgc3RlcCA8IDEpKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICB9XG4gICAgdGhpcy5zdGVwXyA9IHN0ZXA7XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBkaXNhYmxlZDtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzXyhjc3NDbGFzc2VzLkRJU0FCTEVELCB0aGlzLmRpc2FibGVkXyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVELCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cmlidXRlKHN0cmluZ3MuQVJJQV9ESVNBQkxFRCk7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuc2F2ZWRUYWJJbmRleF8pKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIFN0cmluZyh0aGlzLnNhdmVkVGFiSW5kZXhfKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBpbnRlcmFjdGluZyB3aXRoIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRG93bl8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSB0cnVlO1xuICAgIHRoaXMuc2V0SW5UcmFuc2l0XyghdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0Xyk7XG4gICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QWN0aXZlXyh0cnVlKTtcblxuICAgIGNvbnN0IG1vdmVIYW5kbGVyID0gKGV2dCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlXyhldnQpO1xuICAgIH07XG5cbiAgICAvLyBOb3RlOiB1cEhhbmRsZXIgaXMgW2RlXXJlZ2lzdGVyZWQgb24gQUxMIHBvdGVudGlhbCBwb2ludGVyLXJlbGF0ZWQgcmVsZWFzZSBldmVudCB0eXBlcywgc2luY2Ugc29tZSBicm93c2Vyc1xuICAgIC8vIGRvIG5vdCBhbHdheXMgZmlyZSB0aGVzZSBjb25zaXN0ZW50bHkgaW4gcGFpcnMuXG4gICAgLy8gKFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9pc3N1ZXMvMTE5MilcbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVVwXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihNT1ZFX0VWRU5UX01BUFtldnQudHlwZV0sIG1vdmVIYW5kbGVyKTtcbiAgICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHVwSGFuZGxlcikpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihNT1ZFX0VWRU5UX01BUFtldnQudHlwZV0sIG1vdmVIYW5kbGVyKTtcbiAgICBVUF9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4gdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgdGhpcy5zZXRWYWx1ZUZyb21FdnRfKGV2dCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVNb3ZlXyhldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlcidzIGludGVyYWN0aW9uIHdpdGggdGhlIHNsaWRlciBlbmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVVcF8oKSB7XG4gICAgdGhpcy5zZXRBY3RpdmVfKGZhbHNlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhZ2VYIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBhZ2VYXyhldnQpIHtcbiAgICBpZiAoZXZ0LnRhcmdldFRvdWNoZXMgJiYgZXZ0LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGV2dC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIH1cbiAgICByZXR1cm4gZXZ0LnBhZ2VYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNsaWRlciB2YWx1ZSBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFZhbHVlRnJvbUV2dF8oZXZ0KSB7XG4gICAgY29uc3QgcGFnZVggPSB0aGlzLmdldFBhZ2VYXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKTtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG5ldyB2YWx1ZSBmcm9tIHRoZSBwYWdlWCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyhwYWdlWCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbn0gPSB0aGlzO1xuICAgIGNvbnN0IHhQb3MgPSBwYWdlWCAtIHRoaXMucmVjdF8ubGVmdDtcbiAgICBsZXQgcGN0Q29tcGxldGUgPSB4UG9zIC8gdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICBwY3RDb21wbGV0ZSA9IDEgLSBwY3RDb21wbGV0ZTtcbiAgICB9XG4gICAgLy8gRml0IHRoZSBwZXJjZW50YWdlIGNvbXBsZXRlIGJldHdlZW4gdGhlIHJhbmdlIFttaW4sbWF4XVxuICAgIC8vIGJ5IHJlbWFwcGluZyBmcm9tIFswLCAxXSB0byBbbWluLCBtaW4rKG1heC1taW4pXS5cbiAgICByZXR1cm4gbWluICsgcGN0Q29tcGxldGUgKiAobWF4IC0gbWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUtleWRvd25fKGV2dCkge1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZF8oZXZ0KTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JLZXlJZF8oa2V5SWQpO1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHBhZ2UgZnJvbSBzY3JvbGxpbmcgZHVlIHRvIGtleSBwcmVzc2VzIHRoYXQgd291bGQgbm9ybWFsbHkgc2Nyb2xsIHRoZSBwYWdlXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0ga2JkRXZ0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEtleUlkXyhrYmRFdnQpIHtcbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzNykge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfTEVGVDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfUklHSFQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM5KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19SSUdIVDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfVVAgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM4KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19VUDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX0RPV047XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkhPTUUgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM2KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5IT01FO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5FTkQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM1KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5FTkQ7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfVVAgfHwga2JkRXZ0LmtleUNvZGUgPT09IDMzKSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5QQUdFX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5QQUdFX0RPV04gfHwga2JkRXZ0LmtleUNvZGUgPT09IDM0KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5QQUdFX0RPV047XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB2YWx1ZSBnaXZlbiBhIGtleWJvYXJkIGtleSBJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5SWRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VmFsdWVGb3JLZXlJZF8oa2V5SWQpIHtcbiAgICBjb25zdCB7bWF4XzogbWF4LCBtaW5fOiBtaW4sIHN0ZXBfOiBzdGVwfSA9IHRoaXM7XG4gICAgbGV0IGRlbHRhID0gc3RlcCB8fCAobWF4IC0gbWluKSAvIDEwMDtcbiAgICBjb25zdCB2YWx1ZU5lZWRzVG9CZUZsaXBwZWQgPSB0aGlzLmFkYXB0ZXJfLmlzUlRMKCkgJiYgKFxuICAgICAga2V5SWQgPT09IEtFWV9JRFMuQVJST1dfTEVGVCB8fCBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVFxuICAgICk7XG4gICAgaWYgKHZhbHVlTmVlZHNUb0JlRmxpcHBlZCkge1xuICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgfVxuXG4gICAgc3dpdGNoIChrZXlJZCkge1xuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19MRUZUOlxuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19ET1dOOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfIC0gZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1JJR0hUOlxuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19VUDpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyArIGRlbHRhO1xuICAgIGNhc2UgS0VZX0lEUy5IT01FOlxuICAgICAgcmV0dXJuIHRoaXMubWluXztcbiAgICBjYXNlIEtFWV9JRFMuRU5EOlxuICAgICAgcmV0dXJuIHRoaXMubWF4XztcbiAgICBjYXNlIEtFWV9JRFMuUEFHRV9VUDpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyArIGRlbHRhICogbnVtYmVycy5QQUdFX0ZBQ1RPUjtcbiAgICBjYXNlIEtFWV9JRFMuUEFHRV9ET1dOOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfIC0gZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzXygpIHtcbiAgICBpZiAodGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgfVxuXG4gIGhhbmRsZUJsdXJfKCkge1xuICAgIHRoaXMucHJldmVudEZvY3VzU3RhdGVfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEZpcmVJbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVxuICAgKi9cbiAgc2V0VmFsdWVfKHZhbHVlLCBzaG91bGRGaXJlSW5wdXQsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMudmFsdWVfICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHttaW5fOiBtaW4sIG1heF86IG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhbHVlU2V0VG9Cb3VuZGFyeSA9IHZhbHVlID09PSBtaW4gfHwgdmFsdWUgPT09IG1heDtcbiAgICBpZiAodGhpcy5zdGVwXyAmJiAhdmFsdWVTZXRUb0JvdW5kYXJ5KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucXVhbnRpemVfKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICB2YWx1ZSA9IG1pbjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICB2YWx1ZSA9IG1heDtcbiAgICB9XG4gICAgdGhpcy52YWx1ZV8gPSB2YWx1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVOT1csIFN0cmluZyh0aGlzLnZhbHVlXykpO1xuICAgIHRoaXMudXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCk7XG5cbiAgICBpZiAoc2hvdWxkRmlyZUlucHV0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUlucHV0KCk7XG4gICAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldE1hcmtlclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcXVhbnRpemVkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBxdWFudGl6ZV8odmFsdWUpIHtcbiAgICBjb25zdCBudW1TdGVwcyA9IE1hdGgucm91bmQodmFsdWUgLyB0aGlzLnN0ZXBfKTtcbiAgICBjb25zdCBxdWFudGl6ZWRWYWwgPSBudW1TdGVwcyAqIHRoaXMuc3RlcF87XG4gICAgcmV0dXJuIHF1YW50aXplZFZhbDtcbiAgfVxuXG4gIHVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpIHtcbiAgICBjb25zdCB7bWF4XzogbWF4LCBtaW5fOiBtaW4sIHZhbHVlXzogdmFsdWV9ID0gdGhpcztcbiAgICBjb25zdCBwY3RDb21wbGV0ZSA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICBsZXQgdHJhbnNsYXRlUHggPSBwY3RDb21wbGV0ZSAqIHRoaXMucmVjdF8ud2lkdGg7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNSVEwoKSkge1xuICAgICAgdHJhbnNsYXRlUHggPSB0aGlzLnJlY3RfLndpZHRoIC0gdHJhbnNsYXRlUHg7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAndHJhbnNmb3JtJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbmVuZEV2dE5hbWUgPSBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKTtcblxuICAgIGlmICh0aGlzLmluVHJhbnNpdF8pIHtcbiAgICAgIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRJblRyYW5zaXRfKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHRyYW5zaXRpb25lbmRFdnROYW1lLCBvblRyYW5zaXRpb25FbmQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVUlGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gTk9URSh0cmF2aXNrYXVmbWFuKTogSXQgd291bGQgYmUgbmljZSB0byB1c2UgY2FsYygpIGhlcmUsXG4gICAgICAvLyBidXQgSUUgY2Fubm90IGhhbmRsZSBjYWxjcyBpbiB0cmFuc2Zvcm1zIGNvcnJlY3RseS5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9nb28uZ2wvTkMyaXRrXG4gICAgICAvLyBBbHNvIG5vdGUgdGhhdCB0aGUgLTUwJSBvZmZzZXQgaXMgdXNlZCB0byBjZW50ZXIgdGhlIHNsaWRlciB0aHVtYi5cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHRyYW5zZm9ybVByb3AsIGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlUHh9cHgpIHRyYW5zbGF0ZVgoLTUwJSlgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhY2tTdHlsZVByb3BlcnR5KHRyYW5zZm9ybVByb3AsIGBzY2FsZVgoJHtwY3RDb21wbGV0ZX0pYCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmVcbiAgICovXG4gIHNldEFjdGl2ZV8oYWN0aXZlKSB7XG4gICAgdGhpcy5hY3RpdmVfID0gYWN0aXZlO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuQUNUSVZFLCB0aGlzLmFjdGl2ZV8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGluVHJhbnNpdCBzdGF0ZSBvZiB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5UcmFuc2l0XG4gICAqL1xuICBzZXRJblRyYW5zaXRfKGluVHJhbnNpdCkge1xuICAgIHRoaXMuaW5UcmFuc2l0XyA9IGluVHJhbnNpdDtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzXyhjc3NDbGFzc2VzLklOX1RSQU5TSVQsIHRoaXMuaW5UcmFuc2l0Xyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSBhZGRzIG9yIHJlbW92ZXMgYSBjbGFzcyBiYXNlZCBvbiBzaG91bGRCZVByZXNlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEJlUHJlc2VudFxuICAgKi9cbiAgdG9nZ2xlQ2xhc3NfKGNsYXNzTmFtZSwgc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgaWYgKHNob3VsZEJlUHJlc2VudCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NsaWRlckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzbGlkZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2stY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIiA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlci1jb250YWluZXJcIiB2LWlmPVwiaGFzTWFya2Vyc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2stbWFya2VyXCIgXG4gICAgICAgICAgdi1mb3I9XCJtYXJrZXJOdW0gaW4gbnVtTWFya2Vyc1wiXG4gICAgICAgICAgOmtleT1cIm1hcmtlck51bVwiXG4gICAgICAgICAgOnN0eWxlPVwiKG1hcmtlck51bSA9PSBudW1NYXJrZXJzKSA/IGxhc3RUcmFja01hcmtlcnNTdHlsZXMgOiB7fVwiXG4gICAgICAgICAgPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiByZWY9XCJ0aHVtYkNvbnRhaW5lclwiIDpzdHlsZT1cInRodW1iU3R5bGVzXCIgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYi1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19waW5cIiB2LWlmPVwiaXNEaXNjcmV0ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm1kYy1zbGlkZXJfX3Bpbi12YWx1ZS1tYXJrZXJcIj57e21hcmtlclZhbHVlfX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzdmcgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYlwiIHdpZHRoPVwiMjFcIiBoZWlnaHQ9XCIyMVwiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI3Ljg3NVwiPjwvY2lyY2xlPlxuICAgICAgPC9zdmc+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fZm9jdXMtcmluZ1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHsgRGlzcGF0Y2hGb2N1c01peGluIH0gZnJvbSAnLi4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnLFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIG1pbjogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgbWF4OiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDEwMCB9LFxuICAgIHN0ZXA6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMCB9LFxuICAgIGRpc3BsYXlNYXJrZXJzOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxheW91dE9uOiBTdHJpbmcsXG4gICAgbGF5b3V0T25Tb3VyY2U6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2UgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNsaWRlci0tZGlzY3JldGUnOiAhIXRoaXMuc3RlcCxcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2Vycyc6IHRoaXMuZGlzcGxheU1hcmtlcnMsXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwLFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNEaXNjcmV0ZSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc3RlcDtcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnM7XG4gICAgfSxcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSAhPT0gTnVtYmVyKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSk7XG4gICAgfSxcbiAgICBtYXgoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgIH0sXG4gICAgc3RlcCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTdGVwKE51bWJlcih0aGlzLnN0ZXApKTtcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBnZXRBdHRyaWJ1dGU6IG5hbWUgPT4gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKG5hbWUpLFxuICAgICAgc2V0QXR0cmlidXRlOiAobmFtZSwgdmFsdWUpID0+IHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSksXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6IG5hbWUgPT4gdGhpcy4kZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRUYWJJbmRleDogKCkgPT4gdGhpcy4kZWwudGFiSW5kZXgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBub3RpZnlJbnB1dDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKTtcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpO1xuICAgICAgfSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudGh1bWJTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudHJhY2tTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6IG51bU1hcmtlcnMgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSBudW1NYXJrZXJzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVRyYWNrTWFya2VyczogKCkgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSAwO1xuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBpc1JUTDogKCkgPT4gZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKTtcbiAgICBpZiAoTnVtYmVyKHRoaXMubWluKSA8PSB0aGlzLmZvdW5kYXRpb24uZ2V0TWF4KCkpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSk7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldE1pbihOdW1iZXIodGhpcy5taW4pKTtcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZShOdW1iZXIodGhpcy52YWx1ZSkpO1xuICAgIGlmICh0aGlzLmhhc01hcmtlcnMpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXR1cFRyYWNrTWFya2VyKCk7XG4gICAgfVxuXG4gICAgdGhpcy4kcm9vdC4kb24oJ21kYzpsYXlvdXQnLCB0aGlzLmxheW91dCk7XG5cbiAgICBpZiAodGhpcy5sYXlvdXRPbikge1xuICAgICAgbGV0IHNvdXJjZSA9IHRoaXMubGF5b3V0T25Tb3VyY2UgfHwgdGhpcy4kcm9vdDtcbiAgICAgIHNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNTbGlkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NsaWRlclxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1zbmFja2JhcicsXG4gIFRFWFQ6ICdtZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUjogJ21kYy1zbmFja2Jhcl9fYWN0aW9uLXdyYXBwZXInLFxuICBBQ1RJT05fQlVUVE9OOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uJyxcbiAgQUNUSVZFOiAnbWRjLXNuYWNrYmFyLS1hY3RpdmUnLFxuICBNVUxUSUxJTkU6ICdtZGMtc25hY2tiYXItLW11bHRpbGluZScsXG4gIEFDVElPTl9PTl9CT1RUT006ICdtZGMtc25hY2tiYXItLWFjdGlvbi1vbi1ib3R0b20nLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRFWFRfU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX190ZXh0JyxcbiAgQUNUSU9OX1dSQVBQRVJfU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT05fU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uJyxcbiAgU0hPV19FVkVOVDogJ01EQ1NuYWNrYmFyOnNob3cnLFxuICBISURFX0VWRU5UOiAnTURDU25hY2tiYXI6aGlkZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUVTU0FHRV9USU1FT1VUOiAyNzUwLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1NuYWNrYmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+IHt9LFxuICAgICAgc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICB1bnNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+IHt9LFxuICAgICAgc2V0QWN0aW9uVGV4dDogKC8qIGFjdGlvblRleHQ6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNZXNzYWdlVGV4dDogKC8qIG1lc3NhZ2U6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRGb2N1czogKCkgPT4ge30sXG4gICAgICB2aXNpYmlsaXR5SXNIaWRkZW46ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SGlkZTogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlXztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NuYWNrYmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5hY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5hY3Rpb25XYXNDbGlja2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9IHRydWU7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5wb2ludGVyRG93blJlY29nbml6ZWRfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IGZhbHNlO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZV8gPSBbXTtcbiAgICB0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52b2tlQWN0aW9uXygpO1xuICAgIH07XG4gICAgdGhpcy52aXNpYmlsaXR5Y2hhbmdlSGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8udmlzaWJpbGl0eUlzSGlkZGVuKCkpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNsZWFudXBfLmJpbmQodGhpcyksIHRoaXMuc25hY2tiYXJEYXRhXy50aW1lb3V0IHx8IG51bWJlcnMuTUVTU0FHRV9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQudHlwZSA9PSAndG91Y2hzdGFydCcgfHwgZXZ0LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyRG93blJlY29nbml6ZWRfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlUG9zc2libGVUYWJLZXlib2FyZEZvY3VzXyhldnQpO1xuXG4gICAgICBpZiAoZXZ0LnR5cGUgPT0gJ2ZvY3VzJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyKHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIodGhpcy52aXNpYmlsaXR5Y2hhbmdlSGFuZGxlcl8pO1xuICAgIFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nLCAnZm9jdXMnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzbWlzc2VzT25BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzbWlzc09uQWN0aW9uXztcbiAgfVxuXG4gIHNldERpc21pc3NPbkFjdGlvbihkaXNtaXNzT25BY3Rpb24pIHtcbiAgICB0aGlzLmRpc21pc3NPbkFjdGlvbl8gPSAhIWRpc21pc3NPbkFjdGlvbjtcbiAgfVxuXG4gIHNob3coZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUGxlYXNlIHByb3ZpZGUgYSBkYXRhIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgbWVzc2FnZSB0byBkaXNwbGF5LicpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5hY3Rpb25IYW5kbGVyICYmICFkYXRhLmFjdGlvblRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYWN0aW9uIHRleHQgd2l0aCB0aGUgaGFuZGxlci4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLnF1ZXVlXy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICB0aGlzLnNuYWNrYmFyRGF0YV8gPSBkYXRhO1xuICAgIHRoaXMuZmlyc3RGb2N1c18gPSB0cnVlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXIodGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nLCAnZm9jdXMnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHtBQ1RJVkUsIE1VTFRJTElORSwgQUNUSU9OX09OX0JPVFRPTX0gPSBjc3NDbGFzc2VzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZXNzYWdlVGV4dCh0aGlzLnNuYWNrYmFyRGF0YV8ubWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLm11bHRpbGluZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNVUxUSUxJTkUpO1xuICAgICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25PbkJvdHRvbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElPTl9PTl9CT1RUT00pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8uYWN0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25UZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25UZXh0KTtcbiAgICAgIHRoaXMuYWN0aW9uSGFuZGxlcl8gPSB0aGlzLnNuYWNrYmFyRGF0YV8uYWN0aW9uSGFuZGxlcjtcbiAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgIHRoaXMuYWN0aW9uSGFuZGxlcl8gPSBudWxsO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25UZXh0KG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhBQ1RJVkUpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTaG93KCk7XG5cbiAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICB9XG5cbiAgaGFuZGxlUG9zc2libGVUYWJLZXlib2FyZEZvY3VzXygpIHtcbiAgICBjb25zdCBoaWphY2tGb2N1cyA9XG4gICAgICB0aGlzLmZpcnN0Rm9jdXNfICYmICF0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF87XG5cbiAgICBpZiAoaGlqYWNrRm9jdXMpIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNPbkFjdGlvbl8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBzZXRGb2N1c09uQWN0aW9uXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEZvY3VzKCk7XG4gICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IGZhbHNlO1xuICB9XG5cbiAgaW52b2tlQWN0aW9uXygpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmFjdGlvbkhhbmRsZXJfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5kaXNtaXNzT25BY3Rpb25fKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cF8oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhbnVwXygpIHtcbiAgICBjb25zdCBhbGxvd0Rpc21pc3NhbCA9ICF0aGlzLnNuYWNrYmFySGFzRm9jdXNfIHx8IHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF87XG5cbiAgICBpZiAoYWxsb3dEaXNtaXNzYWwpIHtcbiAgICAgIGNvbnN0IHtBQ1RJVkUsIE1VTFRJTElORSwgQUNUSU9OX09OX0JPVFRPTX0gPSBjc3NDbGFzc2VzO1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEFDVElWRSk7XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNVUxUSUxJTkUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEFDVElPTl9PTl9CT1RUT00pO1xuICAgICAgICB0aGlzLnNldEFjdGlvbkhpZGRlbl8odHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgICAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUhpZGUoKTtcbiAgICAgICAgdGhpcy5zaG93TmV4dF8oKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBzaG93TmV4dF8oKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlXy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zaG93KHRoaXMucXVldWVfLnNoaWZ0KCkpO1xuICB9XG5cbiAgc2V0QWN0aW9uSGlkZGVuXyhpc0hpZGRlbikge1xuICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25BcmlhSGlkZGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW5zZXRBY3Rpb25BcmlhSGlkZGVuKCk7XG4gICAgfVxuICB9XG59XG4iLCI8dGVtcGxhdGU+XG48ZGl2IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1zbmFja2JhclwiIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiIDphcmlhLWhpZGRlbj1cImhpZGRlblwiPlxuICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX190ZXh0XCI+e3ttZXNzYWdlfX08L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fYWN0aW9uLXdyYXBwZXJcIj5cbiAgICA8YnV0dG9uIHJlZj1cImJ1dHRvblwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fYWN0aW9uLWJ1dHRvblwiXG4gICAgICAgIDphcmlhLWhpZGRlbj1cImFjdGlvbkhpZGRlblwiPnt7YWN0aW9uVGV4dH19PC9idXR0b24+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1NuYWNrYmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbidcbmltcG9ydCB7IGdldENvcnJlY3RFdmVudE5hbWUgfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc25hY2tiYXInLFxuICBwcm9wczoge1xuICAgICdhbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2V2ZW50Jzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCAoKSB7IHJldHVybiAnc2hvdy1zbmFja2JhcicgfVxuICAgIH0sXG4gICAgJ2V2ZW50LXNvdXJjZSc6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdCB9XG4gICAgfSxcbiAgICAnZGlzbWlzc2VzLW9uLWFjdGlvbic6IHt0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlfVxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNuYWNrYmFyLS1hbGlnbi1zdGFydCc6IHRoaXMuYWxpZ25TdGFydFxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgYWN0aW9uVGV4dDogJycsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgYWN0aW9uSGlkZGVuOiBmYWxzZSxcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaG93IChkYXRhKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2hvdyhkYXRhKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1NuYWNrYmFyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4gdGhpcy5oaWRkZW4gPSB0cnVlLFxuICAgICAgdW5zZXRBcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmhpZGRlbiA9IGZhbHNlLFxuICAgICAgc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4gdGhpcy5hY3Rpb25IaWRkZW4gPSB0cnVlLFxuICAgICAgdW5zZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmFjdGlvbkhpZGRlbiA9IGZhbHNlLFxuICAgICAgc2V0QWN0aW9uVGV4dDogKHRleHQpID0+IHsgdGhpcy5hY3Rpb25UZXh0ID0gdGV4dCB9LFxuICAgICAgc2V0TWVzc2FnZVRleHQ6ICh0ZXh0KSA9PiB7IHRoaXMubWVzc2FnZSA9IHRleHQgIH0sXG4gICAgICBzZXRGb2N1czogKCkgPT4gdGhpcy4kcmVmcy5idXR0b24uZm9jdXMoKSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gZG9jdW1lbnQuaGlkZGVuLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlciwgdHJ1ZSksXG4gICAgICByZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHRoaXMuJGVtaXQoJ3Nob3cnKSxcbiAgICAgIG5vdGlmeUhpZGU6ICgpID0+IHRoaXMuJGVtaXQoJ2hpZGUnKSxcbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICBpZiAodGhpcy5ldmVudCkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS4kb24odGhpcy5ldmVudCwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNob3coZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNtaXNzT25BY3Rpb24odGhpcy5kaXNtaXNzZXNPbkFjdGlvbilcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTbmFja2JhciBmcm9tICcuL21kYy1zbmFja2Jhci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1NuYWNrYmFyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbmFja2JhclxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2gtd3JhcHBlclwiIFxuICAgIDpjbGFzcz1cIntcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkJzogdGhpcy5oYXNMYWJlbCxcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiB0aGlzLmhhc0xhYmVsICYmIHRoaXMuYWxpZ25FbmRcbiAgICAgIH1cIiA+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaFwiIFxuICAgICAgOmNsYXNzPVwieydtZGMtc3dpdGNoLS1kaXNhYmxlZCc6IGRpc2FibGVkIH1cIj5cbiAgICAgIDxpbnB1dCByZWY9XCJjb250cm9sXCIgdHlwZT1cImNoZWNrYm94XCIgXG4gICAgICAgIDpuYW1lPVwibmFtZVwiIDppZD1cIl91aWRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoX19uYXRpdmUtY29udHJvbFwiIFxuICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRcIiBcbiAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VkXCIgLz5cblxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2tub2JcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8bGFiZWwgOmZvcj1cIl91aWRcIiB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoLWxhYmVsXCI+XG4gICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXN3aXRjaCcsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICdjaGVja2VkJzogQm9vbGVhbixcbiAgICAnbGFiZWwnOiBTdHJpbmcsXG4gICAgJ2FsaWduRW5kJzogQm9vbGVhbixcbiAgICAnZGlzYWJsZWQnOiBCb29sZWFuLFxuICAgICd2YWx1ZSc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0ICgpIHsgcmV0dXJuICdvbicgfSB9LFxuICAgICduYW1lJzogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlZCAoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2ZW50LnRhcmdldC5jaGVja2VkKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU3dpdGNoIGZyb20gJy4vbWRjLXN3aXRjaC52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1N3aXRjaFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU3dpdGNoXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy10YWItLWFjdGl2ZScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgU0VMRUNURURfRVZFTlQ6ICdNRENUYWI6c2VsZWN0ZWQnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1RhYkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlTZWxlY3RlZDogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IDA7XG4gICAgdGhpcy5jb21wdXRlZExlZnRfID0gMDtcbiAgICB0aGlzLmlzQWN0aXZlXyA9IGZhbHNlO1xuICAgIHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXykge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNlbGVjdGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGdldENvbXB1dGVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRXaWR0aF87XG4gIH1cblxuICBnZXRDb21wdXRlZExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRMZWZ0XztcbiAgfVxuXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQWN0aXZlXztcbiAgfVxuXG4gIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xuICAgIHRoaXMuaXNBY3RpdmVfID0gaXNBY3RpdmU7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmVfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgfVxuICB9XG5cbiAgcHJldmVudHNEZWZhdWx0T25DbGljaygpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfO1xuICB9XG5cbiAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaykge1xuICAgIHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXyA9IHByZXZlbnREZWZhdWx0T25DbGljaztcbiAgfVxuXG4gIG1lYXN1cmVTZWxmKCkge1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgdGhpcy5jb21wdXRlZExlZnRfID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRMZWZ0KCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgY2xhc3M9XCJtZGMtdGFiXCIgXHJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCJcclxuICAgIDpsaW5rPVwibGlua1wiIFxyXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxyXG5cclxuICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNJY29uXCJcclxuICAgICAgdGFiaW5kZXg9XCIwXCIgXHJcbiAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiICBcclxuICAgICAgOmNsYXNzPVwiaGFzSWNvbi5jbGFzc2VzXCI+XHJcbiAgICAgIDxzbG90IG5hbWU9XCJpY29uXCI+e3sgaGFzSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgPC9pPlxyXG5cclxuICAgIDxzcGFuIDpjbGFzcz1cInsnbWRjLXRhYl9faWNvbi10ZXh0JzogISFoYXNJY29ufVwiIHYtaWY9XCJoYXNUZXh0XCI+XHJcbiAgICAgIDxzbG90Pjwvc2xvdD4gIFxyXG4gICAgPC9zcGFuPlxyXG5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXHJcbmltcG9ydCB7Q3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW4sIGVtaXRDdXN0b21FdmVudCwgZXh0cmFjdEljb25Qcm9wIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy10YWInLFxyXG4gIG1peGluczogW0N1c3RvbUxpbmtNaXhpbiwgRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgYWN0aXZlOiBCb29sZWFuLFxyXG4gICAgaWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmljb24gfHwgdGhpcy4kc2xvdHMuaWNvbikge1xyXG4gICAgICAgIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0ICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHMuZGVmYXVsdFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgZ2V0Q29tcHV0ZWRXaWR0aCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uZ2V0Q29tcHV0ZWRXaWR0aCgpXHJcbiAgICB9LFxyXG4gICAgZ2V0Q29tcHV0ZWRMZWZ0ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5nZXRDb21wdXRlZExlZnQoKVxyXG4gICAgfSxcclxuICAgIGlzQWN0aXZlICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0FjdGl2ZSgpXHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aXZlIChpc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QWN0aXZlKGlzQWN0aXZlKVxyXG4gICAgfSxcclxuICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2sgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLnByZXZlbnRzRGVmYXVsdE9uQ2xpY2soKVxyXG4gICAgfSxcclxuICAgIHNldFByZXZlbnREZWZhdWx0T25DbGljayAocHJldmVudERlZmF1bHRPbkNsaWNrKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKVxyXG4gICAgfSxcclxuICAgIG1lYXN1cmVTZWxmICgpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLm1lYXN1cmVTZWxmKClcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkZvdW5kYXRpb24oe1xyXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxyXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxyXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZWwub2Zmc2V0V2lkdGhcclxuICAgICAgfSxcclxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT5cclxuICAgICAgICB0aGlzLiRlbC5vZmZzZXRMZWZ0LFxyXG4gICAgICBub3RpZnlTZWxlY3RlZDogKCkgPT4ge1xyXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCxcclxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwge3RhYjogdGhpc30sIHRydWUpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB0aGlzLnNldEFjdGl2ZSh0aGlzLmFjdGl2ZSlcclxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcclxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy10YWItYmFyLXVwZ3JhZGVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUQUJfU0VMRUNUT1I6ICcubWRjLXRhYicsXG4gIElORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWJhcl9faW5kaWNhdG9yJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDVGFiQmFyOmNoYW5nZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2dldENvcnJlY3RQcm9wZXJ0eU5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge30sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JJbmRpY2F0b3I6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7YWN0aXZlVGFiSW5kZXg6IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBzZXRUYWJBY3RpdmVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgaXNBY3RpdmU6IHRydWUgKi8pID0+IHt9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIHByZXZlbnREZWZhdWx0T25DbGljazogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiQmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5pc0luZGljYXRvclNob3duXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSAwO1xuICAgIHRoaXMuY29tcHV0ZWRMZWZ0XyA9IDA7XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSAwO1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IGFjdGl2ZVRhYkluZGV4O1xuICAgIH1cbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZvckVhY2hUYWJJbmRleF8oKGluZGV4KSA9PiB0aGlzLmFkYXB0ZXJfLm1lYXN1cmVUYWJBdEluZGV4KGluZGV4KSk7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgfVxuXG4gIGxheW91dEluZGljYXRvcl8oKSB7XG4gICAgY29uc3QgaXNJbmRpY2F0b3JGaXJzdFJlbmRlciA9ICF0aGlzLmlzSW5kaWNhdG9yU2hvd25fO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgaW5kaWNhdG9yIGFwcGVhcnMgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uIGltbWVkaWF0ZWx5IGZvciBjb3JyZWN0IGZpcnN0IHJlbmRlci5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndHJhbnNpdGlvbicsICdub25lJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4Xyk7XG4gICAgY29uc3Qgc2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aCA9XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfKSAvIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlID0gYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVBbXRGb3JBY3RpdmVUYWJMZWZ0fXB4KSBzY2FsZSgke3NjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGh9LCAxKWA7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcihnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ3RyYW5zZm9ybScpLCB0cmFuc2Zvcm1WYWx1ZSk7XG5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgLy8gRm9yY2UgbGF5b3V0IHNvIHRoYXQgdHJhbnNmb3JtIHN0eWxlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3IoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgIHRoaXMuaXNJbmRpY2F0b3JTaG93bl8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRBY3RpdmVUYWJJbmRleF8oKSB7XG4gICAgbGV0IGFjdGl2ZVRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy5mb3JFYWNoVGFiSW5kZXhfKChpbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNUYWJBY3RpdmVBdEluZGV4KGluZGV4KSkge1xuICAgICAgICBhY3RpdmVUYWJJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlVGFiSW5kZXg7XG4gIH1cblxuICBmb3JFYWNoVGFiSW5kZXhfKGl0ZXJhdG9yKSB7XG4gICAgY29uc3QgbnVtVGFicyA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUYWJzKCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVRhYnM7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gaXRlcmF0b3IoaW5kZXgpO1xuICAgICAgaWYgKHNob3VsZEJyZWFrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG5cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCBzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWN0aXZlVGFiSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mVGFicygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBvZiBib3VuZHMgaW5kZXggc3BlY2lmaWVkIGZvciB0YWI6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkFjdGl2ZVRhYkluZGV4ID0gdGhpcy5hY3RpdmVUYWJJbmRleF87XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSBpbmRleDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHByZXZBY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleChwcmV2QWN0aXZlVGFiSW5kZXgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4XywgdHJ1ZSk7XG4gICAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2FjdGl2ZVRhYkluZGV4OiB0aGlzLmFjdGl2ZVRhYkluZGV4X30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtdGFiLWJhclwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPHNwYW4gcmVmPVwiaW5kaWNhdG9yXCIgY2xhc3M9XCJtZGMtdGFiLWJhcl9faW5kaWNhdG9yXCIgXG4gICAgICA6c3R5bGU9XCJpbmRpY2F0b3JTdHlsZXNcIj48L3NwYW4+XG4gIDwvbmF2PiAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RhYkJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10YWItYmFyJyxcbiAgcHJvcHM6IHtcbiAgICAnaW5kaWNhdG9yLXByaW1hcnknOiBCb29sZWFuLFxuICAgICdpbmRpY2F0b3ItYWNjZW50JzogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRhYi1iYXItLWluZGljYXRvci1wcmltYXJ5JzogdGhpcy5pbmRpY2F0b3JQcmltYXJ5LFxuICAgICAgICAnbWRjLXRhYi1iYXItLWluZGljYXRvci1hY2NlbnQnOiB0aGlzLmluZGljYXRvckFjY2VudFxuICAgICAgfSxcbiAgICAgIGluZGljYXRvclN0eWxlczoge30sXG4gICAgICB0YWJzOiBbXVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU2VsZWN0ICh7ZGV0YWlsfSkge1xuICAgICAgY29uc3Qge3RhYn0gPSBkZXRhaWxcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzLmluZGV4T2YodGFiKVxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21kYy10YWItYmFyIGludGVybmFsIGVycm9yOiBpbmRleCBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleChpbmRleCwgdHJ1ZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUYWJCYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PlxuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB0aGlzLm9uU2VsZWN0KVxuICAgICAgfSxcbiAgICAgIHVuYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT5cbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHRoaXMub25TZWxlY3QpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT5cbiAgICAgICAgdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICBzZXRTdHlsZUZvckluZGljYXRvcjogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmluZGljYXRvclN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5pbmRpY2F0b3Iub2Zmc2V0V2lkdGgsXG4gICAgICBub3RpZnlDaGFuZ2U6IChldnREYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2dERhdGEuYWN0aXZlVGFiSW5kZXgpXG4gICAgICB9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PlxuICAgICAgICB0aGlzLnRhYnMubGVuZ3RoLFxuICAgICAgaXNUYWJBY3RpdmVBdEluZGV4OiAoaW5kZXgpID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uaXNBY3RpdmUoKSxcbiAgICAgIHNldFRhYkFjdGl2ZUF0SW5kZXg6IChpbmRleCwgaXNBY3RpdmUpID0+IHtcbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRBY3RpdmUoaXNBY3RpdmUpXG4gICAgICB9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5pc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrKCksXG4gICAgICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2tGb3JUYWJBdEluZGV4OiAoaW5kZXgsIHByZXZlbnREZWZhdWx0T25DbGljaykgPT4ge1xuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLnNldFByZXZlbnREZWZhdWx0T25DbGljayhwcmV2ZW50RGVmYXVsdE9uQ2xpY2spXG4gICAgICB9LFxuICAgICAgbWVhc3VyZVRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5tZWFzdXJlU2VsZigpLFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZFdpZHRoKCksXG4gICAgICBnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4OiAoaW5kZXgpID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uZ2V0Q29tcHV0ZWRMZWZ0KClcbiAgICB9KVxuXG4gICAgY29uc3QgcmVzZXRUYWJzID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFiRWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKFxuICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKE1EQ1RhYkJhckZvdW5kYXRpb24uc3RyaW5ncy5UQUJfU0VMRUNUT1IpKVxuICAgICAgdGhpcy50YWJzID0gdGFiRWxlbWVudHMubWFwKChlbCkgPT4gZWwuX192dWVfXylcblxuICAgICAgbGV0IGhhc1RleHQsIGhhc0ljb25cbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnNcbiAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgIGlmICh0YWIuaGFzVGV4dCkge1xuICAgICAgICAgIGhhc1RleHQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgaWYgKHRhYi5oYXNJY29uKSB7XG4gICAgICAgICAgaGFzSWNvbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNUZXh0ICYmIGhhc0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy10YWItYmFyLS1pY29ucy13aXRoLXRleHQnLCB0cnVlKVxuICAgICAgfSBlbHNlIGlmIChoYXNJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtdGFiLWJhci0taWNvbi10YWItYmFyJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xuICAgICAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZm91bmRhdGlvbi5nZXRBY3RpdmVUYWJJbmRleCgpXG4gICAgICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleChhY3RpdmVUYWJJbmRleCwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KDAsIHRydWUpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmxheW91dCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRUYWJzKClcblxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gcmVzZXRUYWJzKCkpXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUYWIgZnJvbSAnLi9tZGMtdGFiLnZ1ZSdcbmltcG9ydCBtZGNUYWJCYXIgZnJvbSAnLi9tZGMtdGFiLWJhci52dWUnXG5cbmV4cG9ydCB7IFxuICBtZGNUYWIsIFxuICBtZGNUYWJCYXIgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUYWIsIFxuICBtZGNUYWJCYXIgXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEhlbHBlciBUZXh0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHRGaWVsZCBoZWxwZXIgdGV4dCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcmVtb3ZlQXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfSElEREVOOiAnYXJpYS1oaWRkZW4nLFxuICBST0xFOiAncm9sZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXG4gIEhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc1BlcnNpc3RlbnQgU2V0cyB0aGUgcGVyc2lzdGVuY3kgb2YgdGhlIGhlbHBlciB0ZXh0LiAqL1xuICBzZXRQZXJzaXN0ZW50KGlzUGVyc2lzdGVudCkge1xuICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRhdGlvbiBUcnVlIHRvIG1ha2UgdGhlIGhlbHBlciB0ZXh0IGFjdCBhcyBhblxuICAgKiAgIGVycm9yIHZhbGlkYXRpb24gbWVzc2FnZS5cbiAgICovXG4gIHNldFZhbGlkYXRpb24oaXNWYWxpZGF0aW9uKSB7XG4gICAgaWYgKGlzVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9XG4gIH1cblxuICAvKiogTWFrZXMgdGhlIGhlbHBlciB0ZXh0IHZpc2libGUgdG8gdGhlIHNjcmVlbiByZWFkZXIuICovXG4gIHNob3dUb1NjcmVlblJlYWRlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5BUklBX0hJRERFTik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGhlbHBlciB0ZXh0IGJhc2VkIG9uIHRoZSBpbnB1dCB2YWxpZGl0eS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dElzVmFsaWRcbiAgICovXG4gIHNldFZhbGlkaXR5KGlucHV0SXNWYWxpZCkge1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1BlcnNpc3RlbnQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgY29uc3QgaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSA9IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgJiYgIWlucHV0SXNWYWxpZDtcblxuICAgIGlmICh2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5ST0xFLCAnYWxlcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuUk9MRSk7XG4gICAgfVxuXG4gICAgaWYgKCFoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ICYmICF2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmhpZGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBoZWxwIHRleHQgZnJvbSBzY3JlZW4gcmVhZGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhpZGVfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLkFSSUFfSElEREVOLCAndHJ1ZScpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEljb24uXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgdGV4dCBmaWVsZCBpY29uIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRJY29uQWRhcHRlciB7XG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENUZXh0RmllbGQ6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENUZXh0RmllbGQ6aWNvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dCBmaWVsZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICcwJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUljb25BY3Rpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICcuL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJy4vaWNvbi9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmFsdWU6IHN0cmluZyxcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIGJhZElucHV0OiBib29sZWFuLFxuICogICB2YWxpZGl0eToge1xuICogICAgIGJhZElucHV0OiBib29sZWFuLFxuICogICAgIHZhbGlkOiBib29sZWFuLFxuICogICB9LFxuICogfX1cbiAqL1xubGV0IE5hdGl2ZUlucHV0VHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBoZWxwZXJUZXh0OiAoIU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIGljb246ICghTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqIH19XG4gKi9cbmxldCBGb3VuZGF0aW9uTWFwVHlwZTtcblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0IEZpZWxkIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZSBsaXN0ZW5lciBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbighQXJyYXkpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICogQHJldHVybiB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgb2JzZXJ2ZXIgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIob2JzZXJ2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb3JpZ2luIG9mIHRoZSBsaW5lIHJpcHBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRYXG4gICAqL1xuICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFNoYWtlcyBsYWJlbCBpZiBzaG91bGRTaGFrZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlXG4gICAqL1xuICBzaGFrZUxhYmVsKHNob3VsZFNoYWtlKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIEZsb2F0cyB0aGUgbGFiZWwgYWJvdmUgdGhlIGlucHV0IGVsZW1lbnQgaWYgc2hvdWxkRmxvYXQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdFxuICAgKi9cbiAgZmxvYXRMYWJlbChzaG91bGRGbG9hdCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGxhYmVsIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTGFiZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFJldHVybnMgd2lkdGggb2YgbGFiZWwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNPdXRsaW5lKCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogVXBkYXRlcyBTVkcgUGF0aCBvbiBvdXRsaW5lIGVsZW1lbnQgYmFzZWQgb24gdGhlXG4gICAqIGxhYmVsIGVsZW1lbnQgd2lkdGggYW5kIFJUTCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUnRsXG4gICAqL1xuICB1cGRhdGVPdXRsaW5lUGF0aChsYWJlbFdpZHRoLCBpc1J0bCkge31cbn1cblxuZXhwb3J0IHtNRENUZXh0RmllbGRBZGFwdGVyLCBOYXRpdmVJbnB1dFR5cGUsIEZvdW5kYXRpb25NYXBUeXBlfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dEZpZWxkIExpbmUgUmlwcGxlLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGxpbmUgcmlwcGxlIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTElORV9SSVBQTEVfQUNUSVZFOiAnbWRjLWxpbmUtcmlwcGxlLS1hY3RpdmUnLFxuICBMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkc6ICdtZGMtbGluZS1yaXBwbGUtLWRlYWN0aXZhdGluZycsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENMaW5lUmlwcGxlQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTGluZVJpcHBsZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDTGluZVJpcHBsZUFkYXB0ZXI9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0gLyoqIEB0eXBlIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZVxuICAgKi9cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0FDVElWRSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSByaXBwbGUgYW5pbWF0aW9uIHRvIHRoZSBnaXZlbiBYIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0geENvb3JkaW5hdGVcbiAgICovXG4gIHNldFJpcHBsZUNlbnRlcih4Q29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZyA9XG4gICAgICAgIGB0cmFuc2Zvcm0tb3JpZ2luOiAke3hDb29yZGluYXRlfXB4IGNlbnRlcmA7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3N0eWxlJywgYXR0cmlidXRlU3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIGxpbmUgcmlwcGxlIHRvIGJlIGVpdGhlciB0cmFuc3BhcmVudCBvciBvcGFxdWVcbiAgICAvLyBiZWZvcmUgZW1pdHRpbmcgdGhlIGFuaW1hdGlvbiBlbmQgZXZlbnRcbiAgICBjb25zdCBpc0RlYWN0aXZhdGluZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuXG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgaWYgKGlzRGVhY3RpdmF0aW5nKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTGluZVJpcHBsZUZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIEZsb2F0aW5nIExhYmVsLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGZsb2F0aW5nIGxhYmVsIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGbG9hdGluZ0xhYmVsQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGbG9hdGluZ0xhYmVsQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExBQkVMX0ZMT0FUX0FCT1ZFOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZScsXG4gIExBQkVMX1NIQUtFOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1zaGFrZScsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBnZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlU2hha2VBbmltYXRpb25FbmRfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2FuaW1hdGlvbmVuZCcsIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYW5pbWF0aW9uZW5kJywgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIHByb2R1Y2UgdGhlIGxhYmVsIHNoYWtlIGZvciBlcnJvcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkU2hha2UgYWRkcyBzaGFrZSBjbGFzcyBpZiB0cnVlLFxuICAgKiBvdGhlcndpc2UgcmVtb3ZlcyBzaGFrZSBjbGFzcy5cbiAgICovXG4gIHNoYWtlKHNob3VsZFNoYWtlKSB7XG4gICAgY29uc3Qge0xBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHNob3VsZFNoYWtlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gZmxvYXQgb3IgZG9jay5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdCBhZGRzIGZsb2F0IGNsYXNzIGlmIHRydWUsIG90aGVyd2lzZSByZW1vdmVcbiAgICogZmxvYXQgYW5kIHNoYWtlIGNsYXNzIHRvIGRvY2sgbGFiZWwuXG4gICAqL1xuICBmbG9hdChzaG91bGRGbG9hdCkge1xuICAgIGNvbnN0IHtMQUJFTF9GTE9BVF9BQk9WRSwgTEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoc2hvdWxkRmxvYXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGludGVyYWN0aW9uIGV2ZW50IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqL1xuICBoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8oKSB7XG4gICAgY29uc3Qge0xBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIE5vdGNoZWQgT3V0bGluZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBOb3RjaGVkIE91dGxpbmUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBcImRcIiBhdHRyaWJ1dGUgb2YgdGhlIG91dGxpbmUgZWxlbWVudCdzIFNWRyBwYXRoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldE91dGxpbmVQYXRoQXR0cih2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWRsZSBvdXRsaW5lIGVsZW1lbnQncyBjb21wdXRlZCBzdHlsZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3NzIHByb3BlcnR5IGBwcm9wZXJ0eU5hbWVgLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBnZXRDb21wdXRlZFN0eWxlKC4uLikuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUocHJvcGVydHlOYW1lKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBQQVRIX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmVfX3BhdGgnLFxuICBJRExFX09VVExJTkVfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZScsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9ICovICh7XG4gICAgICBnZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRIZWlnaHQ6ICgpID0+IHt9LFxuICAgICAgc2V0T3V0bGluZVBhdGhBdHRyOiAoKSA9PiB7fSxcbiAgICAgIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBTVkcgcGF0aCBvZiB0aGUgZm9jdXMgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBub3RjaFdpZHRoXG4gICAqIGFuZCB0aGUgUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3RjaFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqL1xuICB1cGRhdGVTdmdQYXRoKG5vdGNoV2lkdGgsIGlzUnRsID0gZmFsc2UpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyBhIHNwZWNpZmljIGNvcm5lcidzIHN0eWxlIGJlY2F1c2UgRmlyZWZveCBkb2Vzbid0IHJlcG9ydCB0aGUgc3R5bGUgb24gYm9yZGVyLXJhZGl1cy5cbiAgICBjb25zdCByYWRpdXNTdHlsZVZhbHVlID0gdGhpcy5hZGFwdGVyXy5nZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUoJ2JvcmRlci1yYWRpdXMnKSB8fFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHBhcnNlRmxvYXQocmFkaXVzU3R5bGVWYWx1ZSk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBjb3JuZXJXaWR0aCA9IHJhZGl1cyArIDEuMjtcbiAgICBjb25zdCBsZWFkaW5nU3Ryb2tlTGVuZ3RoID0gTWF0aC5hYnMoMTEgLSBjb3JuZXJXaWR0aCk7XG4gICAgY29uc3QgcGFkZGVkTm90Y2hXaWR0aCA9IG5vdGNoV2lkdGggKyA4O1xuXG4gICAgLy8gVGhlIHJpZ2h0LCBib3R0b20sIGFuZCBsZWZ0IHNpZGVzIG9mIHRoZSBvdXRsaW5lIGZvbGxvdyB0aGUgc2FtZSBTVkcgcGF0aC5cbiAgICBjb25zdCBwYXRoTWlkZGxlID0gJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgcmFkaXVzICsgJywnICsgcmFkaXVzXG4gICAgICArICd2JyArIChoZWlnaHQgLSAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgLXJhZGl1cyArICcsJyArIHJhZGl1c1xuICAgICAgKyAnaCcgKyAoLXdpZHRoICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIC1yYWRpdXMgKyAnLCcgKyAtcmFkaXVzXG4gICAgICArICd2JyArICgtaGVpZ2h0ICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIHJhZGl1cyArICcsJyArIC1yYWRpdXM7XG5cbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoIWlzUnRsKSB7XG4gICAgICBwYXRoID0gJ00nICsgKGNvcm5lcldpZHRoICsgbGVhZGluZ1N0cm9rZUxlbmd0aCArIHBhZGRlZE5vdGNoV2lkdGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArICh3aWR0aCAtICgyICogY29ybmVyV2lkdGgpIC0gcGFkZGVkTm90Y2hXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpXG4gICAgICAgICsgcGF0aE1pZGRsZVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSAnTScgKyAod2lkdGggLSBjb3JuZXJXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGhcbiAgICAgICAgKyBwYXRoTWlkZGxlXG4gICAgICAgICsgJ2gnICsgKHdpZHRoIC0gKDIgKiBjb3JuZXJXaWR0aCkgLSBwYWRkZWROb3RjaFdpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRPdXRsaW5lUGF0aEF0dHIocGF0aCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9DT05UUk9MUzogJ2FyaWEtY29udHJvbHMnLFxuICBJTlBVVF9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9faW5wdXQnLFxuICBMQUJFTF9TRUxFQ1RPUjogJy5tZGMtZmxvYXRpbmctbGFiZWwnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pY29uJyxcbiAgT1VUTElORV9TRUxFQ1RPUjogJy5tZGMtbm90Y2hlZC1vdXRsaW5lJyxcbiAgQk9UVE9NX0xJTkVfU0VMRUNUT1I6ICcubWRjLWxpbmUtcmlwcGxlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy10ZXh0LWZpZWxkJyxcbiAgVVBHUkFERUQ6ICdtZGMtdGV4dC1maWVsZC0tdXBncmFkZWQnLFxuICBESVNBQkxFRDogJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCcsXG4gIERFTlNFOiAnbWRjLXRleHQtZmllbGQtLWRlbnNlJyxcbiAgRk9DVVNFRDogJ21kYy10ZXh0LWZpZWxkLS1mb2N1c2VkJyxcbiAgSU5WQUxJRDogJ21kYy10ZXh0LWZpZWxkLS1pbnZhbGlkJyxcbiAgQk9YOiAnbWRjLXRleHQtZmllbGQtLWJveCcsXG4gIE9VVExJTkVEOiAnbWRjLXRleHQtZmllbGQtLW91dGxpbmVkJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgTEFCRUxfU0NBTEU6IDAuNzUsXG4gIERFTlNFX0xBQkVMX1NDQUxFOiAwLjkyMyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge01EQ1RleHRGaWVsZEFkYXB0ZXIsIE5hdGl2ZUlucHV0VHlwZSwgRm91bmRhdGlvbk1hcFR5cGV9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICcuL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJy4vaWNvbi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vLyB3aGl0ZWxpc3QgYmFzZWQgb2ZmIG9mIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0hUTUwvSFRNTDUvQ29uc3RyYWludF92YWxpZGF0aW9uXG4vLyB1bmRlciBzZWN0aW9uOiBgVmFsaWRhdGlvbi1yZWxhdGVkIGF0dHJpYnV0ZXNgXG5jb25zdCBWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNUID0gW1xuICAncGF0dGVybicsICdtaW4nLCAnbWF4JywgJ3JlcXVpcmVkJywgJ3N0ZXAnLCAnbWlubGVuZ3RoJywgJ21heGxlbmd0aCcsXG5dO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgc2hvdWxkU2hha2UoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmFsaWQoKSAmJiAhdGhpcy5pc0ZvY3VzZWRfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRGbG9hdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNCYWRJbnB1dF8oKSAmJiAoISF0aGlzLmdldFZhbHVlKCkgfHwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2hha2VMYWJlbDogKCkgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHt9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4ge30sXG4gICAgICB1cGRhdGVPdXRsaW5lUGF0aDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkQWRhcHRlcn0gYWRhcHRlclxuICAgKiBAcGFyYW0geyFGb3VuZGF0aW9uTWFwVHlwZT19IGZvdW5kYXRpb25NYXAgTWFwIGZyb20gc3ViY29tcG9uZW50IG5hbWVzIHRvIHRoZWlyIHN1YmZvdW5kYXRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgZm91bmRhdGlvbk1hcCA9IC8qKiBAdHlwZSB7IUZvdW5kYXRpb25NYXBUeXBlfSAqLyAoe30pKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oZWxwZXJUZXh0XyA9IGZvdW5kYXRpb25NYXAuaGVscGVyVGV4dDtcbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pY29uXyA9IGZvdW5kYXRpb25NYXAuaWNvbjtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzRm9jdXNlZF8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzVmFsaWRfID0gdHJ1ZTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWN0aXZhdGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmRlYWN0aXZhdGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfID0gKCkgPT4gdGhpcy5hdXRvQ29tcGxldGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfID0gKGV2dCkgPT4gdGhpcy5zZXRUcmFuc2Zvcm1PcmlnaW4oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighQXJyYXkpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy52YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8gPSAobXV0YXRpb25zKSA9PiB0aGlzLmhhbmRsZVZhbGlkYXRpb25BdHRyaWJ1dGVNdXRhdGlvbl8obXV0YXRpb25zKTtcbiAgICAvKiogQHByaXZhdGUgeyFNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXztcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIC8vIEVuc3VyZSBsYWJlbCBkb2VzIG5vdCBjb2xsaWRlIHdpdGggYW55IHByZS1maWxsZWQgdmFsdWUuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSAmJiB0aGlzLmdldFZhbHVlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignaW5wdXQnLCB0aGlzLmlucHV0SW5wdXRIYW5kbGVyXyk7XG4gICAgWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXyA9IHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcihcbiAgICAgIHRoaXMudmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHRoZSBUZXh0IEZpZWxkLlxuICAgKi9cbiAgaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlSW5wdXQoKS5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB2YWxpZGF0aW9uIGF0dHJpYnV0ZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXk8TXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnNMaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlTXV0YXRpb25fKG11dGF0aW9uc0xpc3QpIHtcbiAgICBtdXRhdGlvbnNMaXN0LnNvbWUoKG11dGF0aW9uKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVElPTl9BVFRSX1dISVRFTElTVC5pbmRleE9mKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZm9jdXMgb3V0bGluZSBmb3Igb3V0bGluZWQgdGV4dCBmaWVsZHMuXG4gICAqL1xuICB1cGRhdGVPdXRsaW5lKCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNPdXRsaW5lKCkgfHwgIXRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRGVuc2UgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuREVOU0UpO1xuICAgIGNvbnN0IGxhYmVsU2NhbGUgPSBpc0RlbnNlID8gbnVtYmVycy5ERU5TRV9MQUJFTF9TQ0FMRSA6IG51bWJlcnMuTEFCRUxfU0NBTEU7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGFiZWxXaWR0aCgpICogbGFiZWxTY2FsZTtcbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZU91dGxpbmVQYXRoKGxhYmVsV2lkdGgsIGlzUnRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRleHQgZmllbGQgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICB0aGlzLnVwZGF0ZU91dGxpbmUoKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaW5lIHJpcHBsZSdzIHRyYW5zZm9ybSBvcmlnaW4sIHNvIHRoYXQgdGhlIGxpbmUgcmlwcGxlIGFjdGl2YXRlXG4gICAqIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGUgb3V0IGZyb20gdGhlIHVzZXIncyBjbGljayBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCkge1xuICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGV2dENvb3JkcyA9IHt4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFl9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gZXZ0Q29vcmRzLnggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQ7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZSBpbiBjYXNlcyB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgKiBjaGFuZ2VzIHdpdGhvdXQgdXNlciBpbnB1dCAoZS5nLiBwcm9ncmFtYXRpY2FsbHkpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVkVXNlcklucHV0Xykge1xuICAgICAgdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUZXh0IEZpZWxkJ3MgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBkZWFjdGl2YXRlRm9jdXMoKSB7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlTGluZVJpcHBsZSgpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXROYXRpdmVJbnB1dF8oKTtcbiAgICBjb25zdCBzaG91bGRSZW1vdmVMYWJlbEZsb2F0ID0gIWlucHV0LnZhbHVlICYmICF0aGlzLmlzQmFkSW5wdXRfKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVtb3ZlTGFiZWxGbG9hdCkge1xuICAgICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IEVsZW1lbnQuXG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBvbiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2hha2VMYWJlbCh0aGlzLnNob3VsZFNoYWtlKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgYSBjdXN0b20gdmFsaWRpdHkgaXMgc2V0LCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gICAqICAgICBPdGhlcndpc2UsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tzLlxuICAgKi9cbiAgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nX1xuICAgICAgPyB0aGlzLmlzVmFsaWRfIDogdGhpcy5pc05hdGl2ZUlucHV0VmFsaWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkIFNldHMgdGhlIHZhbGlkaXR5IHN0YXRlIG9mIHRoZSBUZXh0IEZpZWxkLlxuICAgKi9cbiAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18gPSB0cnVlO1xuICAgIHRoaXMuaXNWYWxpZF8gPSBpc1ZhbGlkO1xuICAgIC8vIFJldHJpZXZlIGZyb20gdGhlIGdldHRlciB0byBlbnN1cmUgY29ycmVjdCBsb2dpYyBpcyBhcHBsaWVkLlxuICAgIGlzVmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2hha2VMYWJlbCh0aGlzLnNob3VsZFNoYWtlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCBTZXRzIHRoZSB0ZXh0LWZpZWxkIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB0aGlzLnN0eWxlRGlzYWJsZWRfKGRpc2FibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dC5cbiAgICovXG4gIHNldEhlbHBlclRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBUZXh0IEZpZWxkIGlucHV0IGZhaWxzIGluIGNvbnZlcnRpbmcgdGhlXG4gICAqICAgICB1c2VyLXN1cHBsaWVkIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNCYWRJbnB1dF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkuYmFkSW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tpbmdcbiAgICogICAgIChWYWxpZGl0eVN0YXRlLnZhbGlkKS5cbiAgICovXG4gIGlzTmF0aXZlSW5wdXRWYWxpZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkudmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIHZhbGlkaXR5IHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpIHtcbiAgICBjb25zdCB7SU5WQUxJRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoSU5WQUxJRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNldFZhbGlkaXR5KGlzVmFsaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgZm9jdXNlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRm9jdXNlZF8oaXNGb2N1c2VkKSB7XG4gICAgY29uc3Qge0ZPQ1VTRUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRk9DVVNFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRk9DVVNFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZURpc2FibGVkXyhpc0Rpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVELCBJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKElOVkFMSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWNvbl8pIHtcbiAgICAgIHRoaXMuaWNvbl8uc2V0RGlzYWJsZWQoaXNEaXNhYmxlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fCFOYXRpdmVJbnB1dFR5cGV9IFRoZSBuYXRpdmUgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICAgKiBob3N0IGVudmlyb25tZW50LCBvciBhIGR1bW15IGlmIG5vbmUgZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlSW5wdXRfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUlucHV0KCkgfHxcbiAgICAvKiogQHR5cGUgeyFOYXRpdmVJbnB1dFR5cGV9ICovICh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWxpZGl0eToge1xuICAgICAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtdGV4dGZpZWxkLXdyYXBwZXJcIiA6c3R5bGU9XCJ7d2lkdGg6ZnVsbHdpZHRoPycxMDAlJzp1bmRlZmluZWR9XCI+XHJcblxyXG4gICAgPGRpdiByZWY9XCJyb290XCIgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cclxuXHJcbiAgICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNMZWFkaW5nSWNvblwiXHJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcclxuICAgICAgICBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pY29uXCJcclxuICAgICAgICA6Y2xhc3M9XCJoYXNMZWFkaW5nSWNvbi5jbGFzc2VzXCI+XHJcbiAgICAgICAgPHNsb3QgbmFtZT1cImxlYWRpbmctaWNvblwiPnt7IGhhc0xlYWRpbmdJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XHJcbiAgICAgIDwvaT5cclxuXHJcbiAgICAgIDx0ZXh0YXJlYSByZWY9XCJpbnB1dFwiIHYtaWY9XCJtdWx0aWxpbmVcIlxyXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcclxuICAgICAgICB2LWJpbmQ9XCJpbnB1dEF0dHJzXCJcclxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxyXG4gICAgICAgIEBpbnB1dD1cInVwZGF0ZVZhbHVlKCRldmVudC50YXJnZXQudmFsdWUpXCJcclxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCIgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXHJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcclxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcclxuICAgICAgICA6cm93cz1cInJvd3NcIiA6Y29scz1cImNvbHNcIlxyXG4gICAgICAgID48L3RleHRhcmVhPlxyXG5cclxuICAgICAgPGlucHV0IHJlZj1cImlucHV0XCIgdi1lbHNlXHJcbiAgICAgICAgdi1vbj1cIiRsaXN0ZW5lcnNcIlxyXG4gICAgICAgIHYtYmluZD1cImlucHV0QXR0cnNcIlxyXG4gICAgICAgIDpjbGFzcz1cImlucHV0Q2xhc3Nlc1wiXHJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxyXG4gICAgICAgIDp0eXBlPVwidHlwZVwiXHJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxyXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxyXG4gICAgICAgIDphcmlhLWxhYmVsPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXHJcbiAgICAgICAgLz5cclxuXHJcbiAgICAgIDxsYWJlbCByZWY9XCJsYWJlbFwiIDpjbGFzcz1cImxhYmVsQ2xhc3Nlc1VwZ3JhZGVkXCIgOmZvcj1cIl91aWRcIiAgdi1pZj1cImhhc0xhYmVsXCI+XHJcbiAgICAgICAge3sgbGFiZWwgfX1cclxuICAgICAgPC9sYWJlbD5cclxuXHJcbiAgICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNUcmFpbGluZ0ljb25cIlxyXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXHJcbiAgICAgICAgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9faWNvblwiXHJcbiAgICAgICAgOmNsYXNzPVwiaGFzVHJhaWxpbmdJY29uLmNsYXNzZXNcIj5cclxuICAgICAgICA8c2xvdCBuYW1lPVwidHJhaWxpbmctaWNvblwiPnt7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgICA8L2k+XHJcblxyXG4gICAgICA8ZGl2IHJlZj1cIm91dGxpbmVcIiBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVcIiB2LWlmPVwiaGFzT3V0bGluZVwiPlxyXG4gICAgICAgIDxzdmc+XHJcbiAgICAgICAgICA8cGF0aCBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX3BhdGhcIiA6ZD1cIm91dGxpbmVQYXRoQXR0clwiIC8+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IHJlZj1cIm91dGxpbmVJZGxlXCIgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19pZGxlXCIgdi1pZj1cImhhc091dGxpbmVcIj48L2Rpdj5cclxuICAgICAgPGRpdiByZWY9XCJib3R0b21cIiA6Y2xhc3M9XCJib3R0b21DbGFzc2VzXCIgdi1pZj1cImhhc0JvdHRvbUxpbmVcIj48L2Rpdj5cclxuXHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8cCByZWY9XCJoZWxwXCIgOmlkPVwiJ2hlbHAtJytfdWlkXCIgOmNsYXNzPVwiaGVscENsYXNzZXNcIlxyXG4gICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiB2LWlmPVwiaGVscHRleHRcIj5cclxuICAgICAge3sgaGVscHRleHQgIH19XHJcbiAgICA8L3A+XHJcblxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9mb3VuZGF0aW9uJztcclxuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJztcclxuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvZm91bmRhdGlvbic7XHJcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vZm91bmRhdGlvbic7XHJcbmltcG9ydCBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbic7XHJcbmltcG9ydCBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgZXh0cmFjdEljb25Qcm9wLFxyXG4gIERpc3BhdGNoRm9jdXNNaXhpbixcclxuICBDdXN0b21FbGVtZW50TWl4aW4sXHJcbn0gZnJvbSAnLi4vYmFzZSc7XHJcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtdGV4dGZpZWxkJyxcclxuICBtaXhpbnM6IFtDdXN0b21FbGVtZW50TWl4aW4sIERpc3BhdGNoRm9jdXNNaXhpbl0sXHJcbiAgbW9kZWw6IHtcclxuICAgIHByb3A6ICd2YWx1ZScsXHJcbiAgICBldmVudDogJ21vZGVsJyxcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB2YWx1ZTogU3RyaW5nLFxyXG4gICAgdHlwZToge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcclxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBbJ3RleHQnLCAnZW1haWwnLCAnc2VhcmNoJywgJ3Bhc3N3b3JkJywgJ3RlbCcsICd1cmwnXS5pbmRleE9mKFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICkgIT09IC0xXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBkZW5zZTogQm9vbGVhbixcclxuICAgIGxhYmVsOiBTdHJpbmcsXHJcbiAgICBoZWxwdGV4dDogU3RyaW5nLFxyXG4gICAgaGVscHRleHRQZXJzaXN0ZW50OiBCb29sZWFuLFxyXG4gICAgaGVscHRleHRWYWxpZGF0aW9uOiBCb29sZWFuLFxyXG4gICAgYm94OiBCb29sZWFuLFxyXG4gICAgb3V0bGluZTogQm9vbGVhbixcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXHJcbiAgICB2YWxpZDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcclxuICAgIGZ1bGx3aWR0aDogQm9vbGVhbixcclxuICAgIG11bHRpbGluZTogQm9vbGVhbixcclxuICAgIGxlYWRpbmdJY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcclxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgICBzaXplOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDIwIH0sXHJcbiAgICBtaW5sZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXHJcbiAgICBtYXhsZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXHJcbiAgICByb3dzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDggfSxcclxuICAgIGNvbHM6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogNDAgfSxcclxuXHJcbiAgICAvLyBvdGhlciBpbnB1dCBwcm9wc1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgcmVhZG9ubHk6IEJvb2xlYW4sXHJcbiAgICBhdXRvY29tcGxldGU6IEJvb2xlYW4sXHJcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXHJcbiAgfSxcclxuICBkYXRhOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHQ6IHRoaXMudmFsdWUsXHJcbiAgICAgIHJvb3RDbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy10ZXh0ZmllbGQnOiB0cnVlLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZCc6IHRydWUsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCc6IHRydWUsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kZW5zZSc6IHRoaXMuZGVuc2UsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1mdWxsd2lkdGgnOiB0aGlzLmZ1bGx3aWR0aCxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXRleHRhcmVhJzogdGhpcy5tdWx0aWxpbmUsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1ib3gnOiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5ib3gsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCc6ICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLm91dGxpbmUsXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0Q2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZF9faW5wdXQnOiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgICBsYWJlbENsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsJzogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgICAgYm90dG9tQ2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtbGluZS1yaXBwbGUnOiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgICBoZWxwQ2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dCc6IHRydWUsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS1wZXJzaXN0ZW50JzogdGhpcy5oZWxwdGV4dFBlcnNpc3RlbnQsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZyc6IHRoaXMuaGVscHRleHRWYWxpZGF0aW9uLFxyXG4gICAgICB9LFxyXG4gICAgICBvdXRsaW5lUGF0aEF0dHI6IHVuZGVmaW5lZCxcclxuICAgIH07XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgZGlzYWJsZWQoKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZCk7XHJcbiAgICB9LFxyXG4gICAgcmVxdWlyZWQoKSB7XHJcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgKHRoaXMuJHJlZnMuaW5wdXQucmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkKTtcclxuICAgIH0sXHJcbiAgICB2YWxpZCgpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0VmFsaWQodGhpcy52YWxpZCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkZW5zZSgpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLCB0aGlzLmRlbnNlKTtcclxuICAgIH0sXHJcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQoKSB7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiZcclxuICAgICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLnNldFBlcnNpc3RlbnQodGhpcy5oZWxwdGV4dFBlcnNpc3RlbnQpO1xyXG4gICAgfSxcclxuICAgIGhlbHB0ZXh0VmFsaWRhdGlvbigpIHtcclxuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJlxyXG4gICAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uc2V0VmFsaWRhdGlvbih0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvbik7XHJcbiAgICB9LFxyXG4gICAgdmFsdWUodmFsdWUpIHtcclxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpIHtcclxuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnbW9kZWwnLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgZm9jdXMoKSB7XHJcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpO1xyXG4gICAgfSxcclxuICAgIGJsdXIoKSB7XHJcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5ibHVyKCk7XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGlucHV0QXR0cnMoKSB7XHJcbiAgICAgIGxldCB7IG5hbWUsIHJlYWRvbmx5LCBhdXRvY29tcGxldGUsIGF1dG9mb2N1cyB9ID0gdGhpcztcclxuICAgICAgcmV0dXJuIHsgbmFtZSwgcmVhZG9ubHksIGF1dG9jb21wbGV0ZSwgYXV0b2ZvY3VzIH07XHJcbiAgICB9LFxyXG4gICAgaW5wdXRQbGFjZUhvbGRlcigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZnVsbHdpZHRoID8gdGhpcy5sYWJlbCA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcbiAgICBpbnB1dEFyaWFDb250cm9scygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGVscCA/ICdoZWxwLScgKyB0aGlzLl91aWQgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG4gICAgaGFzTGFiZWwoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5sYWJlbDtcclxuICAgIH0sXHJcbiAgICBoYXNPdXRsaW5lKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZTtcclxuICAgIH0sXHJcbiAgICBoYXNCb3R0b21MaW5lKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMuaGFzT3V0bGluZSAmJiAhdGhpcy5tdWx0aWxpbmU7XHJcbiAgICB9LFxyXG4gICAgaGFzTGVhZGluZ0ljb24oKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAodGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLiRzbG90c1snbGVhZGluZy1pY29uJ10pICYmXHJcbiAgICAgICAgISh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWFkaW5nSWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmxlYWRpbmdJY29uKSA6IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBoYXNUcmFpbGluZ0ljb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhaWxpbmdJY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMudHJhaWxpbmdJY29uKSA6IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBsYWJlbENsYXNzZXNVcGdyYWRlZCgpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5sYWJlbENsYXNzZXMsIHtcclxuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZSc6IHRoaXMudmFsdWUsXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBpZiAodGhpcy4kcmVmcy5ib3R0b20pIHtcclxuICAgICAgdGhpcy5ib3R0b21MaW5lRm91bmRhdGlvbiA9IG5ldyBNRENMaW5lUmlwcGxlRm91bmRhdGlvbih7XHJcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5ib3R0b21DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5ib3R0b21DbGFzc2VzLCBjbGFzc05hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmJvdHRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5ib3R0b20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5ib3R0b20uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmJvdHRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy4kcmVmcy5oZWxwKSB7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24oe1xyXG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuaGVscENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcclxuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmhlbHBDbGFzc2VzLCBjbGFzc05hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5oZWxwLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmhlbHAuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUF0dHI6IG5hbWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5oZWxwLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldENvbnRlbnQ6ICgvKmNvbnRlbnQqLykgPT4ge1xyXG4gICAgICAgICAgLy8gaGVscCB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e2hlbHB0ZXh0fX1cclxuICAgICAgICAgIC8vIHRoaXMuJHJlZnMuaGVscC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uaW5pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLiRyZWZzLmljb24pIHtcclxuICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ0ljb24pIHtcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsIHRydWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVHJhaWxpbmdJY29uKSB7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJywgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuaWNvbkZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24oe1xyXG4gICAgICAgIHNldEF0dHI6IChhdHRyLCB2YWx1ZSkgPT4gdGhpcy4kcmVmcy5pY29uLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXHJcbiAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHRoaXMuJGVtaXQoJ2ljb24tYWN0aW9uJyksXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy4kcmVmcy5sYWJlbCkge1xyXG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbih7XHJcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcclxuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLmxhYmVsLm9mZnNldFdpZHRoLFxyXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLiRyZWZzLm91dGxpbmUpIHtcclxuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiA9IG5ldyBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24oe1xyXG4gICAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmUub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmUub2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogdmFsdWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vdXRsaW5lUGF0aEF0dHIgPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZTogcHJvcGVydHlOYW1lID0+IHtcclxuICAgICAgICAgIGNvbnN0IGlkbGVPdXRsaW5lRWxlbWVudCA9IHRoaXMuJHJlZnMub3V0bGluZUlkbGU7XHJcbiAgICAgICAgICBpZiAoaWRsZU91dGxpbmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dcclxuICAgICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShpZGxlT3V0bGluZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5pbml0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24oXHJcbiAgICAgIHtcclxuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcclxuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzRm9jdXNlZDogKCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMuaW5wdXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1J0bDogKCkgPT5cclxuICAgICAgICAgIHdpbmRvd1xyXG4gICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpXHJcbiAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXHJcbiAgICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLmJvdHRvbSkge1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLmJvdHRvbSkge1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5hY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbjogbm9ybWFsaXplZFggPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnNldFJpcHBsZUNlbnRlcihub3JtYWxpemVkWCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PiB7XHJcbiAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZXIpO1xyXG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJHJlZnMuaW5wdXQ7XHJcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUgfTtcclxuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgY29uZmlnKTtcclxuICAgICAgICAgIHJldHVybiBvYnNlcnZlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogb2JzZXJ2ZXIgPT4ge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hha2VMYWJlbDogc2hvdWxkU2hha2UgPT4ge1xyXG4gICAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uc2hha2Uoc2hvdWxkU2hha2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmxvYXRMYWJlbDogc2hvdWxkRmxvYXQgPT4ge1xyXG4gICAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uZmxvYXQoc2hvdWxkRmxvYXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzTGFiZWw6ICgpID0+IHtcclxuICAgICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMubGFiZWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvdW5kYXRpb24uZ2V0V2lkdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc091dGxpbmU6ICgpID0+ICEhdGhpcy5oYXNPdXRsaW5lLFxyXG4gICAgICAgIHVwZGF0ZU91dGxpbmVQYXRoOiAobGFiZWxXaWR0aCwgaXNSdGwpID0+IHtcclxuICAgICAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24udXBkYXRlU3ZnUGF0aChsYWJlbFdpZHRoLCBpc1J0bCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGJvdHRvbUxpbmU6IHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24sXHJcbiAgICAgICAgaGVscGVyVGV4dDogdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbixcclxuICAgICAgICBpY29uOiB0aGlzLmljb25Gb3VuZGF0aW9uLFxyXG4gICAgICAgIGxhYmVsOiB0aGlzLmxhYmVsRm91bmRhdGlvbixcclxuICAgICAgICBvdXRsaW5lOiB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLFxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUpO1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpO1xyXG4gICAgdGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5yZXF1aXJlZCA9IHRoaXMucmVxdWlyZWQpO1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsaWQodGhpcy52YWxpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudGV4dGJveCkge1xyXG4gICAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpO1xyXG4gICAgICB0aGlzLnJpcHBsZS5pbml0KCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XHJcbiAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uICYmIHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24uZGVzdHJveSgpO1xyXG4gICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJiB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuaWNvbkZvdW5kYXRpb24gJiYgdGhpcy5pY29uRm91bmRhdGlvbi5kZXN0cm95KCk7XHJcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiAmJiB0aGlzLmxhYmVsRm91bmRhdGlvbi5kZXN0cm95KCk7XHJcbiAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uICYmIHRoaXMub3V0bGluZUZvdW5kYXRpb24uZGVzdHJveSgpO1xyXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpO1xyXG4gIH0sXHJcbn07XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGV4dEZpZWxkIGZyb20gJy4vbWRjLXRleHRmaWVsZC52dWUnXG5cbmV4cG9ydCB7bWRjVGV4dEZpZWxkfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGV4dEZpZWxkXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWVsZW1lbnQgOnRhZz1cInRhZ1wiIFxuICAgIGNsYXNzPVwibWRjLXRoZW1lXCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tZWxlbWVudD5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9iYXNlJ1xuXG5cbmNvbnN0IFRIRU1FX0NPTE9SUyA9IFtcbiAgJ3ByaW1hcnknLFxuICAnc2Vjb25kYXJ5JyxcbiAgJ2JhY2tncm91bmQnLFxuICAncHJpbWFyeS1saWdodCcsXG4gICdzZWNvbmRhcnktbGlnaHQnLFxuICAnc2Vjb25kYXJ5LWRhcmsnLFxuICAncHJpbWFyeS1kYXJrJ1xuXVxuXG5jb25zdCBUSEVNRV9TVFlMRVMgPSBbXG4gICd0ZXh0LXByaW1hcnknLFxuICAndGV4dC1zZWNvbmRhcnknLFxuICAndGV4dC1oaW50JyxcbiAgJ3RleHQtaWNvbicsXG4gICd0ZXh0LWRpc2FibGVkJ1xuXVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGhlbWUnLFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9LFxuICBwcm9wczoge1xuICAgIHRhZzoge3R5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RpdicgfSxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmQ6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgbGV0IGNsYXNzZXMgPSB7fVxuXG4gICAgICBpZiAodGhpcy5jb2xvciAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmNvbG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn1gXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmJhY2tncm91bmQpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5iYWNrZ3JvdW5kfS1iZ2BdID0gdHJ1ZVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX1NUWUxFUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfS1vbi0ke3RoaXMuYmFja2dyb3VuZH1gXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RoZW1lIGZyb20gJy4vbWRjLXRoZW1lLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjVGhlbWVcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RoZW1lXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEZJWEVEOiAnbWRjLXRvb2xiYXItLWZpeGVkJyxcbiAgRklYRURfTEFTVFJPVzogJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknLFxuICBGSVhFRF9BVF9MQVNUX1JPVzogJ21kYy10b29sYmFyLS1maXhlZC1hdC1sYXN0LXJvdycsXG4gIFRPT0xCQVJfUk9XX0ZMRVhJQkxFOiAnbWRjLXRvb2xiYXItLWZsZXhpYmxlJyxcbiAgRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUjogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1kZWZhdWx0LWJlaGF2aW9yJyxcbiAgRkxFWElCTEVfTUFYOiAnbWRjLXRvb2xiYXItLWZsZXhpYmxlLXNwYWNlLW1heGltaXplZCcsXG4gIEZMRVhJQkxFX01JTjogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1taW5pbWl6ZWQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJVExFX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX190aXRsZScsXG4gIElDT05fU0VMRUNUT1I6ICcubWRjLXRvb2xiYXJfX2ljb24nLFxuICBGSVJTVF9ST1dfU0VMRUNUT1I6ICcubWRjLXRvb2xiYXJfX3JvdzpmaXJzdC1jaGlsZCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1Rvb2xiYXI6Y2hhbmdlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNQVhfVElUTEVfU0laRTogMi4xMjUsXG4gIE1JTl9USVRMRV9TSVpFOiAxLjI1LFxuICBUT09MQkFSX1JPV19IRUlHSFQ6IDY0LFxuICBUT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUOiA1NixcbiAgVE9PTEJBUl9NT0JJTEVfQlJFQUtQT0lOVDogNjAwLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUb29sYmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldFZpZXdwb3J0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldE9mZnNldEhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoLyogZXZ0RGF0YToge2ZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGU6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yVGl0bGVFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVG9vbGJhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5jaGVja1Jvd0hlaWdodF8oKTtcbiAgICB0aGlzLnNjcm9sbEhhbmRsZXJfID0gKCkgPT4gdGhpcy51cGRhdGVUb29sYmFyU3R5bGVzXygpO1xuICAgIHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8gPSAwO1xuICAgIHRoaXMuc2Nyb2xsRnJhbWVfID0gMDtcbiAgICB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8gPSBmYWxzZTtcblxuICAgIHRoaXMuY2FsY3VsYXRpb25zXyA9IHtcbiAgICAgIHRvb2xiYXJSb3dIZWlnaHQ6IDAsXG4gICAgICAvLyBDYWxjdWxhdGVkIEhlaWdodCByYXRpby4gV2UgdXNlIHJhdGlvIHRvIGNhbGN1bGF0ZSBjb3JyZXNwb25kaW5nIGhlaWdodHMgaW4gcmVzaXplIGV2ZW50LlxuICAgICAgdG9vbGJhclJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgdG9vbGJhciBoZWlnaHQgdG8gcm93IGhlaWdodFxuICAgICAgZmxleGlibGVFeHBhbnNpb25SYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIGZsZXhpYmxlIHNwYWNlIGhlaWdodCB0byByb3cgaGVpZ2h0XG4gICAgICBtYXhUcmFuc2xhdGVZUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBtYXggdG9vbGJhciBtb3ZlIHVwIGRpc3RhbmNlIHRvIHJvdyBoZWlnaHRcbiAgICAgIHNjcm9sbFRocmVzaG9sZFJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgbWF4IHNjcm9sbFRvcCB0aGF0IHdlIHNob3VsZCBsaXN0ZW4gdG8gdG8gcm93IGhlaWdodFxuICAgICAgLy8gRGVyaXZlZCBIZWlnaHRzIGJhc2VkIG9uIHRoZSBhYm92ZSBrZXkgcmF0aW9zLlxuICAgICAgdG9vbGJhckhlaWdodDogMCxcbiAgICAgIGZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0OiAwLCAvLyBGbGV4aWJsZSByb3cgbWludXMgdG9vbGJhciBoZWlnaHQgKGRlcml2ZWQpXG4gICAgICBtYXhUcmFuc2xhdGVZRGlzdGFuY2U6IDAsIC8vIFdoZW4gdG9vbGJhciBvbmx5IGZpeCBsYXN0IHJvdyAoZGVyaXZlZClcbiAgICAgIHNjcm9sbFRocmVzaG9sZDogMCxcbiAgICB9O1xuICAgIC8vIFRvb2xiYXIgZml4ZWQgYmVoYXZpb3JcbiAgICAvLyBJZiB0b29sYmFyIGlzIGZpeGVkXG4gICAgdGhpcy5maXhlZF8gPSBmYWxzZTtcbiAgICAvLyBJZiBmaXhlZCBpcyB0YXJnZXRlZCBvbmx5IGF0IHRoZSBsYXN0IHJvd1xuICAgIHRoaXMuZml4ZWRMYXN0cm93XyA9IGZhbHNlO1xuICAgIC8vIFRvb2xiYXIgZmxleGlibGUgYmVoYXZpb3JcbiAgICAvLyBJZiB0aGUgZmlyc3Qgcm93IGlzIGZsZXhpYmxlXG4gICAgdGhpcy5oYXNGbGV4aWJsZVJvd18gPSBmYWxzZTtcbiAgICAvLyBJZiB1c2UgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICB0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfID0gZmFsc2U7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuZml4ZWRfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEKTtcbiAgICB0aGlzLmZpeGVkTGFzdHJvd18gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfTEFTVFJPVykgJiB0aGlzLmZpeGVkXztcbiAgICB0aGlzLmhhc0ZsZXhpYmxlUm93XyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5UT09MQkFSX1JPV19GTEVYSUJMRSk7XG4gICAgaWYgKHRoaXMuaGFzRmxleGlibGVSb3dfKSB7XG4gICAgICB0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1IpO1xuICAgIH1cbiAgICB0aGlzLmluaXRLZXlSYXRpb18oKTtcbiAgICB0aGlzLnNldEtleUhlaWdodHNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG4gIHVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWRfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50KCdtYXJnaW4tdG9wJywgYCR7dGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJIZWlnaHR9cHhgKTtcbiAgICB9XG4gIH1cblxuICBnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyhzY3JvbGxUb3ApIHtcbiAgICAvLyBUbyBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm8gd2hlbiB0aGVyZSBpcyBubyBmbGV4aWJsZUV4cGFuc2lvbkhlaWdodFxuICAgIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAxIC0gc2Nyb2xsVG9wIC8gKHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCArIGRlbHRhKSk7XG4gIH1cblxuICBjaGVja1Jvd0hlaWdodF8oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyk7XG4gICAgdGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNldEtleUhlaWdodHNfKCkpO1xuICB9XG5cbiAgc2V0S2V5SGVpZ2h0c18oKSB7XG4gICAgY29uc3QgbmV3VG9vbGJhclJvd0hlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0XygpO1xuICAgIGlmIChuZXdUb29sYmFyUm93SGVpZ2h0ICE9PSB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodCkge1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQgPSBuZXdUb29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJIZWlnaHQgPSB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25SYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGQgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMudXBkYXRlQWRqdXN0RWxlbWVudFN0eWxlcygpO1xuICAgICAgdGhpcy51cGRhdGVUb29sYmFyU3R5bGVzXygpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJTdHlsZXNfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsRnJhbWVfKTtcbiAgICB0aGlzLnNjcm9sbEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0U2Nyb2xsWSgpO1xuICAgICAgY29uc3QgaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8oc2Nyb2xsVG9wKTtcblxuICAgICAgaWYgKGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQgJiYgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmxleGlibGVFeHBhbnNpb25SYXRpbyA9IHRoaXMuZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18oc2Nyb2xsVG9wKTtcblxuICAgICAgdGhpcy51cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgICBpZiAodGhpcy5maXhlZExhc3Ryb3dfKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbGJhckZpeGVkU3RhdGVfKHNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNGbGV4aWJsZVJvd18pIHtcbiAgICAgICAgdGhpcy51cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfID0gaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZDtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKHtmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvfSk7XG4gICAgfSk7XG4gIH1cblxuICBzY3JvbGxlZE91dE9mVGhyZXNob2xkXyhzY3JvbGxUb3ApIHtcbiAgICByZXR1cm4gc2Nyb2xsVG9wID4gdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZDtcbiAgfVxuXG4gIGluaXRLZXlSYXRpb18oKSB7XG4gICAgY29uc3QgdG9vbGJhclJvd0hlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0XygpO1xuICAgIGNvbnN0IGZpcnN0Um93TWF4UmF0aW8gPSB0aGlzLmFkYXB0ZXJfLmdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodCgpIC8gdG9vbGJhclJvd0hlaWdodDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRIZWlnaHQoKSAvIHRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPSBmaXJzdFJvd01heFJhdGlvIC0gMTtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWVJhdGlvID1cbiAgICAgIHRoaXMuZml4ZWRMYXN0cm93XyA/IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gLSBmaXJzdFJvd01heFJhdGlvIDogMDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkUmF0aW8gPVxuICAgICAgKHRoaXMuZml4ZWRMYXN0cm93XyA/IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gOiBmaXJzdFJvd01heFJhdGlvKSAtIDE7XG4gIH1cblxuICBnZXRSb3dIZWlnaHRfKCkge1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRXaWR0aCgpIDwgYnJlYWtwb2ludCA/XG4gICAgICBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQgOiBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfUk9XX0hFSUdIVDtcbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01BWCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01JTik7XG4gICAgaWYgKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPT09IDEpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NQVgpO1xuICAgIH0gZWxzZSBpZiAoZmxleGlibGVFeHBhbnNpb25SYXRpbyA9PT0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01JTik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVG9vbGJhckZpeGVkU3RhdGVfKHNjcm9sbFRvcCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZURpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oXG4gICAgICBzY3JvbGxUb3AgLSB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQsXG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVkoJHstdHJhbnNsYXRlRGlzdGFuY2V9cHgpYCk7XG5cbiAgICBpZiAodHJhbnNsYXRlRGlzdGFuY2UgPT09IHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9BVF9MQVNUX1JPVyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9BVF9MQVNUX1JPVyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgaWYgKHRoaXMuZml4ZWRfKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgKiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudCgnaGVpZ2h0JyxcbiAgICAgICAgYCR7aGVpZ2h0ICsgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8pIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIGNvbnN0IG1heFRpdGxlU2l6ZSA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuTUFYX1RJVExFX1NJWkU7XG4gICAgY29uc3QgbWluVGl0bGVTaXplID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5NSU5fVElUTEVfU0laRTtcbiAgICBjb25zdCBjdXJyZW50VGl0bGVTaXplID0gKG1heFRpdGxlU2l6ZSAtIG1pblRpdGxlU2l6ZSkgKiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvICsgbWluVGl0bGVTaXplO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpdGxlRWxlbWVudCgnZm9udC1zaXplJywgYCR7Y3VycmVudFRpdGxlU2l6ZX1yZW1gKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgY2xhc3M9XCJtZGMtdG9vbGJhci13cmFwcGVyXCI+XG4gICAgPCEtLVRvb2xiYXItLT5cbiAgICA8ZGl2IHJlZj1cInJvb3RcIiA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIDpzdHlsZT1cInJvb3RTdHlsZXNcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuICAgIDwhLS0gRml4ZWQgQWRqdXN0IEVsZW1lbnQtLT5cbiAgICA8ZGl2IHJlZj1cImZpeGVkLWFkanVzdFwiIGNsYXNzPVwibWRjLXRvb2xiYXItZml4ZWQtYWRqdXN0XCIgXG4gICAgICA6c3R5bGU9XCJhZGp1c3RTdHlsZXNcIlxuICAgICAgdi1pZj1cImZpeGVkIHx8IHdhdGVyZmFsbCB8fCBmaXhlZExhc3Ryb3dcIj48L2Rpdj5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTURDVG9vbGJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbidcbiAgaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvdG9vbGJhci91dGlsJ1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnbWRjLXRvb2xiYXInLFxuICAgIHByb3BzOiB7XG4gICAgICAnZml4ZWQnOiBCb29sZWFuLFxuICAgICAgJ3dhdGVyZmFsbCc6IEJvb2xlYW4sXG4gICAgICAnZml4ZWQtbGFzdHJvdyc6IEJvb2xlYW4sXG4gICAgICAnZmxleGlibGUnOiBCb29sZWFuLFxuICAgICAgJ2ZsZXhpYmxlLWRlZmF1bHQnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICAgIH0sXG4gICAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAgICdtZGMtdG9vbGJhcic6IHRydWUsXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZCc6IHRoaXMuZml4ZWQgfHwgdGhpcy53YXRlcmZhbGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgICAnbWRjLXRvb2xiYXItLXdhdGVyZmFsbCc6IHRoaXMud2F0ZXJmYWxsLFxuICAgICAgICAgICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JzogdGhpcy5maXhlZExhc3Ryb3csXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZSc6IHRoaXMuZmxleGlibGUsXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZS1kZWZhdWx0LWJlaGF2aW9yJzogdGhpcy5mbGV4aWJsZSAmJlxuICAgICAgICAgICAgdGhpcy5mbGV4aWJsZURlZmF1bHRcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdFN0eWxlczoge30sXG4gICAgICAgIGFkanVzdFN0eWxlczoge1xuICAgICAgICAgIC8vIHRvIGF2b2lkIHRvcCBtYXJnaW4gY29sbGFwc2Ugd2l0aCA6YWZ0ZXIgZWxcbiAgICAgICAgICAvLyAwLjEgcHggc2hvdWxkIGJlIHJvdW5kZWQgdG8gMHB4XG4gICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB0cmlja1xuICAgICAgICAgIC8vIGhlaWdodDogJzAuMXB4J1xuICAgICAgICB9LFxuICAgICAgICBmb3VuZGF0aW9uOiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUb29sYmFyRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Vmlld3BvcnRXaWR0aDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICB9LFxuICAgICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9mZnNldEhlaWdodDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3Qub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodDogKCkgPT4ge1xuICAgICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SKVxuICAgICAgICAgIHJldHVybiAoZWwpID8gZWwub2Zmc2V0SGVpZ2h0IDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeUNoYW5nZTogKGV2dERhdGEpID0+IHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBsZXQgZWwgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvcihNRENUb29sYmFyRm91bmRhdGlvbi5zdHJpbmdzLlRJVExFX1NFTEVDVE9SKVxuICAgICAgICAgIGlmIChlbCkgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SKVxuICAgICAgICAgIGlmIChlbCkgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmFkanVzdFN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgfVxuICB9XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy10b29sYmFyLXJvdyBtZGMtdG9vbGJhcl9fcm93XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1yb3cnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtdG9vbGJhci1zZWN0aW9uIG1kYy10b29sYmFyX19zZWN0aW9uXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgICdhbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgJ3Nocmluay10by1maXQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnQnOiB0aGlzLmFsaWduU3RhcnQsXG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tYWxpZ24tZW5kJzogdGhpcy5hbGlnbkVuZCxcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1zaHJpbmstdG8tZml0JzogdGhpcy5zaHJpbmtUb0ZpdFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxhIGNsYXNzPVwibWRjLXRvb2xiYXItbWVudS1pY29uIG1kYy10b29sYmFyX19tZW51LWljb25cIlxuICAgIDpjbGFzcz1cInsnbWF0ZXJpYWwtaWNvbnMnOiEhaWNvbn1cIlxuICAgIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cbiAgICA8c2xvdD57e2ljb259fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1tZW51LWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IHt0eXBlOiBTdHJpbmcsICdkZWZhdWx0JzogXCJtZW51XCJ9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxhIGNsYXNzPVwibWRjLXRvb2xiYXItdGl0bGUgbWRjLXRvb2xiYXJfX3RpdGxlXCIgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci10aXRsZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBjbGFzcz1cIm1kYy10b29sYmFyLWljb24gbWRjLXRvb2xiYXJfX2ljb25cIiBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCJcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XG4gICAgPHNsb3Q+e3tpY29ufX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbn0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1Rvb2xiYXIgZnJvbSAnLi9tZGMtdG9vbGJhci52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclJvdyBmcm9tICcuL21kYy10b29sYmFyLXJvdy52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclNlY3Rpb24gZnJvbSAnLi9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyTWVudUljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1tZW51LWljb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJUaXRsZSBmcm9tICcuL21kYy10b29sYmFyLXRpdGxlLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFySWNvbiBmcm9tICcuL21kYy10b29sYmFyLWljb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59KVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVZJR0FUSU9OX0VWRU5UOiAnTURDVG9wQXBwQmFyOm5hdicsXG4gIFJPT1RfU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyJyxcbiAgVElUTEVfU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyX190aXRsZScsXG4gIE5BVklHQVRJT05fSUNPTl9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXJfX25hdmlnYXRpb24taWNvbicsXG4gIEFDVElPTl9JVEVNX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcl9fYWN0aW9uLWl0ZW0nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBTSE9SVF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQnLFxuICBTSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWhhcy1hY3Rpb24taXRlbScsXG4gIFNIT1JUX0NPTExBUFNFRF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRvcCBBcHAgQmFyXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVG9wIEFwcCBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgRWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIG5hdmlnYXRpb24gaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBuYXZpZ2F0aW9uIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBuYXZpZ2F0aW9uIGljb24gaXMgY2xpY2tlZC5cbiAgICovXG4gIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICByZWdpc3RlclNjcm9sbEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0Vmlld3BvcnRTY3JvbGxZKCkge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRUb3RhbEFjdGlvbkl0ZW1zKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVG9wQXBwQmFyQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVG9wQXBwQmFyQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUb3BBcHBCYXJBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUb3BBcHBCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRUb3RhbEFjdGlvbkl0ZW1zOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUb3BBcHBCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUb3BBcHBCYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLm5hdkNsaWNrSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFkYXB0ZXJfLm5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5uYXZDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5uYXZDbGlja0hhbmRsZXJfKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUb3BBcHBCYXJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckZvdW5kYXRpb24gZnJvbSAnLi4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RvcEFwcEJhckZvdW5kYXRpb248IU1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDVG9wQXBwQmFyRm91bmRhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUb3BBcHBCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG4gICAgLy8gU3RhdGUgdmFyaWFibGUgZm9yIHRoZSBjdXJyZW50IHRvcCBhcHAgYmFyIHN0YXRlXG4gICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMuc2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgY29uc3QgaXNBbHdheXNDb2xsYXBzZWQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldFRvdGFsQWN0aW9uSXRlbXMoKSA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MpO1xuICAgIH1cblxuICAgIGlmICghaXNBbHdheXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICAgICAgdGhpcy5zaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjcm9sbCBoYW5kbGVyIGZvciBhcHBseWluZy9yZW1vdmluZyB0aGUgY29sbGFwc2VkIG1vZGlmaWVyIGNsYXNzXG4gICAqIG9uIHRoZSBzaG9ydCB0b3AgYXBwIGJhci5cbiAgICovXG4gIHNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8oKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG5cbiAgICBpZiAoY3VycmVudFNjcm9sbCA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNIT1JUX0NPTExBUFNFRF9DTEFTUyk7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuZXhwb3J0IHthcHBseVBhc3NpdmV9O1xuIiwiPHRlbXBsYXRlPlxuPGhlYWRlciByZWY9XCJyb290XCIgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cbiAgPGRpdiBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fcm93XCI+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24gbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydFwiPlxuICAgICAgPGEgcmVmPVwibmF2aWdhdGlvbkljb25cIiBocmVmPVwiI1wiIDpjbGFzcz1cIm5hdmljb25DbGFzc2VzXCIgdi1pZj1cImhhdmVOYXZpZ2F0aW9uSWNvblwiIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj57e2ljb259fTwvYT5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX190aXRsZVwiIHYtaWY9XCIhIXRpdGxlXCI+e3t0aXRsZX19PC9zcGFuPlxuICAgIDwvc2VjdGlvbj5cbiAgICA8c2VjdGlvbiBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbiBtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24tLWFsaWduLWVuZFwiIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvc2VjdGlvbj5cbiAgPC9kaXY+XG48L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVG9wQXBwQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90b3AtYXBwLWJhci9zaG9ydC9mb3VuZGF0aW9uJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL3RvcC1hcHAtYmFyL3V0aWwnO1xuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluLCBlbWl0Q3VzdG9tRXZlbnQgfSBmcm9tICcuLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvcC1hcHAtYmFyJyxcbiAgcHJvcHM6IHtcbiAgICBzaG9ydDogQm9vbGVhbixcbiAgICBzaG9ydENvbGxhcHNlZDogQm9vbGVhbixcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdtZW51JyxcbiAgICB9LFxuICAgIGljb25DbGFzc2VzOiBPYmplY3QsXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydCc6IHRoaXMuc2hvcnQsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWNvbGxhcHNlZCc6IHRoaXMuc2hvcnRDb2xsYXBzZWQsXG4gICAgICB9LFxuICAgICAgZm91bmRhdGlvbjogbnVsbCxcbiAgICB9O1xuICB9LFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLm5hdmlnYXRpb25JY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbi5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDVG9wQXBwQmFyRm91bmRhdGlvbi5zdHJpbmdzLk5BVklHQVRJT05fRVZFTlQsXG4gICAgICAgICAge30sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSk7XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcik7XG4gICAgICB9LFxuXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgIH0sXG4gICAgICBnZXRUb3RhbEFjdGlvbkl0ZW1zOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICBNRENUb3BBcHBCYXJGb3VuZGF0aW9uLnN0cmluZ3MuQUNUSU9OX0lURU1fU0VMRUNUT1IsXG4gICAgICAgICkubGVuZ3RoLFxuICAgIH07XG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSB0aGlzLnNob3J0XG4gICAgICA/IG5ldyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24oYWRhcHRlcilcbiAgICAgIDogbmV3IE1EQ1RvcEFwcEJhckZvdW5kYXRpb24oYWRhcHRlcik7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGhhdmVOYXZpZ2F0aW9uSWNvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaWNvbiB8fCB0aGlzLmljb25DbGFzc2VzO1xuICAgIH0sXG4gICAgbmF2aWNvbkNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyX19uYXZpZ2F0aW9uLWljb24nOiB0cnVlLFxuICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMuaWNvbixcbiAgICAgICAgLi4udGhpcy5pY29uQ2xhc3NlcyxcbiAgICAgIH07XG4gICAgfSxcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm1kYy10b3AtYXBwLWJhci0tYWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fYWN0aW9uLWl0ZW1cIiA6Y2xhc3M9XCJhY3Rpb25pY29uQ2xhc3Nlc1wiIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cbiAgPHNsb3Q+e3tpY29ufX08L3Nsb3Q+XG48L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSAnLi4vYmFzZSc7XG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b3AtYXBwLWJhci0tYWN0aW9uJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nLFxuICAgIGljb25DbGFzc2VzOiBPYmplY3QsXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYWN0aW9uaWNvbkNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMuaWNvbixcbiAgICAgICAgLi4udGhpcy5pY29uQ2xhc3NlcyxcbiAgICAgIH07XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJztcbmltcG9ydCBtZGNUb3BBcHBCYXIgZnJvbSAnLi9tZGMtdG9wLWFwcC1iYXIudnVlJztcbmltcG9ydCBtZGNUb3BBcHBCYXJBY3Rpb24gZnJvbSAnLi9tZGMtdG9wLWFwcC1iYXItLWFjdGlvbi52dWUnO1xuXG5leHBvcnQgeyBtZGNUb3BBcHBCYXIsIG1kY1RvcEFwcEJhckFjdGlvbiB9O1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVG9wQXBwQmFyLFxuICBtZGNUb3BBcHBCYXJBY3Rpb24sXG59KTtcbiIsImNvbnN0IHR5cG9zID0gW1xuICAnZGlzcGxheTQnLCBcbiAgJ2Rpc3BsYXkzJywgXG4gICdkaXNwbGF5MicsIFxuICAnZGlzcGxheTEnLCBcbiAgJ2hlYWRsaW5lJyxcbiAgJ3RpdGxlJyxcbiAgJ3N1YmhlYWRpbmcxJyxcbiAgJ3N1YmhlYWRpbmcyJyxcbiAgJ2JvZHkxJyxcbiAgJ2JvZHkyJyxcbiAgJ2NhcHRpb24nLFxuICAnYnV0dG9uJ1xuXVxuXG5leHBvcnQgY29uc3QgbWRjVHlwb01peGluID0gKG5hbWUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRoaXMudGFnLCB7XG4gICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAnbWRjLXR5cG8nOiB0cnVlLFxuICAgICAgICAgIFtuYW1lXTogdHJ1ZSxcbiAgICAgICAgICBbYG1kYy10eXBvZ3JhcGh5LS0ke3RoaXMudHlwb31gXTogdHJ1ZSxcbiAgICAgICAgICAnbWRjLXR5cG9ncmFwaHktLWFkanVzdC1tYXJnaW4nOiB0aGlzLmFkanVzdE1hcmdpblxuICAgICAgICB9LFxuICAgICAgICAnYXR0cnMnOiB0aGlzLiRhdHRycyxcbiAgICAgICAgJ29uJzogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdCApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZGNUeXBvUHJvcE1peGluKGRlZmF1bHRUYWcsIGRlZmF1bHRUeXBvLCB2YWxpZFR5cG9zKSB7XG4gIHJldHVybiAge1xuICAgIHByb3BzOiB7XG4gICAgICAndGFnJzogeyBcbiAgICAgICAgdHlwZTogU3RyaW5nLCBcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFRhZyBcbiAgICAgIH0sXG4gICAgICAndHlwbyc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VHlwbyxcbiAgICAgICAgdmFsaWRhdG9yOiAgKHZhbHVlKSA9PiB2YWxpZFR5cG9zLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgfSxcbiAgICAgICdhZGp1c3QtbWFyZ2luJzogeyBcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHRTZWN0aW9uID0ge1xuICBuYW1lOiAnbWRjLXRleHQtc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ3RhZyc6IHtcbiAgICAgIHR5cGU6IFN0cmluZywgXG4gICAgICBkZWZhdWx0OiAnc2VjdGlvbicgXG4gICAgfSxcbiAgfSxcbiAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGhpcy50YWcsIHtcbiAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgJ21kYy10eXBvZ3JhcGh5JzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LXNlY3Rpb24nOiB0cnVlLFxuICAgICAgfSxcbiAgICAgICdhdHRycyc6IHRoaXMuJGF0dHJzLFxuICAgICAgJ29uJzogdGhpcy4kbGlzdGVuZXJzXG4gICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCApXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHQgPSB7XG4gIG5hbWU6ICdtZGMtdGV4dCcsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLXRleHQnKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbigncCcsICdib2R5MScsIHR5cG9zKVxuICBdLFxufVxuXG5leHBvcnQgY29uc3QgbWRjRGlzcGxheSA9IHtcbiAgbmFtZTogJ21kYy1kaXNwbGF5JyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLWRpc3BsYXknKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDEnLCAnZGlzcGxheTEnLCBbJ2Rpc3BsYXk0JywgJ2Rpc3BsYXkzJywgJ2Rpc3BsYXkyJywgJ2Rpc3BsYXkxJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY0hlYWRsaW5lID0ge1xuICBuYW1lOiAnbWRjLWhlYWRsaW5lJyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLWhlYWRsaW5lJyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gyJywgJ2hlYWRsaW5lJywgWydoZWFkbGluZSddKV0sXG59XG5cbmV4cG9ydCBjb25zdCBtZGNUaXRsZSA9IHtcbiAgbmFtZTogJ21kYy10aXRsZScsXG4gIG1peGluczogWyBcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy10aXRsZScpLCBcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMycsICd0aXRsZScsIFsndGl0bGUnXSldLFxufVxuXG5leHBvcnQgY29uc3QgbWRjU3ViSGVhZGluZyA9IHtcbiAgbmFtZTogJ21kYy1zdWJoZWFkaW5nJyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLXN1YmhlYWRpbmcnKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDQnLCAnc3ViaGVhZGluZzInLCBbJ3N1YmhlYWRpbmcxJywgJ3N1YmhlYWRpbmcyJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0ICBtZGNCb2R5ID0ge1xuICBuYW1lOiAnbWRjLWJvZHknLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1ib2R5JyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3AnLCAnYm9keTEnLCBbJ2JvZHkxJywgJ2JvZHkyJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY0NhcHRpb24gPSB7XG4gIG5hbWU6ICdtZGMtY2FwdGlvbicsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWNhcHRpb24nKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignc3BhbicsICdjYXB0aW9uJywgWydjYXB0aW9uJ10pXSxcbn1cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7ICBcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSBmcm9tICcuL21kYy10eXBvZ3JhcGh5LmpzJ1xuXG5leHBvcnQge1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59KVxuIiwiLy9cbi8vIHZ1ZSBQbHVnSW5cbi8vXG5pbXBvcnQgVnVlTURDQnV0dG9uIGZyb20gJy4vYnV0dG9uJztcbmltcG9ydCBWdWVNRENDYXJkIGZyb20gJy4vY2FyZCc7XG5pbXBvcnQgVnVlTURDQ2hlY2tib3ggZnJvbSAnLi9jaGVja2JveCc7XG5pbXBvcnQgVnVlTURDQ2hpcFNldCBmcm9tICcuL2NoaXBzJztcbmltcG9ydCBWdWVNRENEaWFsb2cgZnJvbSAnLi9kaWFsb2cnO1xuaW1wb3J0IFZ1ZU1EQ0RyYXdlciBmcm9tICcuL2RyYXdlcic7XG5pbXBvcnQgVnVlTURDRWxldmF0aW9uIGZyb20gJy4vZWxldmF0aW9uJztcbmltcG9ydCBWdWVNRENGYWIgZnJvbSAnLi9mYWInO1xuaW1wb3J0IFZ1ZU1EQ0dyaWRMaXN0IGZyb20gJy4vZ3JpZC1saXN0JztcbmltcG9ydCBWdWVNRENJY29uIGZyb20gJy4vaWNvbic7XG5pbXBvcnQgVnVlTURDSWNvblRvZ2dsZSBmcm9tICcuL2ljb24tdG9nZ2xlJztcbmltcG9ydCBWdWVNRENMYXlvdXRBcHAgZnJvbSAnLi9sYXlvdXQtYXBwJztcbmltcG9ydCBWdWVNRENMYXlvdXRHcmlkIGZyb20gJy4vbGF5b3V0LWdyaWQnO1xuaW1wb3J0IFZ1ZU1EQ0xpbmVhclByb2dyZXNzIGZyb20gJy4vbGluZWFyLXByb2dyZXNzJztcbmltcG9ydCBWdWVNRENMaXN0IGZyb20gJy4vbGlzdCc7XG5pbXBvcnQgVnVlTURDTWVudSBmcm9tICcuL21lbnUnO1xuaW1wb3J0IFZ1ZU1EQ1JhZGlvIGZyb20gJy4vcmFkaW8nO1xuaW1wb3J0IFZ1ZU1EQ1JpcHBsZSBmcm9tICcuL3JpcHBsZSc7XG5pbXBvcnQgVnVlTURDU2VsZWN0IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCBWdWVNRENTbGlkZXIgZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IFZ1ZU1EQ1NuYWNrYmFyIGZyb20gJy4vc25hY2tiYXInO1xuaW1wb3J0IFZ1ZU1EQ1N3aXRjaCBmcm9tICcuL3N3aXRjaCc7XG5pbXBvcnQgVnVlTURDVGFicyBmcm9tICcuL3RhYnMnO1xuaW1wb3J0IFZ1ZU1EQ1RleHRmaWVsZCBmcm9tICcuL3RleHRmaWVsZCc7XG5pbXBvcnQgVnVlTURDVGhlbWUgZnJvbSAnLi90aGVtZSc7XG5pbXBvcnQgVnVlTURDVG9vbGJhciBmcm9tICcuL3Rvb2xiYXInO1xuaW1wb3J0IFZ1ZU1EQ1RvcEFwcEJhciBmcm9tICcuL3RvcC1hcHAtYmFyJztcbmltcG9ydCBWdWVNRENUeXBvZ3JhcGh5IGZyb20gJy4vdHlwb2dyYXBoeSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbjogJ19fVkVSU0lPTl9fJyxcbiAgaW5zdGFsbCh2bSkge1xuICAgIHZtLnVzZShWdWVNRENCdXR0b24pO1xuICAgIHZtLnVzZShWdWVNRENDYXJkKTtcbiAgICB2bS51c2UoVnVlTURDQ2hlY2tib3gpO1xuICAgIHZtLnVzZShWdWVNRENDaGlwU2V0KTtcbiAgICB2bS51c2UoVnVlTURDRGlhbG9nKTtcbiAgICB2bS51c2UoVnVlTURDRHJhd2VyKTtcbiAgICB2bS51c2UoVnVlTURDRWxldmF0aW9uKTtcbiAgICB2bS51c2UoVnVlTURDRmFiKTtcbiAgICB2bS51c2UoVnVlTURDR3JpZExpc3QpO1xuICAgIHZtLnVzZShWdWVNRENJY29uKTtcbiAgICB2bS51c2UoVnVlTURDSWNvblRvZ2dsZSk7XG4gICAgdm0udXNlKFZ1ZU1EQ0xheW91dEFwcCk7XG4gICAgdm0udXNlKFZ1ZU1EQ0xheW91dEdyaWQpO1xuICAgIHZtLnVzZShWdWVNRENMaW5lYXJQcm9ncmVzcyk7XG4gICAgdm0udXNlKFZ1ZU1EQ0xpc3QpO1xuICAgIHZtLnVzZShWdWVNRENNZW51KTtcbiAgICB2bS51c2UoVnVlTURDUmFkaW8pO1xuICAgIHZtLnVzZShWdWVNRENSaXBwbGUpO1xuICAgIHZtLnVzZShWdWVNRENTZWxlY3QpO1xuICAgIHZtLnVzZShWdWVNRENTbGlkZXIpO1xuICAgIHZtLnVzZShWdWVNRENTbmFja2Jhcik7XG4gICAgdm0udXNlKFZ1ZU1EQ1N3aXRjaCk7XG4gICAgdm0udXNlKFZ1ZU1EQ1RhYnMpO1xuICAgIHZtLnVzZShWdWVNRENUZXh0ZmllbGQpO1xuICAgIHZtLnVzZShWdWVNRENUaGVtZSk7XG4gICAgdm0udXNlKFZ1ZU1EQ1Rvb2xiYXIpO1xuICAgIHZtLnVzZShWdWVNRENUb3BBcHBCYXIpO1xuICAgIHZtLnVzZShWdWVNRENUeXBvZ3JhcGh5KTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnXG5pbXBvcnQge2F1dG9Jbml0fSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbImF1dG9Jbml0IiwicGx1Z2luIiwiX1Z1ZSIsIndpbmRvdyIsIlZ1ZSIsImdsb2JhbCIsInVzZSIsIkJhc2VQbHVnaW4iLCJjb21wb25lbnRzIiwidmVyc2lvbiIsImluc3RhbGwiLCJ2bSIsImtleSIsImNvbXBvbmVudCIsIm5hbWUiLCJDdXN0b21FbGVtZW50IiwiZnVuY3Rpb25hbCIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwicHJvcHMiLCJpcyIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsIkN1c3RvbUVsZW1lbnRNaXhpbiIsIkN1c3RvbUxpbmsiLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsImxpbmsiLCJPYmplY3QiLCJoIiwiZWxlbWVudCIsImJhYmVsSGVscGVycy5leHRlbmRzIiwicGFyZW50IiwiJHJvdXRlciIsIiRyb290IiwiJG9wdGlvbnMiLCJvbiIsImNsaWNrIiwibmF0aXZlT24iLCJDdXN0b21MaW5rTWl4aW4iLCJ0byIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsInJlcGxhY2UiLCJhY3RpdmVDbGFzcyIsImV4YWN0QWN0aXZlQ2xhc3MiLCJjb21wdXRlZCIsImVtaXRDdXN0b21FdmVudCIsImVsIiwiZXZ0VHlwZSIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJldnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUJ1dHRvbiIsImF0dHJzIiwicm9sZSIsImhyZWYiLCJDdXN0b21CdXR0b25NaXhpbiIsImRpc2FibGVkIiwiZXh0cmFjdEljb25Qcm9wIiwiaWNvblByb3AiLCJjbGFzc2VzIiwiY29udGVudCIsIkFycmF5IiwicmVkdWNlIiwicmVzdWx0IiwidmFsdWUiLCJjbGFzc05hbWUiLCJzcGxpdCIsInRleHRDb250ZW50IiwiRGlzcGF0Y2hFdmVudE1peGluIiwibWV0aG9kcyIsIiRlbWl0IiwiZXZlbnQiLCJ0YXJnZXQiLCJldmVudFRhcmdldCIsImFyZ3MiLCJldmVudEFyZ3MiLCJEaXNwYXRjaEZvY3VzTWl4aW4iLCJoYXNGb2N1cyIsIm9uTW91c2VEb3duIiwiX2FjdGl2ZSIsIm9uTW91c2VVcCIsIm9uRm9jdXNFdmVudCIsInNldFRpbWVvdXQiLCJkaXNwYXRjaEZvY3VzRXZlbnQiLCJvbkJsdXJFdmVudCIsIiRlbCIsImFjdGl2ZUVsZW1lbnQiLCJjb250YWlucyIsIm1vdW50ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiYmVmb3JlRGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNRENGb3VuZGF0aW9uIiwiYWRhcHRlciIsImFkYXB0ZXJfIiwiTURDUmlwcGxlQWRhcHRlciIsImhhbmRsZXIiLCJ2YXJOYW1lIiwiY3NzQ2xhc3NlcyIsIlJPT1QiLCJVTkJPVU5ERUQiLCJCR19GT0NVU0VEIiwiRkdfQUNUSVZBVElPTiIsIkZHX0RFQUNUSVZBVElPTiIsInN0cmluZ3MiLCJWQVJfTEVGVCIsIlZBUl9UT1AiLCJWQVJfRkdfU0laRSIsIlZBUl9GR19TQ0FMRSIsIlZBUl9GR19UUkFOU0xBVEVfU1RBUlQiLCJWQVJfRkdfVFJBTlNMQVRFX0VORCIsIm51bWJlcnMiLCJQQURESU5HIiwiSU5JVElBTF9PUklHSU5fU0NBTEUiLCJERUFDVElWQVRJT05fVElNRU9VVF9NUyIsIkZHX0RFQUNUSVZBVElPTl9NUyIsIlRBUF9ERUxBWV9NUyIsInN1cHBvcnRzQ3NzVmFyaWFibGVzXyIsInN1cHBvcnRzUGFzc2l2ZV8iLCJkZXRlY3RFZGdlUHNldWRvVmFyQnVnIiwid2luZG93T2JqIiwibm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaGFzUHNldWRvVmFyQnVnIiwiYm9yZGVyVG9wU3R5bGUiLCJyZW1vdmUiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlcyIsImZvcmNlUmVmcmVzaCIsInN1cHBvcnRzRnVuY3Rpb25QcmVzZW50IiwiQ1NTIiwic3VwcG9ydHMiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiYXBwbHlQYXNzaXZlIiwiZ2xvYmFsT2JqIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiZSIsImdldE1hdGNoZXNQcm9wZXJ0eSIsIkhUTUxFbGVtZW50UHJvdG90eXBlIiwiZmlsdGVyIiwicCIsInBvcCIsImdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyIsImV2IiwicGFnZU9mZnNldCIsImNsaWVudFJlY3QiLCJ4IiwieSIsImRvY3VtZW50WCIsImxlZnQiLCJkb2N1bWVudFkiLCJ0b3AiLCJub3JtYWxpemVkWCIsIm5vcm1hbGl6ZWRZIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNVbmJvdW5kZWQiLCJpc1N1cmZhY2VBY3RpdmUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJjb250YWluc0V2ZW50VGFyZ2V0IiwicmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyUmVzaXplSGFuZGxlciIsImRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwidXBkYXRlQ3NzVmFyaWFibGUiLCJjb21wdXRlQm91bmRpbmdSZWN0IiwiZ2V0V2luZG93UGFnZU9mZnNldCIsImRlZmF1bHRBZGFwdGVyIiwibGF5b3V0RnJhbWVfIiwiZnJhbWVfIiwid2lkdGgiLCJoZWlnaHQiLCJhY3RpdmF0aW9uU3RhdGVfIiwiZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8iLCJpbml0aWFsU2l6ZV8iLCJtYXhSYWRpdXNfIiwiYWN0aXZhdGVIYW5kbGVyXyIsImFjdGl2YXRlXyIsImRlYWN0aXZhdGVIYW5kbGVyXyIsImRlYWN0aXZhdGVfIiwiZm9jdXNIYW5kbGVyXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJsdXJIYW5kbGVyXyIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJpc0FjdGl2YXRlZCIsImhhc0RlYWN0aXZhdGlvblVYUnVuIiwid2FzQWN0aXZhdGVkQnlQb2ludGVyIiwid2FzRWxlbWVudE1hZGVBY3RpdmUiLCJhY3RpdmF0aW9uRXZlbnQiLCJpc1Byb2dyYW1tYXRpYyIsImlzU3VwcG9ydGVkXyIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImxheW91dEludGVybmFsXyIsImRlcmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsInJlbW92ZUNzc1ZhcnNfIiwiZm9yRWFjaCIsImtleXMiLCJrIiwiaW5kZXhPZiIsImFjdGl2YXRpb25TdGF0ZSIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50IiwiaXNTYW1lSW50ZXJhY3Rpb24iLCJoYXNBY3RpdmF0ZWRDaGlsZCIsImxlbmd0aCIsInNvbWUiLCJyZXNldEFjdGl2YXRpb25TdGF0ZV8iLCJwdXNoIiwicmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJhbmltYXRlQWN0aXZhdGlvbl8iLCJ0cmFuc2xhdGVTdGFydCIsInRyYW5zbGF0ZUVuZCIsImdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18iLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJjbGVhclRpbWVvdXQiLCJybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18iLCJhY3RpdmF0aW9uSGFzRW5kZWQiLCJzdGF0ZSIsImV2dE9iamVjdCIsImFuaW1hdGVEZWFjdGl2YXRpb25fIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtYXhEaW0iLCJNYXRoIiwibWF4IiwiZ2V0Qm91bmRlZFJhZGl1cyIsImh5cG90ZW51c2UiLCJzcXJ0IiwicG93IiwidXBkYXRlTGF5b3V0Q3NzVmFyc18iLCJyb3VuZCIsInVuYm91bmRlZCIsIlJpcHBsZUJhc2UiLCJyZWYiLCJNQVRDSEVTIiwiX21hdGNoZXMiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCIkc2V0IiwiJGRlbGV0ZSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJSaXBwbGVNaXhpbiIsInJpcHBsZSIsImluaXQiLCJkZXN0cm95IiwibWl4aW5zIiwibWRjUmlwcGxlIiwiZXh0ZW5kcyIsIm1kY0J1dHRvbkJhc2UiLCJyYWlzZWQiLCJ1bmVsZXZhdGVkIiwic3Ryb2tlZCIsImRlbnNlIiwiYWNjZW50Iiwid2F0Y2giLCJtZGNCdXR0b24iLCJzcmMiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJzcXVhcmUiLCJmdWxsQmxlZWQiLCJjb21wYWN0IiwiaWNvbiIsIm1kY0NhcmQiLCJtZGNDYXJkUHJpbWFyeUFjdGlvbiIsIm1kY0NhcmRNZWRpYSIsIm1kY0NhcmRIZWFkZXIiLCJtZGNDYXJkVGl0bGUiLCJtZGNDYXJkU3VidGl0bGUiLCJtZGNDYXJkVGV4dCIsIm1kY0NhcmRBY3Rpb25zIiwibWRjQ2FyZEFjdGlvbkJ1dHRvbnMiLCJtZGNDYXJkQWN0aW9uQnV0dG9uIiwibWRjQ2FyZEFjdGlvbkljb25zIiwibWRjQ2FyZEFjdGlvbkljb24iLCJNRENDb21wb25lbnQiLCJyb290IiwiZm91bmRhdGlvbiIsInJvb3RfIiwiaW5pdGlhbGl6ZSIsImZvdW5kYXRpb25fIiwiZ2V0RGVmYXVsdEZvdW5kYXRpb24iLCJpbml0aWFsU3luY1dpdGhET00iLCJFcnJvciIsIk1EQ1JpcHBsZSIsInVuYm91bmRlZF8iLCJzZXRVbmJvdW5kZWQiLCJhY3RpdmF0ZSIsImRlYWN0aXZhdGUiLCJjcmVhdGVBZGFwdGVyIiwiZGF0YXNldCIsInNldFVuYm91bmRlZF8iLCJpbnN0YW5jZSIsInV0aWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJzdHlsZSIsInNldFByb3BlcnR5IiwiTURDU2VsZWN0aW9uQ29udHJvbCIsIk1EQ0NoZWNrYm94QWRhcHRlciIsImF0dHIiLCJVUEdSQURFRCIsIkNIRUNLRUQiLCJJTkRFVEVSTUlOQVRFIiwiRElTQUJMRUQiLCJBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQiLCJBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEIiwiQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCIsIk5BVElWRV9DT05UUk9MX1NFTEVDVE9SIiwiVFJBTlNJVElPTl9TVEFURV9JTklUIiwiVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIiwiVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQiLCJUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEUiLCJBUklBX0NIRUNLRURfQVRUUiIsIkFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFIiwiQU5JTV9FTkRfTEFUQ0hfTVMiLCJDQl9QUk9UT19QUk9QUyIsIk1EQ0NoZWNrYm94Rm91bmRhdGlvbiIsInNldE5hdGl2ZUNvbnRyb2xBdHRyIiwicmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIiLCJyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlciIsInJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyIiwiZ2V0TmF0aXZlQ29udHJvbCIsImZvcmNlTGF5b3V0IiwiaXNBdHRhY2hlZFRvRE9NIiwiY3VycmVudENoZWNrU3RhdGVfIiwiY3VycmVudEFuaW1hdGlvbkNsYXNzXyIsImFuaW1FbmRMYXRjaFRpbWVyXyIsImFuaW1FbmRIYW5kbGVyXyIsImhhbmRsZUFuaW1hdGlvbkVuZCIsImNoYW5nZUhhbmRsZXJfIiwiaGFuZGxlQ2hhbmdlIiwiZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8iLCJnZXROYXRpdmVDb250cm9sXyIsImluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXyIsInVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfIiwiY2hlY2tlZCIsImluZGV0ZXJtaW5hdGUiLCJ0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8iLCJuYXRpdmVDYiIsImNiUHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNvbnRyb2xTdGF0ZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ2YWxpZERlc2NyaXB0b3IiLCJuYXRpdmVDYkRlc2MiLCJnZXQiLCJzZXQiLCJjYWxsIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsImlzSW5kZXRlcm1pbmF0ZSIsImdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18iLCJpbnB1dFByb3BEZXNjIiwiTURDRm9ybUZpZWxkQWRhcHRlciIsIkxBQkVMX1NFTEVDVE9SIiwiTURDRm9ybUZpZWxkRm91bmRhdGlvbiIsImFjdGl2YXRlSW5wdXRSaXBwbGUiLCJkZWFjdGl2YXRlSW5wdXRSaXBwbGUiLCJjbGlja0hhbmRsZXJfIiwiaGFuZGxlQ2xpY2tfIiwiZXZlbnRUeXBlTWFwIiwibm9QcmVmaXgiLCJ3ZWJraXRQcmVmaXgiLCJzdHlsZVByb3BlcnR5IiwiY3NzUHJvcGVydHlNYXAiLCJoYXNQcm9wZXJTaGFwZSIsImV2ZW50Rm91bmRJbk1hcHMiLCJldmVudFR5cGUiLCJnZXRKYXZhU2NyaXB0RXZlbnROYW1lIiwibWFwIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImV2ZW50TmFtZSIsInRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyIsImdldENvcnJlY3RFdmVudE5hbWUiLCJnZXRDb3JyZWN0UHJvcGVydHlOYW1lIiwibW9kZWwiLCJwcm9wIiwibGFiZWwiLCJoYXNMYWJlbCIsIiRzbG90cyIsImZvcm1GaWVsZENsYXNzZXMiLCJhbGlnbkVuZCIsInNldENoZWNrZWQiLCJzZXREaXNhYmxlZCIsInNldEluZGV0ZXJtaW5hdGUiLCIkcmVmcyIsImNvbnRyb2wiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvZmZzZXRXaWR0aCIsInBhcmVudE5vZGUiLCJmb3JtRmllbGQiLCJvbkNoYW5nZSIsImlzQ2hlY2tlZCIsIm1kY0NoZWNrYm94IiwiTURDQ2hpcEFkYXB0ZXIiLCJJTlRFUkFDVElPTl9FVkVOVCIsIkxFQURJTkdfSUNPTl9TRUxFQ1RPUiIsIlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQiLCJUUkFJTElOR19JQ09OX1NFTEVDVE9SIiwiQ0hFQ0tNQVJLIiwiSElEREVOX0xFQURJTkdfSUNPTiIsIkxFQURJTkdfSUNPTiIsIlNFTEVDVEVEIiwiTURDQ2hpcEZvdW5kYXRpb24iLCJoYXNDbGFzcyIsImFkZENsYXNzVG9MZWFkaW5nSWNvbiIsInJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uIiwiZXZlbnRUYXJnZXRIYXNDbGFzcyIsInJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwiZGVyZWdpc3RlckV2ZW50SGFuZGxlciIsInJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeUludGVyYWN0aW9uIiwibm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb24iLCJpbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlSW50ZXJhY3Rpb25fIiwidHJhbnNpdGlvbkVuZEhhbmRsZXJfIiwiaGFuZGxlVHJhbnNpdGlvbkVuZF8iLCJ0cmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25fIiwia2V5Q29kZSIsInByb3BlcnR5TmFtZSIsInN0b3BQcm9wYWdhdGlvbiIsImxlYWRpbmdJY29uIiwidHJhaWxpbmdJY29uIiwibGVhZGluZ0ljb25DbGFzc2VzIiwidHJhaWxpbmdJY29uQ2xhc3NlcyIsImluamVjdCIsInRvZ2dsZVNlbGVjdGVkIiwiaGF2ZWxlYWRpbmdJY29uIiwiY2hpcCIsImlzRmlsdGVyIiwibWRjQ2hpcFNldCIsImhhdmV0cmFpbGluZ0ljb24iLCJsZWFkaW5nQ2xhc3NlcyIsInRyYWlsaW5nQ2xhc3NlcyIsIk1EQ0NoaXBTZXRBZGFwdGVyIiwiTURDQ2hpcCIsImxlYWRpbmdJY29uXyIsInF1ZXJ5U2VsZWN0b3IiLCJyaXBwbGVfIiwidHJhaWxpbmdJY29uRWwiLCJlbWl0IiwiQ0hJUF9TRUxFQ1RPUiIsIkNIT0lDRSIsIkZJTFRFUiIsIk1EQ0NoaXBTZXRGb3VuZGF0aW9uIiwic2VsZWN0ZWRDaGlwc18iLCJjaGlwSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZUNoaXBJbnRlcmFjdGlvbl8iLCJpbmRleCIsInNwbGljZSIsImNob2ljZSIsInByb3ZpZGUiLCJtZGNDaGlwIiwiT1BFTiIsIkFOSU1BVElORyIsIkJBQ0tEUk9QIiwiU0NST0xMX0xPQ0siLCJBQ0NFUFRfQlROIiwiQ0FOQ0VMX0JUTiIsIk9QRU5fRElBTE9HX1NFTEVDVE9SIiwiRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1IiLCJBQ0NFUFRfU0VMRUNUT1IiLCJBQ0NFUFRfRVZFTlQiLCJDQU5DRUxfRVZFTlQiLCJNRENEaWFsb2dGb3VuZGF0aW9uIiwiYWRkQm9keUNsYXNzIiwicmVtb3ZlQm9keUNsYXNzIiwicmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlciIsInJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIiLCJkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIiLCJub3RpZnlBY2NlcHQiLCJub3RpZnlDYW5jZWwiLCJ0cmFwRm9jdXNPblN1cmZhY2UiLCJ1bnRyYXBGb2N1c09uU3VyZmFjZSIsImlzRGlhbG9nIiwibGF5b3V0Rm9vdGVyUmlwcGxlcyIsImlzT3Blbl8iLCJjb21wb25lbnRDbGlja0hhbmRsZXJfIiwiY2FuY2VsIiwiZGlhbG9nQ2xpY2tIYW5kbGVyXyIsImhhbmRsZURpYWxvZ0NsaWNrXyIsImRvY3VtZW50S2V5ZG93bkhhbmRsZXJfIiwiZW5hYmxlU2Nyb2xsXyIsImRpc2FibGVTY3JvbGxfIiwic2hvdWxkTm90aWZ5IiwiY2xvc2UiLCJhY2NlcHQiLCJtb2R1bGUiLCJlbGVtZW50RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiYmFzaWNUYWJiYWJsZXMiLCJvcmRlcmVkVGFiYmFibGVzIiwiaXNVbmF2YWlsYWJsZSIsImNyZWF0ZUlzVW5hdmFpbGFibGUiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImpvaW4iLCJpbmNsdWRlQ29udGFpbmVyIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsImNhbmRpZGF0ZVNlbGVjdG9yIiwic2xpY2UiLCJhcHBseSIsInVuc2hpZnQiLCJjYW5kaWRhdGUiLCJjYW5kaWRhdGVJbmRleCIsImkiLCJsIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0YWJJbmRleCIsInRhZ05hbWUiLCJ0YWJiYWJsZU5vZGVzIiwic29ydCIsImEiLCJiIiwiaXNPZmZDYWNoZSIsImlzT2ZmIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJkZWZhdWx0VmlldyIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwibGlzdGVuaW5nRm9jdXNUcmFwIiwiZm9jdXNUcmFwIiwidXNlck9wdGlvbnMiLCJmaXJzdFRhYmJhYmxlTm9kZSIsImxhc3RUYWJiYWJsZU5vZGUiLCJub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24iLCJhY3RpdmUiLCJwYXVzZWQiLCJ0YWJFdmVudCIsImNvbnRhaW5lciIsImNvbmZpZyIsInJldHVybkZvY3VzT25EZWFjdGl2YXRlIiwiZXNjYXBlRGVhY3RpdmF0ZXMiLCJ0cmFwIiwicGF1c2UiLCJ1bnBhdXNlIiwiYWN0aXZhdGVPcHRpb25zIiwiZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zIiwib25BY3RpdmF0ZSIsImRlYWN0aXZhdGVPcHRpb25zIiwiZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMiLCJyZXR1cm5Gb2N1cyIsIm9uRGVhY3RpdmF0ZSIsImFkZExpc3RlbmVycyIsImZpcnN0Rm9jdXNOb2RlIiwiY2hlY2tGb2N1cyIsImNoZWNrQ2xpY2siLCJjaGVja1BvaW50ZXJEb3duIiwiY2hlY2tLZXkiLCJyZW1vdmVMaXN0ZW5lcnMiLCJnZXROb2RlRm9yT3B0aW9uIiwib3B0aW9uTmFtZSIsIm9wdGlvblZhbHVlIiwiY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImJsdXIiLCJpc0VzY2FwZUV2ZW50IiwiaGFuZGxlVGFiIiwiaGFzQXR0cmlidXRlIiwiTnVtYmVyIiwiY3VycmVudEZvY3VzSW5kZXgiLCJzaGlmdEtleSIsInRyeUZvY3VzIiwidXBkYXRlVGFiYmFibGVOb2RlcyIsInRhYmJhYmxlIiwicmVhZGp1c3RGb2N1cyIsImZvY3VzIiwidG9Mb3dlckNhc2UiLCJzZWxlY3QiLCJjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZSIsInN1cmZhY2VFbCIsImFjY2VwdEJ1dHRvbkVsIiwiZm9jdXNUcmFwRmFjdG9yeSIsImNyZWF0ZUZvY3VzVHJhcCIsImluaXRpYWxGb2N1cyIsInRpdGxlIiwicmVxdWlyZWQiLCJhY2NlcHREaXNhYmxlZCIsInNjcm9sbGFibGUiLCJkYXJrIiwic3VyZmFjZUNsYXNzZXMiLCJib2R5Q2xhc3NlcyIsInN1cmZhY2UiLCJvbkNhbmNlbCIsIm9uQWNjZXB0IiwiJGxpc3RlbmVycyIsIm5vdGlmeSIsInNob3ciLCJvcGVuIiwibWRjRGlhbG9nIiwiRk9DVVNBQkxFX0VMRU1FTlRTIiwiTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIiwiaGFzTmVjZXNzYXJ5RG9tIiwicmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyIiwic2V0VHJhbnNsYXRlWCIsImdldEZvY3VzYWJsZUVsZW1lbnRzIiwic2F2ZUVsZW1lbnRUYWJTdGF0ZSIsInJlc3RvcmVFbGVtZW50VGFiU3RhdGUiLCJtYWtlRWxlbWVudFVudGFiYmFibGUiLCJub3RpZnlPcGVuIiwibm90aWZ5Q2xvc2UiLCJpc1J0bCIsImdldERyYXdlcldpZHRoIiwicm9vdENzc0NsYXNzIiwiYW5pbWF0aW5nQ3NzQ2xhc3MiLCJvcGVuQ3NzQ2xhc3MiLCJyb290Q3NzQ2xhc3NfIiwiYW5pbWF0aW5nQ3NzQ2xhc3NfIiwib3BlbkNzc0NsYXNzXyIsImluZXJ0XyIsImNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyIsImhhbmRsZVRvdWNoU3RhcnRfIiwiY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8iLCJoYW5kbGVUb3VjaE1vdmVfIiwiY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyIsImhhbmRsZVRvdWNoRW5kXyIsImRldGFiaW5hdGVfIiwicmV0YWJpbmF0ZV8iLCJlbGVtZW50cyIsInBvaW50ZXJUeXBlIiwiZGlyZWN0aW9uXyIsImRyYXdlcldpZHRoXyIsInN0YXJ0WF8iLCJ0b3VjaGVzIiwiY3VycmVudFhfIiwidXBkYXRlUmFmXyIsInVwZGF0ZURyYXdlcl8iLCJiaW5kIiwicHJlcGFyZUZvclRvdWNoRW5kXyIsImFicyIsIm5ld1Bvc2l0aW9uXyIsImlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8iLCJuZXdQb3MiLCJtaW4iLCJEUkFXRVJfU0VMRUNUT1IiLCJPUEVOX0VWRU5UIiwiQ0xPU0VfRVZFTlQiLCJNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiIsImlzRHJhd2VyIiwiVEFCX0RBVEEiLCJUQUJfREFUQV9IQU5ETEVEIiwic3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyIsInJlbWFwRXZlbnQiLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJ0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMiLCJfcmVmcmVzaCIsImRyYXdlciIsImdldFByb3BlcnR5VmFsdWUiLCJPUEFDSVRZX1ZBUl9OQU1FIiwiTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiIsIm5ld09wYWNpdHkiLCJtZWRpYSIsIl9zbWFsbCIsIm1hdGNoTWVkaWEiLCJfbGFyZ2UiLCJwZXJtYW5lbnQiLCJwZXJzaXN0ZW50IiwidGVtcG9yYXJ5IiwiZHJhd2VyVHlwZSIsInZhbGlkYXRvciIsInZhbCIsInRvb2xiYXJTcGFjZXIiLCJ0b2dnbGVPbiIsInRvZ2dsZU9uU291cmNlIiwib3Blbk9uIiwib3Blbk9uU291cmNlIiwiY2xvc2VPbiIsImNsb3NlT25Tb3VyY2UiLCJtZGNEcmF3ZXIiLCJzbWFsbCIsImxhcmdlIiwib3Blbl8iLCJtZGNQZXJtYW5lbnREcmF3ZXIiLCJtZGNQZXJzaXN0ZW50RHJhd2VyIiwibWRjVGVtcG9yYXJ5RHJhd2VyIiwiaXNQZXJtYW5lbnQiLCJpc1BlcnNpc3RlbnQiLCJpc1RlbXBvcmFyeSIsImlzUmVzcG9uc2l2ZSIsInRvZ2dsZSIsImlzT3BlbiIsInJlZnJlc2hNZWRpYSIsImNyZWF0ZWQiLCJzb3VyY2UiLCIkb24iLCJhZGRMaXN0ZW5lciIsIiRuZXh0VGljayIsInJlbW92ZUxpc3RlbmVyIiwic3RhcnRJY29uIiwidGVtcG9yYXJ5Q2xvc2UiLCJhY3RpdmF0ZWQiLCJpdGVtQ2xhc3NlcyIsImhhc1N0YXJ0RGV0YWlsIiwib25DbGljayIsIm1kY0RyYXdlckxheW91dCIsIm1kY0RyYXdlckhlYWRlciIsIm1kY0RyYXdlckxpc3QiLCJtZGNEcmF3ZXJJdGVtIiwibWRjRHJhd2VyRGl2aWRlciIsIm1kY0VsZXZhdGlvbiIsIm1pbmkiLCJhYnNvbHV0ZSIsImZpeGVkIiwibWRjRkFCIiwiVElMRVNfU0VMRUNUT1IiLCJUSUxFX1NFTEVDVE9SIiwiTURDR3JpZExpc3RGb3VuZGF0aW9uIiwiZ2V0T2Zmc2V0V2lkdGgiLCJnZXROdW1iZXJPZlRpbGVzIiwiZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleCIsInNldFN0eWxlRm9yVGlsZXNFbGVtZW50IiwiYWxpZ25DZW50ZXIiLCJyZXNpemVGcmFtZV8iLCJhbGlnbkNlbnRlcl8iLCJncmlkV2lkdGgiLCJpdGVtV2lkdGgiLCJ0aWxlc1dpZHRoIiwiZmxvb3IiLCJtZGNHcmlkIiwibmFycm93R3V0dGVyIiwiaGVhZGVyQ2FwdGlvbiIsInJhdGlvIiwiaWNvbkFsaWduU3RhcnQiLCJpY29uQWxpZ25FbmQiLCJ3aXRoU3VwcG9ydFRleHQiLCJpbnRlcmFjdGl2ZSIsImRlZmF1bHRXaWR0aCIsInByb3BlcnR5Iiwic2VsZWN0ZWQiLCJpc0ludGVyYWN0aXZlIiwiaGFzRW5kRGV0YWlsIiwiZW5kSWNvbiIsImFkZFJpcHBsZSIsInJlbW92ZVJpcHBsZSIsIm1kY0dyaWRMaXN0IiwibWRjR3JpZFRpbGUiLCJtZGNJY29uIiwiTURDSWNvblRvZ2dsZUFkYXB0ZXIiLCJ0ZXh0IiwiREFUQV9UT0dHTEVfT04iLCJEQVRBX1RPR0dMRV9PRkYiLCJBUklBX1BSRVNTRUQiLCJBUklBX0RJU0FCTEVEIiwiQVJJQV9MQUJFTCIsIkNIQU5HRV9FVkVOVCIsIk1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uIiwic2V0VGV4dCIsImdldFRhYkluZGV4Iiwic2V0VGFiSW5kZXgiLCJnZXRBdHRyIiwic2V0QXR0ciIsInJtQXR0ciIsIm5vdGlmeUNoYW5nZSIsIm9uXyIsImRpc2FibGVkXyIsInNhdmVkVGFiSW5kZXhfIiwidG9nZ2xlT25EYXRhXyIsInRvZ2dsZU9mZkRhdGFfIiwidG9nZ2xlRnJvbUV2dF8iLCJpc0hhbmRsaW5nS2V5ZG93bl8iLCJrZXlkb3duSGFuZGxlcl8iLCJpc1NwYWNlIiwia2V5dXBIYW5kbGVyXyIsInJlZnJlc2hUb2dnbGVEYXRhIiwicGFyc2VKc29uRGF0YUF0dHJfIiwiaXNPbiIsImNsYXNzVG9SZW1vdmUiLCJjc3NDbGFzcyIsImRhdGFBdHRyIiwiSlNPTiIsInBhcnNlIiwiaXNEaXNhYmxlZCIsImtleWJvYXJkS2V5IiwidG9nZ2xlT2ZmIiwiaWNvbkNsYXNzZXMiLCJ0b2dnbGVPbkRhdGEiLCJ0b2dnbGVPZmZEYXRhIiwic3RyaW5naWZ5IiwiaXNLZXlib2FyZEFjdGl2YXRlZCIsIm1kY0lDb25Ub2dnbGUiLCJtZGNMYXlvdXRBcHAiLCJmaXhlZENvbHVtbldpZHRoIiwic3Bhbk9wdGlvbnMiLCJudW0iLCJpc0Zpbml0ZSIsInNwYW4iLCJvcmRlciIsInBob25lIiwidGFibGV0IiwiZGVza3RvcCIsImFsaWduIiwibWRjTGF5b3V0R3JpZCIsIm1kY0xheW91dENlbGwiLCJtZGNMYXlvdXRJbm5lckdyaWQiLCJDTE9TRURfQ0xBU1MiLCJJTkRFVEVSTUlOQVRFX0NMQVNTIiwiUkVWRVJTRURfQ0xBU1MiLCJQUklNQVJZX0JBUl9TRUxFQ1RPUiIsIkJVRkZFUl9TRUxFQ1RPUiIsIk1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiIsImdldFByaW1hcnlCYXIiLCJnZXRCdWZmZXIiLCJzZXRTdHlsZSIsImRldGVybWluYXRlXyIsInJldmVyc2VfIiwicHJvZ3Jlc3NfIiwiaXNEZXRlcm1pbmF0ZSIsInNldFNjYWxlXyIsImlzUmV2ZXJzZWQiLCJzY2FsZVZhbHVlIiwidHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSIsIlByb2dyZXNzUHJvcFR5cGUiLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwiYnVmZmVyIiwic2V0QnVmZmVyIiwic2V0RGV0ZXJtaW5hdGUiLCJyZXZlcnNlIiwic2V0UmV2ZXJzZSIsInByaW1hcnkiLCJtZGNMaW5lYXJQcm9ncmVzcyIsImF2YXRhckxpc3QiLCJ0d29MaW5lIiwiYm9yZGVyZWQiLCJtZGNMaXN0IiwiaGFzU2Vjb25kYXJ5IiwiaW5zZXQiLCJwYWRkZWQiLCJtZGNMaXN0SXRlbSIsIm1kY0xpc3REaXZpZGVyIiwibWRjTGlzdEdyb3VwIiwibWRjTGlzdEdyb3VwSGVhZGVyIiwibWRjTGlzdEdyb3VwRGl2aWRlciIsIk1EQ01lbnVBZGFwdGVyIiwiYXR0cmlidXRlTmFtZSIsIm9yaWdpbiIsInBvc2l0aW9uIiwiQU5JTUFUSU5HX09QRU4iLCJBTklNQVRJTkdfQ0xPU0VEIiwiU0VMRUNURURfTElTVF9JVEVNIiwiSVRFTVNfU0VMRUNUT1IiLCJTRUxFQ1RFRF9FVkVOVCIsIkFSSUFfRElTQUJMRURfQVRUUiIsIlNFTEVDVEVEX1RSSUdHRVJfREVMQVkiLCJUUkFOU0lUSU9OX09QRU5fRFVSQVRJT04iLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwiTUFSR0lOX1RPX0VER0UiLCJBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTyIsIk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTyIsIkNvcm5lckJpdCIsIkJPVFRPTSIsIkNFTlRFUiIsIlJJR0hUIiwiRkxJUF9SVEwiLCJDb3JuZXIiLCJUT1BfTEVGVCIsIlRPUF9SSUdIVCIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiVE9QX1NUQVJUIiwiVE9QX0VORCIsIkJPVFRPTV9TVEFSVCIsIkJPVFRPTV9FTkQiLCJNRENNZW51Rm91bmRhdGlvbiIsImdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0IiwiZ2V0SW5uZXJEaW1lbnNpb25zIiwiaGFzQW5jaG9yIiwiZ2V0QW5jaG9yRGltZW5zaW9ucyIsImdldFdpbmRvd0RpbWVuc2lvbnMiLCJnZXROdW1iZXJPZkl0ZW1zIiwicmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyIiwiZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIiLCJnZXRJbmRleEZvckV2ZW50VGFyZ2V0Iiwibm90aWZ5U2VsZWN0ZWQiLCJzYXZlRm9jdXMiLCJyZXN0b3JlRm9jdXMiLCJpc0ZvY3VzZWQiLCJnZXRGb2N1c2VkSXRlbUluZGV4IiwiZm9jdXNJdGVtQXRJbmRleCIsInNldFRyYW5zZm9ybU9yaWdpbiIsInNldFBvc2l0aW9uIiwic2V0TWF4SGVpZ2h0Iiwic2V0QXR0ckZvck9wdGlvbkF0SW5kZXgiLCJybUF0dHJGb3JPcHRpb25BdEluZGV4IiwiYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4Iiwicm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgiLCJoYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyIsImhhbmRsZUtleWJvYXJkRG93bl8iLCJoYW5kbGVLZXlib2FyZFVwXyIsImRvY3VtZW50Q2xpY2tIYW5kbGVyXyIsImhhbmRsZURvY3VtZW50Q2xpY2tfIiwib3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfIiwiY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyIsInNlbGVjdGVkVHJpZ2dlclRpbWVySWRfIiwiYW5pbWF0aW9uUmVxdWVzdElkXyIsImRpbWVuc2lvbnNfIiwiaXRlbUhlaWdodF8iLCJhbmNob3JDb3JuZXJfIiwiYW5jaG9yTWFyZ2luXyIsInJpZ2h0IiwiYm90dG9tIiwibWVhc3VyZXNfIiwic2VsZWN0ZWRJbmRleF8iLCJyZW1lbWJlclNlbGVjdGlvbl8iLCJxdWlja09wZW5fIiwia2V5RG93bldpdGhpbk1lbnVfIiwiY29ybmVyIiwibWFyZ2luIiwicmVtZW1iZXJTZWxlY3Rpb24iLCJzZXRTZWxlY3RlZEluZGV4IiwicXVpY2tPcGVuIiwiZm9jdXNJbmRleCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiaXNUYWIiLCJpc0Fycm93VXAiLCJpc0Fycm93RG93biIsImlzRW50ZXIiLCJmb2N1c2VkSXRlbUluZGV4IiwibGFzdEl0ZW1JbmRleCIsImlzRXNjYXBlIiwidGFyZ2V0SW5kZXgiLCJhbmNob3JSZWN0Iiwidmlld3BvcnQiLCJ2aWV3cG9ydERpc3RhbmNlIiwiYW5jaG9ySGVpZ2h0IiwiYW5jaG9yV2lkdGgiLCJtZW51SGVpZ2h0IiwibWVudVdpZHRoIiwiaXNCb3R0b21BbGlnbmVkIiwiYXZhaWxhYmxlVG9wIiwiYXZhaWxhYmxlQm90dG9tIiwidG9wT3ZlcmZsb3ciLCJib3R0b21PdmVyZmxvdyIsImlzRmxpcFJ0bCIsImF2b2lkSG9yaXpvbnRhbE92ZXJsYXAiLCJpc0FsaWduZWRSaWdodCIsImF2YWlsYWJsZUxlZnQiLCJhdmFpbGFibGVSaWdodCIsImxlZnRPdmVyZmxvdyIsInJpZ2h0T3ZlcmZsb3ciLCJpc1JpZ2h0QWxpZ25lZCIsInJpZ2h0T2Zmc2V0IiwibGVmdE9mZnNldCIsImF2b2lkVmVydGljYWxPdmVybGFwIiwiY2FuT3ZlcmxhcFZlcnRpY2FsbHkiLCJtYXhIZWlnaHQiLCJnZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXyIsImdldE9yaWdpbkNvcm5lcl8iLCJtYXhNZW51SGVpZ2h0IiwiZ2V0TWVudU1heEhlaWdodF8iLCJ2ZXJ0aWNhbEFsaWdubWVudCIsImhvcml6b250YWxBbGlnbm1lbnQiLCJob3Jpem9udGFsT2Zmc2V0IiwiZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8iLCJ2ZXJ0aWNhbE9mZnNldCIsImdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0XyIsInZlcnRpY2FsT2Zmc2V0UGVyY2VudCIsIm9yaWdpblBlcmNlbnQiLCJhdXRvUG9zaXRpb25fIiwiZm9jdXNPbk9wZW5fIiwidGFyZ2V0SXNEaXNhYmxlZCIsInByZXZTZWxlY3RlZEluZGV4Iiwib3BlbkZyb21Ub3BMZWZ0Iiwib3BlbkZyb21Ub3BSaWdodCIsIm9wZW5Gcm9tQm90dG9tTGVmdCIsIm9wZW5Gcm9tQm90dG9tUmlnaHQiLCJpdGVtcyIsImhpZGUiLCJyZWZyZXNoSXRlbXMiLCJzbG90T2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJfcHJldmlvdXNGb2N1cyIsIm9mZnNldEhlaWdodCIsInBhcmVudEVsZW1lbnQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJpdGVtIiwiYW5jaG9yQ29ybmVyIiwic2V0QW5jaG9yQ29ybmVyIiwiYW5jaG9yTWFyZ2luIiwic2V0QW5jaG9yTWFyZ2luIiwibnYiLCJzZXRRdWlja09wZW4iLCJkaXNjb25uZWN0IiwibWRjTWVudSIsIm1kY01lbnVJdGVtIiwibWRjTWVudURpdmlkZXIiLCJtZGNNZW51QW5jaG9yIiwiTURDUmFkaW9BZGFwdGVyIiwiTURDUmFkaW9Gb3VuZGF0aW9uIiwic2V0VmFsdWUiLCJwaWNrZWQiLCJnZXRWYWx1ZSIsInN5bmMiLCJtZGNSYWRpbyIsIm5ld1ZhbHVlIiwiQk9YIiwiQk9UVE9NX0xJTkVfU0VMRUNUT1IiLCJNRU5VX1NFTEVDVE9SIiwiU1VSRkFDRV9TRUxFQ1RPUiIsIlNFTEVDVEVEX1RFWFRfU0VMRUNUT1IiLCJNRENNZW51IiwicHJldmlvdXNGb2N1c18iLCJpdGVtc0NvbnRhaW5lcl8iLCJpdGVtc0NvbnRhaW5lciIsImdldFNlbGVjdGVkSW5kZXgiLCJzZXRSZW1lbWJlclNlbGVjdGlvbiIsIk9QRU5FUl9LRVlTIiwiZm9yVHlwZSIsIk1EQ1NlbGVjdEZvdW5kYXRpb24iLCJmbG9hdExhYmVsIiwiYWN0aXZhdGVCb3R0b21MaW5lIiwiZGVhY3RpdmF0ZUJvdHRvbUxpbmUiLCJtYWtlVGFiYmFibGUiLCJtYWtlVW50YWJiYWJsZSIsImdldENvbXB1dGVkU3R5bGVWYWx1ZSIsImNyZWF0ZTJkUmVuZGVyaW5nQ29udGV4dCIsImZvbnQiLCJtZWFzdXJlVGV4dCIsInNldE1lbnVFbFN0eWxlIiwic2V0TWVudUVsQXR0ciIsInJtTWVudUVsQXR0ciIsImdldE1lbnVFbE9mZnNldEhlaWdodCIsIm9wZW5NZW51IiwiaXNNZW51T3BlbiIsInNldFNlbGVjdGVkVGV4dENvbnRlbnQiLCJnZXROdW1iZXJPZk9wdGlvbnMiLCJnZXRUZXh0Rm9yT3B0aW9uQXRJbmRleCIsImdldFZhbHVlRm9yT3B0aW9uQXRJbmRleCIsImdldE9mZnNldFRvcEZvck9wdGlvbkF0SW5kZXgiLCJyZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlciIsImdldFdpbmRvd0lubmVySGVpZ2h0IiwiY3R4XyIsImlzRm9jdXNlZF8iLCJkaXNwbGF5SGFuZGxlcl8iLCJkaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyIsImhhbmRsZURpc3BsYXlWaWFLZXlib2FyZF8iLCJzZWxlY3Rpb25IYW5kbGVyXyIsImNsb3NlXyIsImNhbmNlbEhhbmRsZXJfIiwicmVzaXplIiwic2VsZWN0ZWRUZXh0Q29udGVudCIsInRyaW0iLCJsZXR0ZXJTcGFjaW5nIiwicGFyc2VGbG9hdCIsInByaW1hcnlGb250RmFtaWx5IiwiZm9udFNpemUiLCJtYXhUZXh0TGVuZ3RoIiwic3VyZmFjZVBhZGRpbmdSaWdodCIsInN1cmZhY2VQYWRkaW5nTGVmdCIsInNlbGVjdEJveEFkZGVkUGFkZGluZyIsInR4dCIsImFkZGVkU3BhY2UiLCJjZWlsIiwic2V0TWVudVN0eWxlc0Zvck9wZW5BdEluZGV4XyIsIml0ZW1PZmZzZXRUb3AiLCJhZGp1c3RlZFRvcCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsIkVWRU5UX1BIQVNFX0FUX1RBUkdFVCIsImV2ZW50UGhhc2UiLCJpc1NwYWNlRG93biIsImlzT3BlbmVyS2V5IiwiTURDU2VsZWN0Qm90dG9tTGluZUFkYXB0ZXIiLCJCT1RUT01fTElORV9BQ1RJVkUiLCJNRENTZWxlY3RCb3R0b21MaW5lRm91bmRhdGlvbiIsIk1EQ1NlbGVjdExhYmVsQWRhcHRlciIsIkxBQkVMX0ZMT0FUX0FCT1ZFIiwiTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uIiwiZ2V0V2lkdGgiLCJtdWx0aXBsZSIsImJveCIsImxhYmVsQ2xhc3NlcyIsImJvdHRvbUxpbmVDbGFzc2VzIiwic3VyZmFjZVN0eWxlcyIsInJlZnJlc2hJbmRleCIsIm1lbnUiLCJsYWJlbEZvdW5kYXRpb24iLCJib3R0b21MaW5lRm91bmRhdGlvbiIsInN0eWxlRmxvYXQiLCJnZXRDb250ZXh0Iiwib2Zmc2V0VG9wIiwibGFiZWxUeHQiLCJtYXhTaXplIiwic2l6ZSIsImNvdW50Iiwic2Nyb2xsIiwicmVmcmVzaFNpemUiLCJfbW9iaWxlIiwibmF0aXZlIiwibWRjU2VsZWN0IiwiTURDTmF0aXZlU2VsZWN0IiwiTURDTWVudVNlbGVjdCIsIk1EQ011bHRpU2VsZWN0IiwibW9iaWxlIiwiaXNOYXRpdmUiLCJiZWZvcmVNb3VudCIsImhhc1ZhbHVlIiwiTURDTmF0aXZlT3B0aW9uIiwiTURDTXVsdGlPcHRpb24iLCJNRENNZW51T3B0aW9uIiwibWRjT3B0aW9uIiwiQUNUSVZFIiwiRElTQ1JFVEUiLCJGT0NVUyIsIklOX1RSQU5TSVQiLCJJU19ESVNDUkVURSIsIkhBU19UUkFDS19NQVJLRVIiLCJUUkFDS19TRUxFQ1RPUiIsIlRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1IiLCJMQVNUX1RSQUNLX01BUktFUl9TRUxFQ1RPUiIsIlRIVU1CX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIlBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1IiLCJBUklBX1ZBTFVFTUlOIiwiQVJJQV9WQUxVRU1BWCIsIkFSSUFfVkFMVUVOT1ciLCJTVEVQX0RBVEFfQVRUUiIsIklOUFVUX0VWRU5UIiwiUEFHRV9GQUNUT1IiLCJNRENTbGlkZXJBZGFwdGVyIiwibnVtTWFya2VycyIsIktFWV9JRFMiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIk1PVkVfRVZFTlRfTUFQIiwiRE9XTl9FVkVOVFMiLCJVUF9FVkVOVFMiLCJNRENTbGlkZXJGb3VuZGF0aW9uIiwicmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwibm90aWZ5SW5wdXQiLCJzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkiLCJzZXRUcmFja1N0eWxlUHJvcGVydHkiLCJzZXRNYXJrZXJWYWx1ZSIsImFwcGVuZFRyYWNrTWFya2VycyIsInJlbW92ZVRyYWNrTWFya2VycyIsInNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5IiwiaXNSVEwiLCJyZWN0XyIsIk5hTiIsImFjdGl2ZV8iLCJpblRyYW5zaXRfIiwiaXNEaXNjcmV0ZV8iLCJoYXNUcmFja01hcmtlcl8iLCJoYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyIsIm1pbl8iLCJtYXhfIiwic3RlcF8iLCJ2YWx1ZV8iLCJwcmV2ZW50Rm9jdXNTdGF0ZV8iLCJ1cGRhdGVVSUZyYW1lXyIsInRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfIiwiaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfIiwiaGFuZGxlRG93bl8iLCJoYW5kbGVLZXlkb3duXyIsImhhbmRsZUZvY3VzXyIsImhhbmRsZUJsdXJfIiwiZXZ0TmFtZSIsImdldFN0ZXAiLCJnZXRNaW4iLCJnZXRNYXgiLCJzdGVwIiwiaW5kaXZpc2libGUiLCJsYXN0U3RlcFJhdGlvIiwiZmxleCIsInVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXyIsInNldFZhbHVlXyIsInNldHVwVHJhY2tNYXJrZXIiLCJ0b2dnbGVDbGFzc18iLCJpc05hTiIsInNldEluVHJhbnNpdF8iLCJzZXRBY3RpdmVfIiwibW92ZUhhbmRsZXIiLCJoYW5kbGVNb3ZlXyIsInVwSGFuZGxlciIsImhhbmRsZVVwXyIsInNldFZhbHVlRnJvbUV2dF8iLCJ0YXJnZXRUb3VjaGVzIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImtleUlkIiwiZ2V0S2V5SWRfIiwiZ2V0VmFsdWVGb3JLZXlJZF8iLCJrYmRFdnQiLCJkZWx0YSIsInZhbHVlTmVlZHNUb0JlRmxpcHBlZCIsInNob3VsZEZpcmVJbnB1dCIsImZvcmNlIiwidmFsdWVTZXRUb0JvdW5kYXJ5IiwicXVhbnRpemVfIiwibnVtU3RlcHMiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsImluVHJhbnNpdCIsInNob3VsZEJlUHJlc2VudCIsImRpc3BsYXlNYXJrZXJzIiwibGF5b3V0T24iLCJsYXlvdXRPblNvdXJjZSIsInRyYWNrU3R5bGVzIiwibGFzdFRyYWNrTWFya2Vyc1N0eWxlcyIsInRodW1iU3R5bGVzIiwibWFya2VyVmFsdWUiLCJpc0Rpc2NyZXRlIiwiaGFzTWFya2VycyIsInNldE1pbiIsInNldE1heCIsInNldFN0ZXAiLCJ0aHVtYkNvbnRhaW5lciIsIm1kY1NsaWRlciIsIlRFWFQiLCJBQ1RJT05fV1JBUFBFUiIsIkFDVElPTl9CVVRUT04iLCJNVUxUSUxJTkUiLCJBQ1RJT05fT05fQk9UVE9NIiwiVEVYVF9TRUxFQ1RPUiIsIkFDVElPTl9XUkFQUEVSX1NFTEVDVE9SIiwiQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUiIsIlNIT1dfRVZFTlQiLCJISURFX0VWRU5UIiwiTUVTU0FHRV9USU1FT1VUIiwiTURDU25hY2tiYXJGb3VuZGF0aW9uIiwic2V0QXJpYUhpZGRlbiIsInVuc2V0QXJpYUhpZGRlbiIsInNldEFjdGlvbkFyaWFIaWRkZW4iLCJ1bnNldEFjdGlvbkFyaWFIaWRkZW4iLCJzZXRBY3Rpb25UZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJzZXRGb2N1cyIsInZpc2liaWxpdHlJc0hpZGRlbiIsInJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyIiwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJub3RpZnlTaG93Iiwibm90aWZ5SGlkZSIsImFjdGlvbldhc0NsaWNrZWRfIiwiZGlzbWlzc09uQWN0aW9uXyIsImZpcnN0Rm9jdXNfIiwicG9pbnRlckRvd25SZWNvZ25pemVkXyIsInNuYWNrYmFySGFzRm9jdXNfIiwic25hY2tiYXJEYXRhXyIsInF1ZXVlXyIsImFjdGlvbkNsaWNrSGFuZGxlcl8iLCJpbnZva2VBY3Rpb25fIiwidmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfIiwidGltZW91dElkXyIsImNsZWFudXBfIiwidGltZW91dCIsImhhbmRsZVBvc3NpYmxlVGFiS2V5Ym9hcmRGb2N1c18iLCJkaXNtaXNzT25BY3Rpb24iLCJtZXNzYWdlIiwiYWN0aW9uSGFuZGxlciIsImFjdGlvblRleHQiLCJtdWx0aWxpbmUiLCJhY3Rpb25PbkJvdHRvbSIsImFjdGlvbkhhbmRsZXJfIiwic2V0QWN0aW9uSGlkZGVuXyIsImhpamFja0ZvY3VzIiwic2V0Rm9jdXNPbkFjdGlvbl8iLCJhbGxvd0Rpc21pc3NhbCIsInNob3dOZXh0XyIsInNoaWZ0IiwiaXNIaWRkZW4iLCJhbGlnblN0YXJ0IiwiaGlkZGVuIiwiYWN0aW9uSGlkZGVuIiwiYnV0dG9uIiwiZXZlbnRTb3VyY2UiLCJzZXREaXNtaXNzT25BY3Rpb24iLCJkaXNtaXNzZXNPbkFjdGlvbiIsIm1kY1NuYWNrYmFyIiwib25DaGFuZ2VkIiwibWRjU3dpdGNoIiwiTURDVGFiRm91bmRhdGlvbiIsImdldE9mZnNldExlZnQiLCJjb21wdXRlZFdpZHRoXyIsImNvbXB1dGVkTGVmdF8iLCJpc0FjdGl2ZV8iLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2tfIiwiaXNBY3RpdmUiLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJoYXNJY29uIiwiaGFzVGV4dCIsImdldENvbXB1dGVkV2lkdGgiLCJnZXRDb21wdXRlZExlZnQiLCJzZXRBY3RpdmUiLCJpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrIiwicHJldmVudHNEZWZhdWx0T25DbGljayIsInNldFByZXZlbnREZWZhdWx0T25DbGljayIsIm1lYXN1cmVTZWxmIiwib2Zmc2V0TGVmdCIsInRhYiIsIlRBQl9TRUxFQ1RPUiIsIklORElDQVRPUl9TRUxFQ1RPUiIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50IiwidW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50Iiwic2V0U3R5bGVGb3JJbmRpY2F0b3IiLCJnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvciIsImdldE51bWJlck9mVGFicyIsImlzVGFiQWN0aXZlQXRJbmRleCIsInNldFRhYkFjdGl2ZUF0SW5kZXgiLCJpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrRm9yVGFiQXRJbmRleCIsInNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXgiLCJtZWFzdXJlVGFiQXRJbmRleCIsImdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4IiwiZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCIsImlzSW5kaWNhdG9yU2hvd25fIiwiYWN0aXZlVGFiSW5kZXhfIiwiYWN0aXZlVGFiSW5kZXgiLCJmaW5kQWN0aXZlVGFiSW5kZXhfIiwiZm9yRWFjaFRhYkluZGV4XyIsImxheW91dEluZGljYXRvcl8iLCJpc0luZGljYXRvckZpcnN0UmVuZGVyIiwidHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCIsInNjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGgiLCJ0cmFuc2Zvcm1WYWx1ZSIsIml0ZXJhdG9yIiwibnVtVGFicyIsInNob3VsZEJyZWFrIiwicHJldkFjdGl2ZVRhYkluZGV4IiwiaW5kaWNhdG9yUHJpbWFyeSIsImluZGljYXRvckFjY2VudCIsImluZGljYXRvclN0eWxlcyIsInRhYnMiLCJvblNlbGVjdCIsInN3aXRjaFRvVGFiQXRJbmRleCIsImluZGljYXRvciIsInJlc2V0VGFicyIsInRhYkVsZW1lbnRzIiwiX192dWVfXyIsImdldEFjdGl2ZVRhYkluZGV4IiwibWRjVGFiIiwibWRjVGFiQmFyIiwiTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIiLCJBUklBX0hJRERFTiIsIlJPTEUiLCJIRUxQRVJfVEVYVF9QRVJTSVNURU5UIiwiSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0ciLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiIsInJlbW92ZUF0dHIiLCJzZXRDb250ZW50IiwiaXNWYWxpZGF0aW9uIiwiaW5wdXRJc1ZhbGlkIiwiaGVscGVyVGV4dElzUGVyc2lzdGVudCIsImhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2ciLCJ2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5IiwiaGlkZV8iLCJNRENUZXh0RmllbGRJY29uQWRhcHRlciIsIklDT05fRVZFTlQiLCJNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiIsIm5vdGlmeUljb25BY3Rpb24iLCJoYW5kbGVJbnRlcmFjdGlvbiIsIk1EQ1RleHRGaWVsZEFkYXB0ZXIiLCJvYnNlcnZlciIsInNob3VsZFNoYWtlIiwic2hvdWxkRmxvYXQiLCJsYWJlbFdpZHRoIiwiTURDTGluZVJpcHBsZUFkYXB0ZXIiLCJMSU5FX1JJUFBMRV9BQ1RJVkUiLCJMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkciLCJNRENMaW5lUmlwcGxlRm91bmRhdGlvbiIsImhhbmRsZVRyYW5zaXRpb25FbmQiLCJ4Q29vcmRpbmF0ZSIsImF0dHJpYnV0ZVN0cmluZyIsImlzRGVhY3RpdmF0aW5nIiwiTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIiLCJMQUJFTF9TSEFLRSIsIk1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIiwic2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyIsImhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXyIsIk1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciIsIlBBVEhfU0VMRUNUT1IiLCJJRExFX09VVExJTkVfU0VMRUNUT1IiLCJNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24iLCJnZXRIZWlnaHQiLCJzZXRPdXRsaW5lUGF0aEF0dHIiLCJnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUiLCJub3RjaFdpZHRoIiwicmFkaXVzU3R5bGVWYWx1ZSIsInJhZGl1cyIsImNvcm5lcldpZHRoIiwibGVhZGluZ1N0cm9rZUxlbmd0aCIsInBhZGRlZE5vdGNoV2lkdGgiLCJwYXRoTWlkZGxlIiwicGF0aCIsIkFSSUFfQ09OVFJPTFMiLCJJTlBVVF9TRUxFQ1RPUiIsIklDT05fU0VMRUNUT1IiLCJPVVRMSU5FX1NFTEVDVE9SIiwiREVOU0UiLCJGT0NVU0VEIiwiSU5WQUxJRCIsIk9VVExJTkVEIiwiTEFCRUxfU0NBTEUiLCJERU5TRV9MQUJFTF9TQ0FMRSIsIlZBTElEQVRJT05fQVRUUl9XSElURUxJU1QiLCJNRENUZXh0RmllbGRGb3VuZGF0aW9uIiwiaXNWYWxpZCIsImlzQmFkSW5wdXRfIiwicmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJnZXROYXRpdmVJbnB1dCIsImFjdGl2YXRlTGluZVJpcHBsZSIsImRlYWN0aXZhdGVMaW5lUmlwcGxlIiwic2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbiIsInNoYWtlTGFiZWwiLCJnZXRMYWJlbFdpZHRoIiwiaGFzT3V0bGluZSIsInVwZGF0ZU91dGxpbmVQYXRoIiwiZm91bmRhdGlvbk1hcCIsImhlbHBlclRleHRfIiwiaGVscGVyVGV4dCIsImljb25fIiwicmVjZWl2ZWRVc2VySW5wdXRfIiwidXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18iLCJpc1ZhbGlkXyIsImlucHV0Rm9jdXNIYW5kbGVyXyIsImFjdGl2YXRlRm9jdXMiLCJpbnB1dEJsdXJIYW5kbGVyXyIsImRlYWN0aXZhdGVGb2N1cyIsImlucHV0SW5wdXRIYW5kbGVyXyIsImF1dG9Db21wbGV0ZUZvY3VzIiwic2V0UG9pbnRlclhPZmZzZXRfIiwidGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uIiwidmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfIiwibXV0YXRpb25zIiwiaGFuZGxlVmFsaWRhdGlvbkF0dHJpYnV0ZU11dGF0aW9uXyIsInZhbGlkYXRpb25PYnNlcnZlcl8iLCJtdXRhdGlvbnNMaXN0IiwibXV0YXRpb24iLCJzdHlsZVZhbGlkaXR5XyIsImlzRGVuc2UiLCJsYWJlbFNjYWxlIiwic3R5bGVGb2N1c2VkXyIsInVwZGF0ZU91dGxpbmUiLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJ0YXJnZXRDbGllbnRSZWN0IiwiZXZ0Q29vcmRzIiwiY2xpZW50WCIsImNsaWVudFkiLCJpbnB1dCIsImdldE5hdGl2ZUlucHV0XyIsInNob3VsZFJlbW92ZUxhYmVsRmxvYXQiLCJpc05hdGl2ZUlucHV0VmFsaWRfIiwic3R5bGVEaXNhYmxlZF8iLCJ2YWxpZGl0eSIsImJhZElucHV0IiwidmFsaWQiLCJzZXRWYWxpZGl0eSIsImhlbHB0ZXh0IiwiaGVscHRleHRQZXJzaXN0ZW50IiwiaGVscHRleHRWYWxpZGF0aW9uIiwib3V0bGluZSIsImZ1bGx3aWR0aCIsIm1pbmxlbmd0aCIsIm1heGxlbmd0aCIsInJvd3MiLCJjb2xzIiwicmVhZG9ubHkiLCJhdXRvY29tcGxldGUiLCJhdXRvZm9jdXMiLCJyb290Q2xhc3NlcyIsImlucHV0Q2xhc3NlcyIsImJvdHRvbUNsYXNzZXMiLCJoZWxwQ2xhc3NlcyIsIm91dGxpbmVQYXRoQXR0ciIsInNldFZhbGlkIiwiaGVscGVyVGV4dEZvdW5kYXRpb24iLCJzZXRQZXJzaXN0ZW50Iiwic2V0VmFsaWRhdGlvbiIsInVwZGF0ZVZhbHVlIiwiaW5wdXRBdHRycyIsImlucHV0UGxhY2VIb2xkZXIiLCJpbnB1dEFyaWFDb250cm9scyIsImhlbHAiLCJfdWlkIiwiaGFzQm90dG9tTGluZSIsImhhc0xlYWRpbmdJY29uIiwiaGFzVHJhaWxpbmdJY29uIiwibGFiZWxDbGFzc2VzVXBncmFkZWQiLCJpY29uRm91bmRhdGlvbiIsIm91dGxpbmVGb3VuZGF0aW9uIiwiaWRsZU91dGxpbmVFbGVtZW50Iiwib3V0bGluZUlkbGUiLCJNRENUZXh0ZmllbGRGb3VuZGF0aW9uIiwic2V0UmlwcGxlQ2VudGVyIiwidGFyZ2V0Tm9kZSIsImF0dHJpYnV0ZXMiLCJzaGFrZSIsImZsb2F0IiwidXBkYXRlU3ZnUGF0aCIsImJvdHRvbUxpbmUiLCJ0ZXh0Ym94IiwibWRjVGV4dEZpZWxkIiwiVEhFTUVfQ09MT1JTIiwiVEhFTUVfU1RZTEVTIiwiY29sb3IiLCJiYWNrZ3JvdW5kIiwibWRjVGhlbWUiLCJGSVhFRCIsIkZJWEVEX0xBU1RST1ciLCJGSVhFRF9BVF9MQVNUX1JPVyIsIlRPT0xCQVJfUk9XX0ZMRVhJQkxFIiwiRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUiIsIkZMRVhJQkxFX01BWCIsIkZMRVhJQkxFX01JTiIsIlRJVExFX1NFTEVDVE9SIiwiRklSU1RfUk9XX1NFTEVDVE9SIiwiTUFYX1RJVExFX1NJWkUiLCJNSU5fVElUTEVfU0laRSIsIlRPT0xCQVJfUk9XX0hFSUdIVCIsIlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQiLCJUT09MQkFSX01PQklMRV9CUkVBS1BPSU5UIiwiTURDVG9vbGJhckZvdW5kYXRpb24iLCJyZWdpc3RlclNjcm9sbEhhbmRsZXIiLCJkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlciIsImdldFZpZXdwb3J0V2lkdGgiLCJnZXRWaWV3cG9ydFNjcm9sbFkiLCJnZXRPZmZzZXRIZWlnaHQiLCJnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQiLCJzZXRTdHlsZUZvclRpdGxlRWxlbWVudCIsInNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50Iiwic2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQiLCJjaGVja1Jvd0hlaWdodF8iLCJzY3JvbGxIYW5kbGVyXyIsInVwZGF0ZVRvb2xiYXJTdHlsZXNfIiwiY2hlY2tSb3dIZWlnaHRGcmFtZV8iLCJzY3JvbGxGcmFtZV8iLCJleGVjdXRlZExhc3RDaGFuZ2VfIiwiY2FsY3VsYXRpb25zXyIsInRvb2xiYXJSb3dIZWlnaHQiLCJ0b29sYmFyUmF0aW8iLCJmbGV4aWJsZUV4cGFuc2lvblJhdGlvIiwibWF4VHJhbnNsYXRlWVJhdGlvIiwic2Nyb2xsVGhyZXNob2xkUmF0aW8iLCJ0b29sYmFySGVpZ2h0IiwiZmxleGlibGVFeHBhbnNpb25IZWlnaHQiLCJtYXhUcmFuc2xhdGVZRGlzdGFuY2UiLCJzY3JvbGxUaHJlc2hvbGQiLCJmaXhlZF8iLCJmaXhlZExhc3Ryb3dfIiwiaGFzRmxleGlibGVSb3dfIiwidXNlRmxleERlZmF1bHRCZWhhdmlvcl8iLCJpbml0S2V5UmF0aW9fIiwic2V0S2V5SGVpZ2h0c18iLCJzY3JvbGxUb3AiLCJuZXdUb29sYmFyUm93SGVpZ2h0IiwiZ2V0Um93SGVpZ2h0XyIsInVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMiLCJoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkIiwic2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8iLCJnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyIsInVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyIsInVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyIsInVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18iLCJmaXJzdFJvd01heFJhdGlvIiwiYnJlYWtwb2ludCIsInRyYW5zbGF0ZURpc3RhbmNlIiwidXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8iLCJtYXhUaXRsZVNpemUiLCJtaW5UaXRsZVNpemUiLCJjdXJyZW50VGl0bGVTaXplIiwid2F0ZXJmYWxsIiwiZml4ZWRMYXN0cm93IiwiZmxleGlibGUiLCJmbGV4aWJsZURlZmF1bHQiLCJyb290U3R5bGVzIiwiYWRqdXN0U3R5bGVzIiwic2hyaW5rVG9GaXQiLCJtZGNUb29sYmFyIiwibWRjVG9vbGJhclJvdyIsIm1kY1Rvb2xiYXJTZWN0aW9uIiwibWRjVG9vbGJhck1lbnVJY29uIiwibWRjVG9vbGJhclRpdGxlIiwibWRjVG9vbGJhckljb24iLCJOQVZJR0FUSU9OX0VWRU5UIiwiUk9PVF9TRUxFQ1RPUiIsIk5BVklHQVRJT05fSUNPTl9TRUxFQ1RPUiIsIkFDVElPTl9JVEVNX1NFTEVDVE9SIiwiU0hPUlRfQ0xBU1MiLCJTSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MiLCJTSE9SVF9DT0xMQVBTRURfQ0xBU1MiLCJNRENUb3BBcHBCYXJBZGFwdGVyIiwiTURDVG9wQXBwQmFyRm91bmRhdGlvbiIsInJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIiLCJub3RpZnlOYXZpZ2F0aW9uSWNvbkNsaWNrZWQiLCJnZXRUb3RhbEFjdGlvbkl0ZW1zIiwibmF2Q2xpY2tIYW5kbGVyXyIsIk1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiIsImlzQ29sbGFwc2VkIiwic2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXyIsImlzQWx3YXlzQ29sbGFwc2VkIiwiY3VycmVudFNjcm9sbCIsInNob3J0Iiwic2hvcnRDb2xsYXBzZWQiLCJuYXZpZ2F0aW9uSWNvbiIsImhhdmVOYXZpZ2F0aW9uSWNvbiIsIm5hdmljb25DbGFzc2VzIiwiYWN0aW9uaWNvbkNsYXNzZXMiLCJtZGNUb3BBcHBCYXIiLCJtZGNUb3BBcHBCYXJBY3Rpb24iLCJ0eXBvcyIsIm1kY1R5cG9NaXhpbiIsInR5cG8iLCJhZGp1c3RNYXJnaW4iLCIkYXR0cnMiLCJtZGNUeXBvUHJvcE1peGluIiwiZGVmYXVsdFRhZyIsImRlZmF1bHRUeXBvIiwidmFsaWRUeXBvcyIsIm1kY1RleHRTZWN0aW9uIiwibWRjVGV4dCIsIm1kY0Rpc3BsYXkiLCJtZGNIZWFkbGluZSIsIm1kY1RpdGxlIiwibWRjU3ViSGVhZGluZyIsIm1kY0JvZHkiLCJtZGNDYXB0aW9uIiwiVnVlTURDQnV0dG9uIiwiVnVlTURDQ2FyZCIsIlZ1ZU1EQ0NoZWNrYm94IiwiVnVlTURDQ2hpcFNldCIsIlZ1ZU1EQ0RpYWxvZyIsIlZ1ZU1EQ0RyYXdlciIsIlZ1ZU1EQ0VsZXZhdGlvbiIsIlZ1ZU1EQ0ZhYiIsIlZ1ZU1EQ0dyaWRMaXN0IiwiVnVlTURDSWNvbiIsIlZ1ZU1EQ0ljb25Ub2dnbGUiLCJWdWVNRENMYXlvdXRBcHAiLCJWdWVNRENMYXlvdXRHcmlkIiwiVnVlTURDTGluZWFyUHJvZ3Jlc3MiLCJWdWVNRENMaXN0IiwiVnVlTURDTWVudSIsIlZ1ZU1EQ1JhZGlvIiwiVnVlTURDUmlwcGxlIiwiVnVlTURDU2VsZWN0IiwiVnVlTURDU2xpZGVyIiwiVnVlTURDU25hY2tiYXIiLCJWdWVNRENTd2l0Y2giLCJWdWVNRENUYWJzIiwiVnVlTURDVGV4dGZpZWxkIiwiVnVlTURDVGhlbWUiLCJWdWVNRENUb29sYmFyIiwiVnVlTURDVG9wQXBwQmFyIiwiVnVlTURDVHlwb2dyYXBoeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztFQUFPLFNBQVNBLFFBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCO0VBQ2hDO0VBQ0EsTUFBSUMsT0FBTyxJQUFYO0VBQ0EsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0VBQ2pDRCxXQUFPQyxPQUFPQyxHQUFkO0VBQ0QsR0FGRCxNQUVPLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztFQUN4QztFQUNBSCxXQUFPRyxPQUFPRCxHQUFkO0VBQ0Q7RUFDRCxNQUFJRixJQUFKLEVBQVU7RUFDUkEsU0FBS0ksR0FBTCxDQUFTTCxNQUFUO0VBQ0Q7RUFDRjs7RUNaTSxTQUFTTSxVQUFULENBQXFCQyxVQUFyQixFQUFpQztFQUN0QyxTQUFPO0VBQ0xDLGFBQVMsUUFESjtFQUVMQyxhQUFTLGlCQUFDQyxFQUFELEVBQVE7RUFDZixXQUFLLElBQUlDLEdBQVQsSUFBZ0JKLFVBQWhCLEVBQTRCO0VBQzFCLFlBQUlLLFlBQVlMLFdBQVdJLEdBQVgsQ0FBaEI7RUFDRUQsV0FBR0UsU0FBSCxDQUFhQSxVQUFVQyxJQUF2QixFQUE0QkQsU0FBNUI7RUFDSDtFQUNGLEtBUEk7RUFRTEw7RUFSSyxHQUFQO0VBVUQ7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
